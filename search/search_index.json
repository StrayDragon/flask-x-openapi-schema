{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Flask-X-OpenAPI-Schema","text":"<p>A powerful utility for automatically generating OpenAPI schemas from Flask-RESTful resources, Flask.MethodView classes, and Pydantic models to simplify API documentation with minimal effort.</p>"},{"location":"#features","title":"Features","text":"<ul> <li>Framework Support: Works with both Flask and Flask-RESTful applications</li> <li>Auto-Generation: Generate OpenAPI schemas from Flask-RESTful resources and Flask.MethodView classes</li> <li>Pydantic Integration: Seamlessly convert Pydantic models to OpenAPI schemas</li> <li>Smart Parameter Handling: Inject request parameters from Pydantic models with configurable prefixes</li> <li>Type Safety: Preserve type annotations for better IDE support and validation</li> <li>Multiple Formats: Output schemas in YAML or JSON format</li> <li>Internationalization: Built-in i18n support for API documentation with thread-safe language switching</li> <li>File Upload Support: Simplified handling of file uploads with validation</li> <li>Flexible Architecture: Modular design with framework-specific implementations</li> <li>Performance Optimized: Caching of static information for improved performance</li> </ul>"},{"location":"#installation","title":"Installation","text":"<pre><code># Install the package\nuv pip install flask-x-openapi-schema\n\n# With Flask-RESTful support\nuv pip install flask-x-openapi-schema[flask-restful]\n</code></pre>"},{"location":"#quick-start","title":"Quick Start","text":"<p>Check out the Getting Started guide for a quick introduction to using Flask-X-OpenAPI-Schema.</p>"},{"location":"#components","title":"Components","text":"<ul> <li>Core: Base functionality shared across all implementations</li> <li>Schema Generator: Converts resources to OpenAPI schemas</li> <li>Configuration: Configurable parameter prefixes and settings</li> <li>Cache: Performance optimization for schema generation</li> <li>Framework-Specific:</li> <li>Flask: Support for Flask.MethodView classes</li> <li>Flask-RESTful: Support for Flask-RESTful resources</li> <li>Models:</li> <li>Base Models: Type-safe response handling</li> <li>File Models: Simplified file upload handling</li> <li>Internationalization:</li> <li>I18nStr: Multilingual string support</li> <li>Language Management: Thread-safe language switching</li> <li>Utilities: Helper functions for schema creation and manipulation</li> </ul>"},{"location":"#license","title":"License","text":"<p>This project is licensed under the MIT License - see the LICENSE file for details.</p>"},{"location":"architecture/","title":"Architecture","text":"<p>This page describes the architecture of Flask-X-OpenAPI-Schema using Mermaid diagrams.</p>"},{"location":"architecture/#component-overview","title":"Component Overview","text":"<p>The following diagram shows the main components of Flask-X-OpenAPI-Schema and their relationships:</p> <pre><code>graph TD\n    A[Flask Application] --&gt; B[Flask-X-OpenAPI-Schema]\n    B --&gt; C[Core]\n    B --&gt; D[Flask Extensions]\n    B --&gt; E[Flask-RESTful Extensions]\n\n    C --&gt; C1[Schema Generator]\n    C --&gt; C2[Configuration]\n    C --&gt; C3[Cache]\n    C --&gt; C4[Decorator Base]\n    C --&gt; C5[Utilities]\n\n    D --&gt; D1[MethodView Integration]\n    D --&gt; D2[Route Decorators]\n\n    E --&gt; E1[Resource Integration]\n    E --&gt; E2[RequestParser Integration]\n\n    B --&gt; F[Models]\n    F --&gt; F1[Base Models]\n    F --&gt; F2[File Models]\n    F --&gt; F3[Response Models]\n\n    B --&gt; G[Internationalization]\n    G --&gt; G1[I18n String]\n    G --&gt; G2[I18n Model]\n    G --&gt; G3[Language Management]</code></pre>"},{"location":"architecture/#request-flow","title":"Request Flow","text":"<p>The following sequence diagram shows how a request is processed:</p> <pre><code>sequenceDiagram\n    participant Client\n    participant Flask\n    participant Decorator\n    participant SchemaGenerator\n    participant ModelBinder\n    participant Handler\n\n    Client-&gt;&gt;Flask: HTTP Request\n    Flask-&gt;&gt;Decorator: Route Match\n    Decorator-&gt;&gt;SchemaGenerator: Get Schema\n    SchemaGenerator--&gt;&gt;Decorator: Return Schema\n    Decorator-&gt;&gt;ModelBinder: Bind Request Data\n    ModelBinder--&gt;&gt;Decorator: Return Bound Models\n    Decorator-&gt;&gt;Handler: Call with Bound Models\n    Handler--&gt;&gt;Decorator: Return Response\n    Decorator-&gt;&gt;Flask: Format Response\n    Flask--&gt;&gt;Client: HTTP Response</code></pre>"},{"location":"architecture/#class-diagram","title":"Class Diagram","text":"<p>The following class diagram shows the main classes and their relationships:</p> <pre><code>classDiagram\n    class OpenAPIMetadataBase {\n        +summary: str\n        +description: str\n        +tags: List[str]\n        +responses: Dict\n        +__call__(func)\n    }\n\n    class OpenAPIMethodView {\n        +get_openapi_info()\n    }\n\n    class OpenAPIResource {\n        +get_openapi_info()\n    }\n\n    class SchemaGenerator {\n        +generate_schema_from_model(model)\n        +generate_schema_from_function(func)\n    }\n\n    class BaseRespModel {\n        +to_response()\n    }\n\n    class FileUploadModel {\n        +file: FileStorage\n        +validate()\n    }\n\n    class I18nStr {\n        +translations: Dict[str, str]\n        +__str__()\n    }\n\n    OpenAPIMetadataBase &lt;|-- FlaskOpenAPIMetadata\n    OpenAPIMetadataBase &lt;|-- FlaskRESTfulOpenAPIMetadata\n\n    OpenAPIMethodView --&gt; FlaskOpenAPIMetadata\n    OpenAPIResource --&gt; FlaskRESTfulOpenAPIMetadata\n\n    FlaskOpenAPIMetadata --&gt; SchemaGenerator\n    FlaskRESTfulOpenAPIMetadata --&gt; SchemaGenerator\n\n    BaseRespModel &lt;|-- CustomResponseModel\n    FileUploadModel &lt;|-- ImageUploadModel\n    FileUploadModel &lt;|-- AudioUploadModel</code></pre>"},{"location":"architecture/#entity-relationship-diagram","title":"Entity Relationship Diagram","text":"<p>The following ER diagram shows the data model:</p> <pre><code>erDiagram\n    OPENAPI_SCHEMA ||--o{ ENDPOINT : contains\n    ENDPOINT ||--o{ PARAMETER : has\n    ENDPOINT ||--o{ RESPONSE : returns\n    PARAMETER }|--|| MODEL : uses\n    RESPONSE }|--|| MODEL : uses\n    MODEL ||--o{ PROPERTY : has\n\n    OPENAPI_SCHEMA {\n        string title\n        string version\n        string description\n    }\n\n    ENDPOINT {\n        string path\n        string method\n        string summary\n        string description\n        array tags\n    }\n\n    PARAMETER {\n        string name\n        string location\n        string description\n        boolean required\n        string schema_ref\n    }\n\n    RESPONSE {\n        string status_code\n        string description\n        string schema_ref\n    }\n\n    MODEL {\n        string name\n        string type\n        string description\n    }\n\n    PROPERTY {\n        string name\n        string type\n        string description\n        boolean required\n    }</code></pre>"},{"location":"architecture/#state-diagram","title":"State Diagram","text":"<p>The following state diagram shows the lifecycle of a request:</p> <pre><code>stateDiagram-v2\n    [*] --&gt; Received\n    Received --&gt; Parsing\n    Parsing --&gt; Validating\n    Validating --&gt; Processing\n    Processing --&gt; Responding\n    Responding --&gt; [*]\n\n    Parsing --&gt; Error: Invalid Format\n    Validating --&gt; Error: Invalid Data\n    Processing --&gt; Error: Processing Failed\n    Error --&gt; Responding</code></pre>"},{"location":"core_components/","title":"Core Components of Flask-X-OpenAPI-Schema","text":"<p>This document provides an overview of the core components of Flask-X-OpenAPI-Schema and how they work together to generate OpenAPI schemas for Flask and Flask-RESTful applications.</p>"},{"location":"core_components/#architecture-overview","title":"Architecture Overview","text":"<p>Flask-X-OpenAPI-Schema is designed with a modular architecture that separates core functionality from framework-specific implementations. This allows for easy extension to support additional frameworks in the future.</p> <pre><code>graph TD\n    A[Core Components] --&gt; B[Schema Generator]\n    A --&gt; C[Configuration]\n    A --&gt; D[Models]\n    A --&gt; E[Utilities]\n\n    F[Framework-Specific] --&gt; G[Flask Implementation]\n    F --&gt; H[Flask-RESTful Implementation]\n\n    B --&gt; G\n    B --&gt; H\n    C --&gt; G\n    C --&gt; H\n    D --&gt; G\n    D --&gt; H\n    E --&gt; G\n    E --&gt; H</code></pre>"},{"location":"core_components/#key-components","title":"Key Components","text":""},{"location":"core_components/#1-decorators","title":"1. Decorators","text":"<p>The <code>openapi_metadata</code> decorator is the primary interface for adding OpenAPI metadata to your API endpoints. There are separate implementations for Flask and Flask-RESTful:</p> <pre><code># For Flask.MethodView\nfrom flask_x_openapi_schema.x.flask import openapi_metadata\n\n# For Flask-RESTful\nfrom flask_x_openapi_schema.x.flask_restful import openapi_metadata\n</code></pre>"},{"location":"core_components/#usage","title":"Usage","text":"<pre><code>@openapi_metadata(\n    summary=\"Get an item\",\n    description=\"Retrieve an item by its ID\",\n    tags=[\"items\"],\n    operation_id=\"getItem\",\n    responses=OpenAPIMetaResponse(\n        responses={\n            \"200\": OpenAPIMetaResponseItem(\n                model=ItemResponse,\n                description=\"Item retrieved successfully\",\n            ),\n            \"404\": OpenAPIMetaResponseItem(\n                model=ErrorResponse,\n                description=\"Item not found\",\n            ),\n        }\n    ),\n)\ndef get(self, item_id: str):\n    # Implementation...\n</code></pre>"},{"location":"core_components/#2-schema-generator","title":"2. Schema Generator","text":"<p>The schema generator is responsible for converting your API endpoints into OpenAPI schemas. It handles:</p> <ul> <li>Converting Pydantic models to OpenAPI schemas</li> <li>Processing route information</li> <li>Generating path and component definitions</li> <li>Handling parameter binding</li> </ul>"},{"location":"core_components/#flask-implementation","title":"Flask Implementation","text":"<pre><code>from flask_x_openapi_schema.x.flask.views import MethodViewOpenAPISchemaGenerator\n\ngenerator = MethodViewOpenAPISchemaGenerator(\n    title=\"My API\",\n    version=\"1.0.0\",\n    description=\"API description\",\n)\n\n# Process MethodView resources\ngenerator.process_methodview_resources(blueprint)\n\n# Generate the schema\nschema = generator.generate_schema()\n</code></pre>"},{"location":"core_components/#flask-restful-implementation","title":"Flask-RESTful Implementation","text":"<pre><code># Create an OpenAPI-enabled API\nfrom flask_x_openapi_schema.x.flask_restful import OpenAPIIntegrationMixin\nfrom flask_restful import Api\n\nclass OpenAPIApi(OpenAPIIntegrationMixin, Api):\n    pass\n\napi = OpenAPIApi(app)\n\n# Generate the schema\nschema = api.generate_openapi_schema(\n    title=\"My API\",\n    version=\"1.0.0\",\n    description=\"API description\",\n)\n</code></pre>"},{"location":"core_components/#3-parameter-binding","title":"3. Parameter Binding","text":"<p>Flask-X-OpenAPI-Schema uses special prefixes to bind request parameters to function arguments:</p> <ul> <li><code>_x_body</code>: Request body from JSON</li> <li><code>_x_query</code>: Query parameters</li> <li><code>_x_path_&lt;param_name&gt;</code>: Path parameters</li> <li><code>_x_file</code>: File uploads</li> </ul>"},{"location":"core_components/#custom-parameter-prefixes","title":"Custom Parameter Prefixes","text":"<p>You can customize the parameter prefixes using the <code>ConventionalPrefixConfig</code> class:</p> <pre><code>from flask_x_openapi_schema import ConventionalPrefixConfig, configure_prefixes\n\n# Create a custom configuration\ncustom_config = ConventionalPrefixConfig(\n    request_body_prefix=\"req_body\",\n    request_query_prefix=\"req_query\",\n    request_path_prefix=\"req_path\",\n    request_file_prefix=\"req_file\"\n)\n\n# Configure globally\nconfigure_prefixes(custom_config)\n\n# Or per-function\n@openapi_metadata(\n    summary=\"Test endpoint\",\n    prefix_config=custom_config\n)\ndef my_function(req_body: MyModel, req_query: QueryModel):\n    # Use custom prefixes\n    return {\"message\": \"Success\"}\n</code></pre>"},{"location":"core_components/#4-response-models","title":"4. Response Models","text":"<p>Flask-X-OpenAPI-Schema provides a <code>BaseRespModel</code> class for creating response models that can be automatically converted to Flask responses:</p> <pre><code>from flask_x_openapi_schema import BaseRespModel\nfrom pydantic import Field\n\nclass ItemResponse(BaseRespModel):\n    id: str = Field(..., description=\"Item ID\")\n    name: str = Field(..., description=\"Item name\")\n    price: float = Field(..., description=\"Item price\")\n\n# In your endpoint\ndef get(self, item_id: str):\n    # ...\n    return ItemResponse(id=\"123\", name=\"Example\", price=10.99).to_response(200)\n</code></pre>"},{"location":"core_components/#5-openapimetaresponse","title":"5. OpenAPIMetaResponse","text":"<p>The <code>OpenAPIMetaResponse</code> class provides a structured way to define response schemas for different status codes:</p> <pre><code>from flask_x_openapi_schema import OpenAPIMetaResponse, OpenAPIMetaResponseItem\n\n@openapi_metadata(\n    summary=\"Create an item\",\n    responses=OpenAPIMetaResponse(\n        responses={\n            \"201\": OpenAPIMetaResponseItem(\n                model=ItemResponse,\n                description=\"Item created successfully\",\n            ),\n            \"400\": OpenAPIMetaResponseItem(\n                model=ErrorResponse,\n                description=\"Invalid request data\",\n            ),\n            \"500\": OpenAPIMetaResponseItem(\n                model=ErrorResponse,\n                description=\"Internal server error\",\n            ),\n        }\n    ),\n)\ndef post(self, _x_body: ItemRequest):\n    # Implementation...\n</code></pre>"},{"location":"core_components/#integration-with-flask","title":"Integration with Flask","text":""},{"location":"core_components/#1-methodview-integration","title":"1. MethodView Integration","text":"<p>Flask-X-OpenAPI-Schema provides the <code>OpenAPIMethodViewMixin</code> class for integrating with Flask's <code>MethodView</code>:</p> <pre><code>from flask.views import MethodView\nfrom flask_x_openapi_schema.x.flask import OpenAPIMethodViewMixin, openapi_metadata\n\nclass ItemView(OpenAPIMethodViewMixin, MethodView):\n    @openapi_metadata(\n        summary=\"Get all items\",\n        # ...\n    )\n    def get(self):\n        # Implementation...\n\n    @openapi_metadata(\n        summary=\"Create a new item\",\n        # ...\n    )\n    def post(self, _x_body: ItemRequest):\n        # Implementation...\n\n# Register the view\nItemView.register_to_blueprint(blueprint, \"/items\", \"items\")\n</code></pre>"},{"location":"core_components/#2-schema-generation","title":"2. Schema Generation","text":"<pre><code>from flask_x_openapi_schema.x.flask.views import MethodViewOpenAPISchemaGenerator\n\n@app.route(\"/openapi.yaml\")\ndef get_openapi_spec():\n    generator = MethodViewOpenAPISchemaGenerator(\n        title=\"My API\",\n        version=\"1.0.0\",\n        description=\"API description\",\n    )\n\n    # Process MethodView resources\n    generator.process_methodview_resources(blueprint)\n\n    # Generate the schema\n    schema = generator.generate_schema()\n\n    # Convert to YAML\n    import yaml\n    yaml_content = yaml.dump(schema, sort_keys=False, default_flow_style=False)\n\n    return yaml_content, 200, {\"Content-Type\": \"text/yaml\"}\n</code></pre>"},{"location":"core_components/#integration-with-flask-restful","title":"Integration with Flask-RESTful","text":""},{"location":"core_components/#1-resource-integration","title":"1. Resource Integration","text":"<p>Flask-X-OpenAPI-Schema integrates with Flask-RESTful's <code>Resource</code> class:</p> <pre><code>from flask_restful import Resource\nfrom flask_x_openapi_schema.x.flask_restful import openapi_metadata\n\nclass ItemResource(Resource):\n    @openapi_metadata(\n        summary=\"Get an item\",\n        # ...\n    )\n    def get(self, item_id: str):\n        # Implementation...\n\n    @openapi_metadata(\n        summary=\"Update an item\",\n        # ...\n    )\n    def put(self, item_id: str, _x_body: ItemRequest):\n        # Implementation...\n\n# Register the resource\napi.add_resource(ItemResource, \"/items/&lt;string:item_id&gt;\")\n</code></pre>"},{"location":"core_components/#2-api-integration","title":"2. API Integration","text":"<p>Flask-X-OpenAPI-Schema provides the <code>OpenAPIIntegrationMixin</code> class for integrating with Flask-RESTful's <code>Api</code>:</p> <pre><code>from flask_restful import Api\nfrom flask_x_openapi_schema.x.flask_restful import OpenAPIIntegrationMixin\n\nclass OpenAPIApi(OpenAPIIntegrationMixin, Api):\n    pass\n\napi = OpenAPIApi(app)\n\n# Register resources\n# ...\n\n# Generate OpenAPI schema\n@app.route(\"/openapi.yaml\")\ndef get_openapi_spec():\n    schema = api.generate_openapi_schema(\n        title=\"My API\",\n        version=\"1.0.0\",\n        description=\"API description\",\n    )\n\n    # Convert to YAML\n    import yaml\n    yaml_content = yaml.dump(schema, sort_keys=False, default_flow_style=False)\n\n    return yaml_content, 200, {\"Content-Type\": \"text/yaml\"}\n</code></pre>"},{"location":"core_components/#performance-optimization","title":"Performance Optimization","text":"<p>Flask-X-OpenAPI-Schema includes several performance optimizations:</p> <ol> <li>Caching: Static information is cached to improve performance, especially for OpenAPI documentation generation.</li> <li>Lazy Loading: Components are loaded only when needed.</li> <li>Efficient Parameter Binding: Parameters are bound efficiently using type annotations.</li> </ol>"},{"location":"core_components/#conclusion","title":"Conclusion","text":"<p>The core components of Flask-X-OpenAPI-Schema work together to provide a powerful and flexible system for generating OpenAPI schemas from Flask and Flask-RESTful applications. By separating core functionality from framework-specific implementations, the library can be easily extended to support additional frameworks in the future.</p>"},{"location":"file_uploads/","title":"File Upload Support in Flask-X-OpenAPI-Schema","text":"<p>This document explains how to use the file upload functionality in Flask-X-OpenAPI-Schema with both Flask and Flask-RESTful applications.</p>"},{"location":"file_uploads/#overview","title":"Overview","text":"<p>Flask-X-OpenAPI-Schema provides built-in support for file uploads, making it easy to handle file uploads in your API endpoints. The library includes:</p> <ol> <li>File Upload Models: Pre-defined Pydantic models for common file types</li> <li>Automatic File Injection: Files are automatically injected into your handler functions</li> <li>OpenAPI Schema Generation: File upload fields are properly documented in the OpenAPI schema</li> <li>Validation: File uploads can be validated based on content type, size, etc.</li> </ol>"},{"location":"file_uploads/#file-upload-models","title":"File Upload Models","text":"<p>Flask-X-OpenAPI-Schema provides several pre-defined file upload models:</p> <pre><code>from flask_x_openapi_schema import (\n    FileUploadModel,          # Generic file upload\n    ImageUploadModel,         # Image files (png, jpg, etc.)\n    DocumentUploadModel,      # Document files (pdf, docx, etc.)\n    AudioUploadModel,         # Audio files (mp3, wav, etc.)\n    VideoUploadModel,         # Video files (mp4, avi, etc.)\n)\n</code></pre> <p>You can also create custom file upload models by extending the base <code>FileUploadModel</code> class:</p> <pre><code>from flask_x_openapi_schema import FileUploadModel\nfrom pydantic import Field\n\nclass CustomFileUpload(FileUploadModel):\n    description: str = Field(..., description=\"File description\")\n    category: str = Field(..., description=\"File category\")\n\n    # Customize allowed content types\n    allowed_content_types = [\"application/pdf\", \"application/msword\"]\n\n    # Customize maximum file size (in bytes)\n    max_size = 10 * 1024 * 1024  # 10 MB\n</code></pre>"},{"location":"file_uploads/#basic-usage","title":"Basic Usage","text":""},{"location":"file_uploads/#with-flaskmethodview","title":"With Flask.MethodView","text":"<pre><code>from flask.views import MethodView\nfrom flask_x_openapi_schema.x.flask import openapi_metadata, OpenAPIMethodViewMixin\nfrom flask_x_openapi_schema import ImageUploadModel, OpenAPIMetaResponse, OpenAPIMetaResponseItem\n\nclass FileUploadView(OpenAPIMethodViewMixin, MethodView):\n    @openapi_metadata(\n        summary=\"Upload an image\",\n        description=\"Upload an image file\",\n        tags=[\"files\"],\n        operation_id=\"uploadImage\",\n        responses=OpenAPIMetaResponse(\n            responses={\n                \"201\": OpenAPIMetaResponseItem(\n                    model=FileResponse,\n                    description=\"File uploaded successfully\",\n                ),\n                \"400\": OpenAPIMetaResponseItem(\n                    model=ErrorResponse,\n                    description=\"Invalid file\",\n                ),\n            }\n        ),\n    )\n    def post(self, _x_file: ImageUploadModel):\n        # The file is automatically injected into _x_file.file\n        file = _x_file.file\n\n        # Access file properties\n        filename = file.filename\n        content_type = file.content_type\n\n        # Save the file\n        file.save(f\"uploads/{filename}\")\n\n        # Return response\n        return {\n            \"filename\": filename,\n            \"content_type\": content_type,\n            \"size\": os.path.getsize(f\"uploads/{filename}\"),\n        }, 201\n\n# Register the view\nFileUploadView.register_to_blueprint(blueprint, \"/upload\", \"file_upload\")\n</code></pre>"},{"location":"file_uploads/#with-flask-restful","title":"With Flask-RESTful","text":"<pre><code>from flask_restful import Resource\nfrom flask_x_openapi_schema.x.flask_restful import openapi_metadata\nfrom flask_x_openapi_schema import DocumentUploadModel, OpenAPIMetaResponse, OpenAPIMetaResponseItem\n\nclass DocumentUploadResource(Resource):\n    @openapi_metadata(\n        summary=\"Upload a document\",\n        description=\"Upload a document file (PDF, DOCX, etc.)\",\n        tags=[\"files\"],\n        operation_id=\"uploadDocument\",\n        responses=OpenAPIMetaResponse(\n            responses={\n                \"201\": OpenAPIMetaResponseItem(\n                    model=FileResponse,\n                    description=\"File uploaded successfully\",\n                ),\n                \"400\": OpenAPIMetaResponseItem(\n                    model=ErrorResponse,\n                    description=\"Invalid file\",\n                ),\n            }\n        ),\n    )\n    def post(self, _x_file: DocumentUploadModel):\n        # The file is automatically injected into _x_file.file\n        file = _x_file.file\n\n        # Access file properties\n        filename = file.filename\n        content_type = file.content_type\n\n        # Save the file\n        file.save(f\"uploads/{filename}\")\n\n        # Return response\n        return {\n            \"filename\": filename,\n            \"content_type\": content_type,\n            \"size\": os.path.getsize(f\"uploads/{filename}\"),\n        }, 201\n\n# Register the resource\napi.add_resource(DocumentUploadResource, \"/upload/document\")\n</code></pre>"},{"location":"file_uploads/#advanced-usage","title":"Advanced Usage","text":""},{"location":"file_uploads/#custom-file-parameter-names","title":"Custom File Parameter Names","text":"<p>By default, Flask-X-OpenAPI-Schema uses the parameter name <code>_x_file</code> for file uploads. You can customize this by using a different parameter name with the <code>_x_file_</code> prefix:</p> <pre><code>@openapi_metadata(\n    summary=\"Upload a profile picture\",\n    # ...\n)\ndef post(self, _x_file_profile_picture: ImageUploadModel):\n    # The file is automatically injected into _x_file_profile_picture.file\n    file = _x_file_profile_picture.file\n    # ...\n</code></pre>"},{"location":"file_uploads/#multiple-file-uploads","title":"Multiple File Uploads","text":"<p>You can handle multiple file uploads by using different parameter names:</p> <pre><code>@openapi_metadata(\n    summary=\"Upload product files\",\n    # ...\n)\ndef post(\n    self,\n    _x_file_image: ImageUploadModel,\n    _x_file_document: DocumentUploadModel,\n    _x_file_video: VideoUploadModel\n):\n    # Access each file\n    image = _x_file_image.file\n    document = _x_file_document.file\n    video = _x_file_video.file\n\n    # Process files\n    # ...\n</code></pre>"},{"location":"file_uploads/#file-validation","title":"File Validation","text":"<p>File upload models include built-in validation for content type and file size:</p> <pre><code>from flask_x_openapi_schema import FileUploadModel\nfrom pydantic import Field, validator\n\nclass StrictPDFUpload(FileUploadModel):\n    title: str = Field(..., description=\"Document title\")\n\n    # Define allowed content types\n    allowed_content_types = [\"application/pdf\"]\n\n    # Define maximum file size (5 MB)\n    max_size = 5 * 1024 * 1024\n\n    # Custom validation\n    @validator(\"file\")\n    def validate_file(cls, file):\n        if not file or not hasattr(file, \"filename\"):\n            raise ValueError(\"File is required\")\n\n        if not file.filename.lower().endswith(\".pdf\"):\n            raise ValueError(\"Only PDF files are allowed\")\n\n        return file\n</code></pre>"},{"location":"file_uploads/#custom-file-processing","title":"Custom File Processing","text":"<p>You can add custom processing logic to your file upload models:</p> <pre><code>from flask_x_openapi_schema import ImageUploadModel\nfrom PIL import Image\nimport io\n\nclass ResizedImageUpload(ImageUploadModel):\n    width: int = Field(..., description=\"Target width\")\n    height: int = Field(..., description=\"Target height\")\n\n    def process_image(self):\n        \"\"\"Resize the uploaded image to the specified dimensions.\"\"\"\n        if not self.file:\n            return None\n\n        # Read the image\n        img = Image.open(self.file)\n\n        # Resize the image\n        resized_img = img.resize((self.width, self.height))\n\n        # Save to a buffer\n        buffer = io.BytesIO()\n        resized_img.save(buffer, format=img.format)\n        buffer.seek(0)\n\n        return buffer\n</code></pre>"},{"location":"file_uploads/#openapi-schema-generation","title":"OpenAPI Schema Generation","text":"<p>Flask-X-OpenAPI-Schema automatically generates the correct OpenAPI schema for file upload endpoints. File upload fields are rendered as file upload buttons in Swagger UI, making it easy for users to test your API.</p>"},{"location":"file_uploads/#example-schema","title":"Example Schema","text":"<pre><code>paths:\n  /upload:\n    post:\n      summary: Upload an image\n      description: Upload an image file\n      tags:\n        - files\n      operationId: uploadImage\n      requestBody:\n        content:\n          multipart/form-data:\n            schema:\n              type: object\n              properties:\n                file:\n                  type: string\n                  format: binary\n                  description: Image file to upload\n      responses:\n        '201':\n          description: File uploaded successfully\n          content:\n            application/json:\n              schema:\n                $ref: '#/components/schemas/FileResponse'\n        '400':\n          description: Invalid file\n          content:\n            application/json:\n              schema:\n                $ref: '#/components/schemas/ErrorResponse'\n</code></pre>"},{"location":"file_uploads/#complete-example","title":"Complete Example","text":"<p>Here's a complete example of a file upload endpoint with Flask.MethodView:</p> <pre><code>import os\nimport uuid\nfrom pathlib import Path\nfrom flask import Flask, Blueprint, url_for\nfrom flask.views import MethodView\nfrom flask_x_openapi_schema.x.flask import openapi_metadata, OpenAPIMethodViewMixin\nfrom flask_x_openapi_schema import (\n    ImageUploadModel,\n    OpenAPIMetaResponse,\n    OpenAPIMetaResponseItem,\n    BaseRespModel,\n)\nfrom pydantic import Field\nfrom datetime import datetime\n\n# Create uploads directory\nuploads_dir = Path(\"uploads\")\nuploads_dir.mkdir(exist_ok=True)\n\n# Define response model\nclass FileResponse(BaseRespModel):\n    id: str = Field(..., description=\"File ID\")\n    filename: str = Field(..., description=\"Original filename\")\n    content_type: str = Field(..., description=\"File content type\")\n    size: int = Field(..., description=\"File size in bytes\")\n    upload_date: datetime = Field(..., description=\"Upload date and time\")\n    url: str = Field(..., description=\"File download URL\")\n\n# Define error response model\nclass ErrorResponse(BaseRespModel):\n    error_code: str = Field(..., description=\"Error code\")\n    message: str = Field(..., description=\"Error message\")\n\n# Define custom image upload model\nclass ProductImageUpload(ImageUploadModel):\n    description: str = Field(..., description=\"Image description\")\n    is_primary: bool = Field(False, description=\"Whether this is the primary product image\")\n\n# Create a view for image uploads\nclass ProductImageView(OpenAPIMethodViewMixin, MethodView):\n    @openapi_metadata(\n        summary=\"Upload a product image\",\n        description=\"Upload an image for a specific product\",\n        tags=[\"files\"],\n        operation_id=\"uploadProductImage\",\n        responses=OpenAPIMetaResponse(\n            responses={\n                \"201\": OpenAPIMetaResponseItem(\n                    model=FileResponse,\n                    description=\"Image uploaded successfully\",\n                ),\n                \"400\": OpenAPIMetaResponseItem(\n                    model=ErrorResponse,\n                    description=\"Invalid request data\",\n                ),\n                \"404\": OpenAPIMetaResponseItem(\n                    model=ErrorResponse,\n                    description=\"Product not found\",\n                ),\n            }\n        ),\n    )\n    def post(self, product_id: str, _x_file_image: ProductImageUpload):\n        # The file is automatically injected into _x_file_image.file\n        file = _x_file_image.file\n\n        # Check if product exists (in a real app, you would query a database)\n        if product_id not in [\"123\", \"456\", \"789\"]:\n            error = ErrorResponse(\n                error_code=\"PRODUCT_NOT_FOUND\",\n                message=f\"Product with ID {product_id} not found\",\n            )\n            return error.to_response(404)\n\n        # Save the file\n        file_id = str(uuid.uuid4())\n        filename = file.filename\n        content_type = file.content_type or \"application/octet-stream\"\n\n        # Create product-specific directory\n        product_dir = uploads_dir / product_id\n        product_dir.mkdir(exist_ok=True)\n\n        # Save file to disk\n        file_path = product_dir / f\"{file_id}_{filename}\"\n        file.save(file_path)\n\n        # Get file size\n        size = os.path.getsize(file_path)\n\n        # Create response\n        response = FileResponse(\n            id=file_id,\n            filename=filename,\n            content_type=content_type,\n            size=size,\n            upload_date=datetime.now(),\n            url=url_for(\"api.download_file\", file_id=file_id, _external=True),\n        )\n\n        return response.to_response(201)\n</code></pre>"},{"location":"file_uploads/#working-examples","title":"Working Examples","text":"<p>For complete working examples of file uploads, check out the example applications in the repository:</p> <ul> <li>Flask MethodView File Upload Example: Demonstrates image, document, audio, and video uploads using Flask.MethodView</li> <li>Flask-RESTful File Upload Example: Demonstrates image, document, audio, and video uploads using Flask-RESTful</li> </ul> <p>These examples show how to:</p> <ul> <li>Define file upload models for different file types</li> <li>Handle file uploads with validation</li> <li>Save uploaded files to disk</li> <li>Return appropriate responses</li> <li>Generate OpenAPI schema for file upload endpoints</li> </ul> <p>You can run the examples using the provided justfile commands:</p> <pre><code># Run the Flask MethodView example\njust run-example-flask\n\n# Run the Flask-RESTful example\njust run-example-flask-restful\n</code></pre>"},{"location":"file_uploads/#conclusion","title":"Conclusion","text":"<p>Flask-X-OpenAPI-Schema provides comprehensive support for file uploads in both Flask and Flask-RESTful applications. By using the built-in file upload models and automatic file injection, you can easily handle file uploads in your API endpoints with minimal code. The library also generates the correct OpenAPI schema for file upload endpoints, making it easy for users to test your API.</p>"},{"location":"getting_started/","title":"Getting Started with Flask-X-OpenAPI-Schema","text":"<p>This guide will help you get started with Flask-X-OpenAPI-Schema, a powerful utility for automatically generating OpenAPI schemas from Flask and Flask-RESTful applications.</p>"},{"location":"getting_started/#installation","title":"Installation","text":""},{"location":"getting_started/#basic-installation","title":"Basic Installation","text":"<pre><code># Using pip\npip install flask-x-openapi-schema\n\n# Using uv\nuv pip install flask-x-openapi-schema\n</code></pre>"},{"location":"getting_started/#with-flask-restful-support","title":"With Flask-RESTful Support","text":"<pre><code># Using pip\npip install flask-x-openapi-schema[flask-restful]\n\n# Using uv\nuv pip install flask-x-openapi-schema[flask-restful]\n</code></pre>"},{"location":"getting_started/#basic-usage","title":"Basic Usage","text":"<p>Flask-X-OpenAPI-Schema provides separate implementations for Flask and Flask-RESTful. Choose the one that matches your application.</p>"},{"location":"getting_started/#with-flaskmethodview","title":"With Flask.MethodView","text":"<pre><code>from flask import Flask, Blueprint, jsonify\nfrom flask.views import MethodView\nfrom pydantic import BaseModel, Field\n\nfrom flask_x_openapi_schema.x.flask import openapi_metadata, OpenAPIMethodViewMixin\nfrom flask_x_openapi_schema import OpenAPIMetaResponse, OpenAPIMetaResponseItem\n\n# Define request and response models\nclass ItemRequest(BaseModel):\n    name: str = Field(..., description=\"Item name\")\n    description: str = Field(None, description=\"Item description\")\n    price: float = Field(..., description=\"Item price\")\n\nclass ItemResponse(BaseModel):\n    id: str = Field(..., description=\"Item ID\")\n    name: str = Field(..., description=\"Item name\")\n    description: str = Field(None, description=\"Item description\")\n    price: float = Field(..., description=\"Item price\")\n\n# Create a Flask app\napp = Flask(__name__)\nblueprint = Blueprint(\"api\", __name__, url_prefix=\"/api\")\n\n# Create a MethodView class\nclass ItemView(OpenAPIMethodViewMixin, MethodView):\n    @openapi_metadata(\n        summary=\"Get all items\",\n        description=\"Retrieve a list of all items\",\n        tags=[\"items\"],\n        operation_id=\"getItems\",\n        responses=OpenAPIMetaResponse(\n            responses={\n                \"200\": OpenAPIMetaResponseItem(\n                    model=ItemResponse,\n                    description=\"List of items retrieved successfully\",\n                ),\n            }\n        ),\n    )\n    def get(self):\n        # Implementation...\n        items = [\n            {\"id\": \"1\", \"name\": \"Item 1\", \"description\": \"First item\", \"price\": 10.99},\n            {\"id\": \"2\", \"name\": \"Item 2\", \"description\": \"Second item\", \"price\": 20.99},\n        ]\n        return jsonify(items), 200\n\n    @openapi_metadata(\n        summary=\"Create a new item\",\n        description=\"Create a new item with the provided information\",\n        tags=[\"items\"],\n        operation_id=\"createItem\",\n        responses=OpenAPIMetaResponse(\n            responses={\n                \"201\": OpenAPIMetaResponseItem(\n                    model=ItemResponse,\n                    description=\"Item created successfully\",\n                ),\n                \"400\": OpenAPIMetaResponseItem(\n                    description=\"Invalid request data\",\n                ),\n            }\n        ),\n    )\n    def post(self, _x_body: ItemRequest):\n        # Implementation...\n        # _x_body is automatically populated from the request JSON\n        item = {\n            \"id\": \"3\",\n            \"name\": _x_body.name,\n            \"description\": _x_body.description,\n            \"price\": _x_body.price,\n        }\n        return jsonify(item), 201\n\n# Register the view\nItemView.register_to_blueprint(blueprint, \"/items\", \"items\")\n\n# Register the blueprint\napp.register_blueprint(blueprint)\n\n# Generate OpenAPI schema\n@app.route(\"/openapi.yaml\")\ndef get_openapi_spec():\n    from flask_x_openapi_schema.x.flask.views import MethodViewOpenAPISchemaGenerator\n    import yaml\n\n    generator = MethodViewOpenAPISchemaGenerator(\n        title=\"My API\",\n        version=\"1.0.0\",\n        description=\"API for managing items\",\n    )\n\n    # Process MethodView resources\n    generator.process_methodview_resources(blueprint)\n\n    # Generate the schema\n    schema = generator.generate_schema()\n\n    # Convert to YAML\n    yaml_content = yaml.dump(schema, sort_keys=False, default_flow_style=False)\n\n    return yaml_content, 200, {\"Content-Type\": \"text/yaml\"}\n\n# Serve Swagger UI\n@app.route(\"/\")\ndef index():\n    return \"\"\"\n    &lt;!DOCTYPE html&gt;\n    &lt;html&gt;\n    &lt;head&gt;\n        &lt;title&gt;API Documentation&lt;/title&gt;\n        &lt;link rel=\"stylesheet\" type=\"text/css\" href=\"https://cdnjs.cloudflare.com/ajax/libs/swagger-ui/5.9.1/swagger-ui.min.css\"&gt;\n    &lt;/head&gt;\n    &lt;body&gt;\n        &lt;div id=\"swagger-ui\"&gt;&lt;/div&gt;\n        &lt;script src=\"https://cdnjs.cloudflare.com/ajax/libs/swagger-ui/5.9.1/swagger-ui-bundle.min.js\"&gt;&lt;/script&gt;\n        &lt;script&gt;\n            window.onload = function() {\n                SwaggerUIBundle({\n                    url: \"/openapi.yaml\",\n                    dom_id: \"#swagger-ui\",\n                    presets: [\n                        SwaggerUIBundle.presets.apis,\n                        SwaggerUIBundle.SwaggerUIStandalonePreset\n                    ],\n                    layout: \"BaseLayout\"\n                });\n            }\n        &lt;/script&gt;\n    &lt;/body&gt;\n    &lt;/html&gt;\n    \"\"\"\n\nif __name__ == \"__main__\":\n    app.run(debug=True)\n</code></pre>"},{"location":"getting_started/#with-flask-restful","title":"With Flask-RESTful","text":"<pre><code>from flask import Flask\nfrom flask_restful import Resource\nfrom pydantic import BaseModel, Field\n\nfrom flask_x_openapi_schema.x.flask_restful import openapi_metadata, OpenAPIIntegrationMixin\nfrom flask_x_openapi_schema import OpenAPIMetaResponse, OpenAPIMetaResponseItem\n\n# Define request and response models\nclass ItemRequest(BaseModel):\n    name: str = Field(..., description=\"Item name\")\n    description: str = Field(None, description=\"Item description\")\n    price: float = Field(..., description=\"Item price\")\n\nclass ItemResponse(BaseModel):\n    id: str = Field(..., description=\"Item ID\")\n    name: str = Field(..., description=\"Item name\")\n    description: str = Field(None, description=\"Item description\")\n    price: float = Field(..., description=\"Item price\")\n\n# Create a Flask app\napp = Flask(__name__)\n\n# Create an OpenAPI-enabled API\nclass OpenAPIApi(OpenAPIIntegrationMixin, Api):\n    pass\n\napi = OpenAPIApi(app)\n\n# Create a resource\nclass ItemListResource(Resource):\n    @openapi_metadata(\n        summary=\"Get all items\",\n        description=\"Retrieve a list of all items\",\n        tags=[\"items\"],\n        operation_id=\"getItems\",\n        responses=OpenAPIMetaResponse(\n            responses={\n                \"200\": OpenAPIMetaResponseItem(\n                    model=ItemResponse,\n                    description=\"List of items retrieved successfully\",\n                ),\n            }\n        ),\n    )\n    def get(self):\n        # Implementation...\n        items = [\n            {\"id\": \"1\", \"name\": \"Item 1\", \"description\": \"First item\", \"price\": 10.99},\n            {\"id\": \"2\", \"name\": \"Item 2\", \"description\": \"Second item\", \"price\": 20.99},\n        ]\n        return items, 200\n\n    @openapi_metadata(\n        summary=\"Create a new item\",\n        description=\"Create a new item with the provided information\",\n        tags=[\"items\"],\n        operation_id=\"createItem\",\n        responses=OpenAPIMetaResponse(\n            responses={\n                \"201\": OpenAPIMetaResponseItem(\n                    model=ItemResponse,\n                    description=\"Item created successfully\",\n                ),\n                \"400\": OpenAPIMetaResponseItem(\n                    description=\"Invalid request data\",\n                ),\n            }\n        ),\n    )\n    def post(self, _x_body: ItemRequest):\n        # Implementation...\n        # _x_body is automatically populated from the request JSON\n        item = {\n            \"id\": \"3\",\n            \"name\": _x_body.name,\n            \"description\": _x_body.description,\n            \"price\": _x_body.price,\n        }\n        return item, 201\n\nclass ItemResource(Resource):\n    @openapi_metadata(\n        summary=\"Get an item by ID\",\n        description=\"Retrieve an item by its unique identifier\",\n        tags=[\"items\"],\n        operation_id=\"getItem\",\n        responses=OpenAPIMetaResponse(\n            responses={\n                \"200\": OpenAPIMetaResponseItem(\n                    model=ItemResponse,\n                    description=\"Item retrieved successfully\",\n                ),\n                \"404\": OpenAPIMetaResponseItem(\n                    description=\"Item not found\",\n                ),\n            }\n        ),\n    )\n    def get(self, item_id: str):\n        # Implementation...\n        if item_id not in [\"1\", \"2\"]:\n            return {\"error\": \"Item not found\"}, 404\n\n        item = {\n            \"id\": item_id,\n            \"name\": f\"Item {item_id}\",\n            \"description\": f\"Item {item_id} description\",\n            \"price\": float(item_id) * 10.99,\n        }\n        return item, 200\n\n# Register the resources\napi.add_resource(ItemListResource, \"/api/items\")\napi.add_resource(ItemResource, \"/api/items/&lt;string:item_id&gt;\")\n\n# Generate OpenAPI schema\n@app.route(\"/openapi.yaml\")\ndef get_openapi_spec():\n    import yaml\n\n    schema = api.generate_openapi_schema(\n        title=\"My API\",\n        version=\"1.0.0\",\n        description=\"API for managing items\",\n        output_format=\"json\",\n    )\n\n    # Convert to YAML\n    yaml_content = yaml.dump(schema, sort_keys=False, default_flow_style=False)\n\n    return yaml_content, 200, {\"Content-Type\": \"text/yaml\"}\n\n# Serve Swagger UI\n@app.route(\"/\")\ndef index():\n    return \"\"\"\n    &lt;!DOCTYPE html&gt;\n    &lt;html&gt;\n    &lt;head&gt;\n        &lt;title&gt;API Documentation&lt;/title&gt;\n        &lt;link rel=\"stylesheet\" type=\"text/css\" href=\"https://cdnjs.cloudflare.com/ajax/libs/swagger-ui/5.9.1/swagger-ui.min.css\"&gt;\n    &lt;/head&gt;\n    &lt;body&gt;\n        &lt;div id=\"swagger-ui\"&gt;&lt;/div&gt;\n        &lt;script src=\"https://cdnjs.cloudflare.com/ajax/libs/swagger-ui/5.9.1/swagger-ui-bundle.min.js\"&gt;&lt;/script&gt;\n        &lt;script&gt;\n            window.onload = function() {\n                SwaggerUIBundle({\n                    url: \"/openapi.yaml\",\n                    dom_id: \"#swagger-ui\",\n                    presets: [\n                        SwaggerUIBundle.presets.apis,\n                        SwaggerUIBundle.SwaggerUIStandalonePreset\n                    ],\n                    layout: \"BaseLayout\"\n                });\n            }\n        &lt;/script&gt;\n    &lt;/body&gt;\n    &lt;/html&gt;\n    \"\"\"\n\nif __name__ == \"__main__\":\n    app.run(debug=True)\n</code></pre>"},{"location":"getting_started/#parameter-binding","title":"Parameter Binding","text":"<p>Flask-X-OpenAPI-Schema uses special prefixes to bind request parameters to function arguments:</p>"},{"location":"getting_started/#request-body","title":"Request Body","text":"<p>Use the <code>_x_body</code> prefix to bind the request body:</p> <pre><code>@openapi_metadata(\n    summary=\"Create a new item\",\n    # ...\n)\ndef post(self, _x_body: ItemRequest):\n    # _x_body is automatically populated from the request JSON\n    item = {\n        \"id\": \"3\",\n        \"name\": _x_body.name,\n        \"description\": _x_body.description,\n        \"price\": _x_body.price,\n    }\n    return item, 201\n</code></pre>"},{"location":"getting_started/#query-parameters","title":"Query Parameters","text":"<p>Use the <code>_x_query</code> prefix to bind query parameters:</p> <pre><code>class ItemQueryParams(BaseModel):\n    category: str = Field(None, description=\"Filter by category\")\n    min_price: float = Field(None, description=\"Minimum price\")\n    max_price: float = Field(None, description=\"Maximum price\")\n\n@openapi_metadata(\n    summary=\"Get all items\",\n    # ...\n)\ndef get(self, _x_query: ItemQueryParams = None):\n    # _x_query is automatically populated from the query parameters\n    items = [...]\n\n    if _x_query:\n        if _x_query.category:\n            items = [item for item in items if item[\"category\"] == _x_query.category]\n\n        if _x_query.min_price is not None:\n            items = [item for item in items if item[\"price\"] &gt;= _x_query.min_price]\n\n        if _x_query.max_price is not None:\n            items = [item for item in items if item[\"price\"] &lt;= _x_query.max_price]\n\n    return items, 200\n</code></pre>"},{"location":"getting_started/#path-parameters","title":"Path Parameters","text":"<p>Path parameters are automatically bound to function arguments with matching names:</p> <pre><code>@openapi_metadata(\n    summary=\"Get an item by ID\",\n    # ...\n)\ndef get(self, item_id: str):\n    # item_id is automatically populated from the path parameter\n    if item_id not in [\"1\", \"2\"]:\n        return {\"error\": \"Item not found\"}, 404\n\n    item = {\n        \"id\": item_id,\n        \"name\": f\"Item {item_id}\",\n        \"description\": f\"Item {item_id} description\",\n        \"price\": float(item_id) * 10.99,\n    }\n    return item, 200\n</code></pre>"},{"location":"getting_started/#file-uploads","title":"File Uploads","text":"<p>Use the <code>_x_file</code> prefix to bind file uploads:</p> <pre><code>from flask_x_openapi_schema import ImageUploadModel\n\n@openapi_metadata(\n    summary=\"Upload an item image\",\n    # ...\n)\ndef post(self, item_id: str, _x_file: ImageUploadModel):\n    # _x_file.file is automatically populated from the uploaded file\n    file = _x_file.file\n\n    # Save the file\n    file.save(f\"uploads/{item_id}_{file.filename}\")\n\n    return {\"message\": \"File uploaded successfully\"}, 201\n</code></pre>"},{"location":"getting_started/#response-models","title":"Response Models","text":"<p>Flask-X-OpenAPI-Schema provides a <code>BaseRespModel</code> class for creating response models that can be automatically converted to Flask responses:</p> <pre><code>from flask_x_openapi_schema import BaseRespModel\nfrom pydantic import Field\n\nclass ItemResponse(BaseRespModel):\n    id: str = Field(..., description=\"Item ID\")\n    name: str = Field(..., description=\"Item name\")\n    description: str = Field(None, description=\"Item description\")\n    price: float = Field(..., description=\"Item price\")\n\n@openapi_metadata(\n    summary=\"Get an item by ID\",\n    # ...\n)\ndef get(self, item_id: str):\n    # ...\n    response = ItemResponse(\n        id=item_id,\n        name=f\"Item {item_id}\",\n        description=f\"Item {item_id} description\",\n        price=float(item_id) * 10.99,\n    )\n\n    # Convert to Flask response\n    return response.to_response(200)\n</code></pre>"},{"location":"getting_started/#complete-examples","title":"Complete Examples","text":"<p>For complete working examples, check out the example applications in the repository:</p> <ul> <li>Flask MethodView Example: A complete example using Flask.MethodView</li> <li>Flask-RESTful Example: A complete example using Flask-RESTful</li> <li>Response Example (Flask): Example demonstrating structured responses with OpenAPIMetaResponse</li> <li>Response Example (Flask-RESTful): Example demonstrating structured responses with OpenAPIMetaResponse</li> </ul> <p>These examples demonstrate all the features of the library, including:</p> <ul> <li>Parameter binding (path, query, body)</li> <li>File uploads (images, documents, audio, video)</li> <li>Internationalization</li> <li>Response models</li> <li>OpenAPI schema generation</li> </ul> <p>You can run the examples using the provided justfile commands:</p> <pre><code># Run the basic Flask MethodView example\njust run-example-flask\n\n# Run the basic Flask-RESTful example\njust run-example-flask-restful\n</code></pre>"},{"location":"getting_started/#next-steps","title":"Next Steps","text":"<p>Now that you've learned the basics of Flask-X-OpenAPI-Schema, you can explore more advanced features:</p> <ul> <li>Core Components: Learn about the core components of Flask-X-OpenAPI-Schema</li> <li>File Uploads: Learn how to handle file uploads</li> <li>Internationalization: Learn how to create multilingual API documentation</li> </ul>"},{"location":"internationalization/","title":"Internationalization (i18n) Support in Flask-X-OpenAPI-Schema","text":"<p>This document provides a detailed explanation of the internationalization (i18n) support in Flask-X-OpenAPI-Schema and how to use it effectively.</p>"},{"location":"internationalization/#overview","title":"Overview","text":"<p>Flask-X-OpenAPI-Schema provides robust support for internationalization in API documentation. This allows you to create API documentation in multiple languages, making your API more accessible to users around the world.</p> <pre><code>graph TD\n    A[I18n Support] --&gt; B[I18nStr]\n    A --&gt; C[Language Management]\n\n    B --&gt; E[String Localization]\n    C --&gt; G[Thread-Local Storage]\n\n    E --&gt; H[OpenAPI Metadata]\n    G --&gt; J[Current Language]</code></pre>"},{"location":"internationalization/#core-components","title":"Core Components","text":""},{"location":"internationalization/#1-i18nstr","title":"1. I18nStr","text":"<p>The <code>I18nStr</code> class is the foundation of i18n support in Flask-X-OpenAPI-Schema. It allows you to define strings in multiple languages and automatically returns the appropriate string based on the current language setting.</p> <pre><code>classDiagram\n    class I18nStr {\n        +strings: dict\n        +default_language: str\n        +get(language)\n        +__str__()\n        +create(**kwargs)\n    }</code></pre>"},{"location":"internationalization/#usage","title":"Usage","text":"<pre><code>from flask_x_openapi_schema import I18nStr\n\n# Create an I18nStr with multiple language versions\ngreeting = I18nStr({\n    \"en-US\": \"Hello\",\n    \"zh-Hans\": \"\u4f60\u597d\",\n    \"ja-JP\": \"\u3053\u3093\u306b\u3061\u306f\"\n})\n\n# Get the string in the current language\nprint(str(greeting))  # Outputs the greeting in the current language\n\n# Get the string in a specific language\nprint(greeting.get(\"zh-Hans\"))  # Outputs \"\u4f60\u597d\"\n\n# Alternative creation method with keyword arguments\ngreeting = I18nStr.create(\n    en_US=\"Hello\",\n    zh_Hans=\"\u4f60\u597d\",\n    ja_JP=\"\u3053\u3093\u306b\u3061\u306f\"\n)\n</code></pre>"},{"location":"internationalization/#2-language-management","title":"2. Language Management","text":"<p>Flask-X-OpenAPI-Schema provides functions for managing the current language setting. These functions use Python's <code>contextvars</code> module to store the current language in thread-local storage, allowing different threads to use different languages simultaneously.</p> <pre><code>sequenceDiagram\n    participant A as Application\n    participant L as Language Management\n    participant T as Thread-Local Storage\n    participant S as Schema Generator\n\n    A-&gt;&gt;L: set_current_language(\"zh-Hans\")\n    L-&gt;&gt;T: Store language\n    A-&gt;&gt;S: Generate schema\n    S-&gt;&gt;L: get_current_language()\n    L-&gt;&gt;T: Retrieve language\n    T-&gt;&gt;L: Return \"zh-Hans\"\n    L-&gt;&gt;S: Return \"zh-Hans\"\n    S-&gt;&gt;A: Return schema in Chinese</code></pre>"},{"location":"internationalization/#usage_1","title":"Usage","text":"<pre><code>from flask_x_openapi_schema import set_current_language, get_current_language\n\n# Set the current language\nset_current_language(\"zh-Hans\")\n\n# Get the current language\ncurrent_lang = get_current_language()  # Returns \"zh-Hans\"\n</code></pre>"},{"location":"internationalization/#integration-with-openapi-metadata","title":"Integration with OpenAPI Metadata","text":"<p>The i18n support is fully integrated with the <code>openapi_metadata</code> decorator, allowing you to define internationalized metadata for your API endpoints.</p> <pre><code>graph TD\n    A[openapi_metadata] --&gt; B[I18nString Parameters]\n    B --&gt; C[Current Language]\n    C --&gt; D[Language-Specific Metadata]\n    D --&gt; E[OpenAPI Schema]</code></pre>"},{"location":"internationalization/#usage_2","title":"Usage","text":"<pre><code>from flask_x_openapi_schema.x.flask_restful import openapi_metadata\nfrom flask_x_openapi_schema import I18nStr, set_current_language\n\n# Set the current language for schema generation\nset_current_language(\"zh-Hans\")\n\n@openapi_metadata(\n    summary=I18nStr({\n        \"en-US\": \"Get an item\",\n        \"zh-Hans\": \"\u83b7\u53d6\u4e00\u4e2a\u9879\u76ee\",\n        \"ja-JP\": \"\u30a2\u30a4\u30c6\u30e0\u3092\u53d6\u5f97\u3059\u308b\",\n    }),\n    description=I18nStr({\n        \"en-US\": \"Get an item by ID from the database\",\n        \"zh-Hans\": \"\u901a\u8fc7ID\u4ece\u6570\u636e\u5e93\u83b7\u53d6\u4e00\u4e2a\u9879\u76ee\",\n        \"ja-JP\": \"ID\u304b\u3089\u30c7\u30fc\u30bf\u30d9\u30fc\u30b9\u304b\u3089\u30a2\u30a4\u30c6\u30e0\u3092\u53d6\u5f97\u3059\u308b\",\n    }),\n    tags=[\"Items\"],\n    operation_id=\"getItem\",\n)\ndef get(self, item_id: str):\n    # ...\n</code></pre>"},{"location":"internationalization/#integration-with-schema-generation","title":"Integration with Schema Generation","text":"<p>The i18n support is also integrated with the schema generation process, allowing you to generate OpenAPI schemas in different languages.</p> <pre><code>sequenceDiagram\n    participant A as Application\n    participant L as Language Management\n    participant G as Schema Generator\n    participant S as Schema\n\n    A-&gt;&gt;L: set_current_language(\"ja-JP\")\n    A-&gt;&gt;G: generate_openapi_schema()\n    G-&gt;&gt;L: get_current_language()\n    L-&gt;&gt;G: Return \"ja-JP\"\n    G-&gt;&gt;S: Generate schema in Japanese\n    S-&gt;&gt;A: Return Japanese schema</code></pre>"},{"location":"internationalization/#usage_3","title":"Usage","text":"<pre><code>from flask_x_openapi_schema import set_current_language\nfrom flask_x_openapi_schema.x.flask_restful import OpenAPIIntegrationMixin\nfrom flask import Flask\nfrom flask_restful import Api\n\n# Create a Flask app\napp = Flask(__name__)\n\n# Create an OpenAPI-enabled API\nclass OpenAPIApi(OpenAPIIntegrationMixin, Api):\n    pass\n\n# Initialize the API\napi = OpenAPIApi(app)\n\n# Register resources\n# ...\n\n# Set the language for schema generation\nset_current_language(\"zh-Hans\")\n\n# Generate OpenAPI schema in Chinese\nschema = api.generate_openapi_schema(\n    title=\"Items API\",\n    version=\"1.0.0\",\n    description=\"API for managing items\",\n    output_format=\"yaml\",\n)\n</code></pre>"},{"location":"internationalization/#supported-languages","title":"Supported Languages","text":"<p>Flask-X-OpenAPI-Schema supports a wide range of languages out of the box:</p> <pre><code>SUPPORTED_LANGUAGES = [\n    \"en-US\",    # English (United States)\n    \"zh-Hans\",  # Chinese (Simplified)\n    \"zh-Hant\",  # Chinese (Traditional)\n    \"pt-BR\",    # Portuguese (Brazil)\n    \"es-ES\",    # Spanish (Spain)\n    \"fr-FR\",    # French (France)\n    \"de-DE\",    # German (Germany)\n    \"ja-JP\",    # Japanese (Japan)\n    \"ko-KR\",    # Korean (Korea)\n    \"ru-RU\",    # Russian (Russia)\n    \"it-IT\",    # Italian (Italy)\n    \"uk-UA\",    # Ukrainian (Ukraine)\n    \"vi-VN\",    # Vietnamese (Vietnam)\n    \"ro-RO\",    # Romanian (Romania)\n    \"pl-PL\",    # Polish (Poland)\n    \"hi-IN\",    # Hindi (India)\n    \"tr-TR\",    # Turkish (Turkey)\n    \"fa-IR\",    # Persian (Iran)\n    \"sl-SI\",    # Slovenian (Slovenia)\n    \"th-TH\",    # Thai (Thailand)\n]\n</code></pre> <p>You can add support for additional languages by including them in your <code>I18nString</code> instances.</p>"},{"location":"internationalization/#advanced-usage","title":"Advanced Usage","text":""},{"location":"internationalization/#1-default-language-fallback","title":"1. Default Language Fallback","text":"<p>If a string is not available in the requested language, <code>I18nString</code> will fall back to the default language (usually \"en-US\"):</p> <pre><code>greeting = I18nString({\n    \"en-US\": \"Hello\",\n    \"zh-Hans\": \"\u4f60\u597d\",\n})\n\n# Get the string in a language that's not available\nprint(greeting.get(\"fr-FR\"))  # Falls back to \"Hello\"\n</code></pre>"},{"location":"internationalization/#2-custom-default-language","title":"2. Custom Default Language","text":"<p>You can specify a custom default language when creating an <code>I18nString</code>:</p> <pre><code>greeting = I18nString({\n    \"zh-Hans\": \"\u4f60\u597d\",\n    \"ja-JP\": \"\u3053\u3093\u306b\u3061\u306f\"\n}, default_language=\"zh-Hans\")\n\n# Get the string in a language that's not available\nprint(greeting.get(\"fr-FR\"))  # Falls back to \"\u4f60\u597d\"\n</code></pre>"},{"location":"internationalization/#3-single-string-for-all-languages","title":"3. Single String for All Languages","text":"<p>If you provide a single string instead of a dictionary, it will be used for all languages:</p> <pre><code>greeting = I18nString(\"Hello\")\n\n# Get the string in any language\nprint(greeting.get(\"zh-Hans\"))  # Returns \"Hello\"\nprint(greeting.get(\"ja-JP\"))    # Returns \"Hello\"\n</code></pre>"},{"location":"internationalization/#4-single-string-for-all-languages","title":"4. Single String for All Languages","text":"<p>If you provide a single string instead of a dictionary, it will be used for all languages:</p> <pre><code>greeting = I18nStr(\"Hello\")\n\n# Get the string in any language\nprint(greeting.get(\"zh-Hans\"))  # Returns \"Hello\"\nprint(greeting.get(\"ja-JP\"))    # Returns \"Hello\"\n</code></pre>"},{"location":"internationalization/#5-context-based-language-switching","title":"5. Context-Based Language Switching","text":"<p>You can use Python's context managers to temporarily switch languages:</p> <pre><code>import contextlib\nfrom flask_x_openapi_schema import set_current_language, get_current_language\n\n@contextlib.contextmanager\ndef language_context(language):\n    \"\"\"Temporarily switch to a different language.\"\"\"\n    previous_language = get_current_language()\n    set_current_language(language)\n    try:\n        yield\n    finally:\n        set_current_language(previous_language)\n\n# Use the context manager\nwith language_context(\"zh-Hans\"):\n    # Generate schema in Chinese\n    schema_zh = api.generate_openapi_schema(...)\n\nwith language_context(\"ja-JP\"):\n    # Generate schema in Japanese\n    schema_ja = api.generate_openapi_schema(...)\n</code></pre>"},{"location":"internationalization/#best-practices","title":"Best Practices","text":""},{"location":"internationalization/#1-consistent-language-codes","title":"1. Consistent Language Codes","text":"<p>Use consistent language codes throughout your application. Flask-X-OpenAPI-Schema uses BCP 47 language tags (e.g., \"en-US\", \"zh-Hans\") by default.</p>"},{"location":"internationalization/#2-complete-language-coverage","title":"2. Complete Language Coverage","text":"<p>Ensure that all strings have translations for all supported languages. Missing translations will fall back to the default language, which may not be ideal for users.</p>"},{"location":"internationalization/#3-descriptive-keys","title":"3. Descriptive Keys","text":"<p>Use descriptive keys for your translations to make them easier to maintain:</p> <pre><code># Good\nerror_messages = {\n    \"item_not_found\": I18nString({\n        \"en-US\": \"Item not found\",\n        \"zh-Hans\": \"\u672a\u627e\u5230\u9879\u76ee\",\n        \"ja-JP\": \"\u30a2\u30a4\u30c6\u30e0\u304c\u898b\u3064\u304b\u308a\u307e\u305b\u3093\",\n    }),\n    \"invalid_request\": I18nString({\n        \"en-US\": \"Invalid request\",\n        \"zh-Hans\": \"\u65e0\u6548\u7684\u8bf7\u6c42\",\n        \"ja-JP\": \"\u7121\u52b9\u306a\u30ea\u30af\u30a8\u30b9\u30c8\",\n    }),\n}\n\n# Bad\nerror_messages = {\n    \"e1\": I18nString({\n        \"en-US\": \"Item not found\",\n        \"zh-Hans\": \"\u672a\u627e\u5230\u9879\u76ee\",\n        \"ja-JP\": \"\u30a2\u30a4\u30c6\u30e0\u304c\u898b\u3064\u304b\u308a\u307e\u305b\u3093\",\n    }),\n    \"e2\": I18nString({\n        \"en-US\": \"Invalid request\",\n        \"zh-Hans\": \"\u65e0\u6548\u7684\u8bf7\u6c42\",\n        \"ja-JP\": \"\u7121\u52b9\u306a\u30ea\u30af\u30a8\u30b9\u30c8\",\n    }),\n}\n</code></pre>"},{"location":"internationalization/#4-centralized-string-management","title":"4. Centralized String Management","text":"<p>Consider centralizing your internationalized strings in a separate module to make them easier to manage:</p> <pre><code># strings.py\nfrom flask_x_openapi_schema import I18nString\n\n# Common strings\nCOMMON = {\n    \"success\": I18nString({\n        \"en-US\": \"Success\",\n        \"zh-Hans\": \"\u6210\u529f\",\n        \"ja-JP\": \"\u6210\u529f\",\n    }),\n    \"error\": I18nString({\n        \"en-US\": \"Error\",\n        \"zh-Hans\": \"\u9519\u8bef\",\n        \"ja-JP\": \"\u30a8\u30e9\u30fc\",\n    }),\n}\n\n# Item-related strings\nITEMS = {\n    \"item_not_found\": I18nString({\n        \"en-US\": \"Item not found\",\n        \"zh-Hans\": \"\u672a\u627e\u5230\u9879\u76ee\",\n        \"ja-JP\": \"\u30a2\u30a4\u30c6\u30e0\u304c\u898b\u3064\u304b\u308a\u307e\u305b\u3093\",\n    }),\n    \"item_created\": I18nString({\n        \"en-US\": \"Item created successfully\",\n        \"zh-Hans\": \"\u9879\u76ee\u521b\u5efa\u6210\u529f\",\n        \"ja-JP\": \"\u30a2\u30a4\u30c6\u30e0\u304c\u6b63\u5e38\u306b\u4f5c\u6210\u3055\u308c\u307e\u3057\u305f\",\n    }),\n}\n</code></pre>"},{"location":"internationalization/#5-language-detection","title":"5. Language Detection","text":"<p>Consider implementing language detection based on the user's preferences:</p> <pre><code>from flask import request\nfrom flask_x_openapi_schema import set_current_language\n\n@app.before_request\ndef set_language():\n    \"\"\"Set the current language based on the Accept-Language header.\"\"\"\n    accept_language = request.headers.get(\"Accept-Language\", \"en-US\")\n    # Parse the Accept-Language header to get the preferred language\n    # This is a simplified example; in practice, you would use a proper parser\n    preferred_language = accept_language.split(\",\")[0].split(\";\")[0]\n    set_current_language(preferred_language)\n</code></pre>"},{"location":"internationalization/#working-examples","title":"Working Examples","text":"<p>For complete working examples of internationalization, check out the example applications in the repository:</p> <ul> <li>Common Models with I18n Support: Demonstrates defining multilingual strings for product categories and descriptions</li> <li>Flask MethodView I18n Example: Demonstrates using I18nStr in OpenAPI metadata</li> <li>Flask-RESTful I18n Example: Demonstrates using I18nStr in OpenAPI metadata</li> </ul> <p>These examples show how to:</p> <ul> <li>Define multilingual strings using I18nStr</li> <li>Use multilingual strings in OpenAPI metadata</li> <li>Switch languages at runtime</li> <li>Generate OpenAPI schema in different languages</li> </ul> <p>You can run the examples using the provided justfile commands:</p> <pre><code># Run the Flask MethodView example\njust run-example-flask\n\n# Run the Flask-RESTful example\njust run-example-flask-restful\n</code></pre>"},{"location":"internationalization/#conclusion","title":"Conclusion","text":"<p>Flask-X-OpenAPI-Schema provides comprehensive support for internationalization in API documentation. By using <code>I18nString</code> and <code>I18nBaseModel</code>, you can create multilingual API documentation that is accessible to users around the world. The thread-local storage for the current language allows different parts of your application to use different languages simultaneously, making it easy to support multiple languages in a single application.</p>"},{"location":"parameter_binding/","title":"Parameter Binding in Flask-X-OpenAPI-Schema","text":"<p>This document explains how parameter binding works in Flask-X-OpenAPI-Schema and how to customize it for your needs.</p>"},{"location":"parameter_binding/#overview","title":"Overview","text":"<p>Flask-X-OpenAPI-Schema uses a convention-based approach to bind request parameters to function arguments. By using special prefixes, the library can automatically:</p> <ol> <li>Extract parameters from different parts of the request</li> <li>Convert them to the appropriate types</li> <li>Validate them against Pydantic models</li> <li>Document them in the OpenAPI schema</li> </ol>"},{"location":"parameter_binding/#default-parameter-prefixes","title":"Default Parameter Prefixes","text":"<p>By default, Flask-X-OpenAPI-Schema uses the following prefixes:</p> Prefix Source Example <code>_x_body</code> Request body (JSON) <code>_x_body: UserModel</code> <code>_x_query</code> Query parameters <code>_x_query: FilterParams</code> <code>_x_path_</code> Path parameters Path parameter binding is automatic <code>_x_file</code> File uploads <code>_x_file: ImageUploadModel</code>"},{"location":"parameter_binding/#request-body-binding","title":"Request Body Binding","text":"<p>Use the <code>_x_body</code> prefix to bind the request body to a Pydantic model:</p> <pre><code>from pydantic import BaseModel, Field\n\nclass UserCreateRequest(BaseModel):\n    username: str = Field(..., description=\"User's username\")\n    email: str = Field(..., description=\"User's email address\")\n    password: str = Field(..., description=\"User's password\")\n    full_name: str = Field(None, description=\"User's full name\")\n\n@openapi_metadata(\n    summary=\"Create a new user\",\n    # ...\n)\ndef post(self, _x_body: UserCreateRequest):\n    # _x_body is automatically populated from the request JSON\n    user = {\n        \"id\": \"123\",\n        \"username\": _x_body.username,\n        \"email\": _x_body.email,\n        \"full_name\": _x_body.full_name,\n    }\n    return user, 201\n</code></pre> <p>This will generate the following OpenAPI schema:</p> <pre><code>paths:\n  /users:\n    post:\n      summary: Create a new user\n      requestBody:\n        content:\n          application/json:\n            schema:\n              $ref: '#/components/schemas/UserCreateRequest'\n      responses:\n        '201':\n          description: User created successfully\n          content:\n            application/json:\n              schema:\n                $ref: '#/components/schemas/UserResponse'\n</code></pre>"},{"location":"parameter_binding/#query-parameter-binding","title":"Query Parameter Binding","text":"<p>Use the <code>_x_query</code> prefix to bind query parameters to a Pydantic model:</p> <pre><code>from pydantic import BaseModel, Field\n\nclass UserFilterParams(BaseModel):\n    username: str = Field(None, description=\"Filter by username\")\n    email: str = Field(None, description=\"Filter by email\")\n    role: str = Field(None, description=\"Filter by role\")\n    active: bool = Field(None, description=\"Filter by active status\")\n    limit: int = Field(10, description=\"Maximum number of results to return\")\n    offset: int = Field(0, description=\"Number of results to skip\")\n\n@openapi_metadata(\n    summary=\"Get all users\",\n    # ...\n)\ndef get(self, _x_query: UserFilterParams = None):\n    # _x_query is automatically populated from the query parameters\n    users = [...]\n\n    if _x_query:\n        if _x_query.username:\n            users = [user for user in users if _x_query.username in user[\"username\"]]\n\n        if _x_query.email:\n            users = [user for user in users if _x_query.email in user[\"email\"]]\n\n        if _x_query.role:\n            users = [user for user in users if user[\"role\"] == _x_query.role]\n\n        if _x_query.active is not None:\n            users = [user for user in users if user[\"active\"] == _x_query.active]\n\n        # Apply pagination\n        users = users[_x_query.offset:_x_query.offset + _x_query.limit]\n\n    return users, 200\n</code></pre> <p>This will generate the following OpenAPI schema:</p> <pre><code>paths:\n  /users:\n    get:\n      summary: Get all users\n      parameters:\n        - name: username\n          in: query\n          description: Filter by username\n          schema:\n            type: string\n        - name: email\n          in: query\n          description: Filter by email\n          schema:\n            type: string\n        - name: role\n          in: query\n          description: Filter by role\n          schema:\n            type: string\n        - name: active\n          in: query\n          description: Filter by active status\n          schema:\n            type: boolean\n        - name: limit\n          in: query\n          description: Maximum number of results to return\n          schema:\n            type: integer\n            default: 10\n        - name: offset\n          in: query\n          description: Number of results to skip\n          schema:\n            type: integer\n            default: 0\n      responses:\n        '200':\n          description: List of users retrieved successfully\n          content:\n            application/json:\n              schema:\n                type: array\n                items:\n                  $ref: '#/components/schemas/UserResponse'\n</code></pre>"},{"location":"parameter_binding/#path-parameter-binding","title":"Path Parameter Binding","text":"<p>Path parameters are automatically bound to function arguments with matching names:</p> <pre><code>@openapi_metadata(\n    summary=\"Get a user by ID\",\n    # ...\n)\ndef get(self, user_id: str):\n    # user_id is automatically populated from the path parameter\n    if user_id not in [\"123\", \"456\"]:\n        return {\"error\": \"User not found\"}, 404\n\n    user = {\n        \"id\": user_id,\n        \"username\": f\"user{user_id}\",\n        \"email\": f\"user{user_id}@example.com\",\n        \"full_name\": f\"User {user_id}\",\n    }\n    return user, 200\n</code></pre> <p>This will generate the following OpenAPI schema:</p> <pre><code>paths:\n  /users/{user_id}:\n    get:\n      summary: Get a user by ID\n      parameters:\n        - name: user_id\n          in: path\n          required: true\n          description: User ID\n          schema:\n            type: string\n      responses:\n        '200':\n          description: User retrieved successfully\n          content:\n            application/json:\n              schema:\n                $ref: '#/components/schemas/UserResponse'\n        '404':\n          description: User not found\n</code></pre>"},{"location":"parameter_binding/#file-upload-binding","title":"File Upload Binding","text":"<p>Use the <code>_x_file</code> prefix to bind file uploads to a file upload model:</p> <pre><code>from flask_x_openapi_schema import ImageUploadModel\n\n@openapi_metadata(\n    summary=\"Upload a user profile picture\",\n    # ...\n)\ndef post(self, user_id: str, _x_file: ImageUploadModel):\n    # _x_file.file is automatically populated from the uploaded file\n    file = _x_file.file\n\n    # Save the file\n    file.save(f\"uploads/{user_id}_profile.jpg\")\n\n    return {\"message\": \"Profile picture uploaded successfully\"}, 201\n</code></pre> <p>This will generate the following OpenAPI schema:</p> <pre><code>paths:\n  /users/{user_id}/profile-picture:\n    post:\n      summary: Upload a user profile picture\n      parameters:\n        - name: user_id\n          in: path\n          required: true\n          description: User ID\n          schema:\n            type: string\n      requestBody:\n        content:\n          multipart/form-data:\n            schema:\n              type: object\n              properties:\n                file:\n                  type: string\n                  format: binary\n                  description: Profile picture to upload\n      responses:\n        '201':\n          description: Profile picture uploaded successfully\n</code></pre>"},{"location":"parameter_binding/#custom-parameter-names","title":"Custom Parameter Names","text":"<p>You can use custom parameter names with the appropriate prefixes:</p> <pre><code>@openapi_metadata(\n    summary=\"Upload multiple files\",\n    # ...\n)\ndef post(\n    self,\n    user_id: str,\n    _x_file_profile: ImageUploadModel,\n    _x_file_cover: ImageUploadModel,\n    _x_body: UserUpdateRequest,\n):\n    # Access each parameter\n    profile_pic = _x_file_profile.file\n    cover_pic = _x_file_cover.file\n    update_data = _x_body\n\n    # Process files and data\n    # ...\n\n    return {\"message\": \"Files uploaded and user updated successfully\"}, 200\n</code></pre>"},{"location":"parameter_binding/#customizing-parameter-prefixes","title":"Customizing Parameter Prefixes","text":"<p>You can customize the parameter prefixes using the <code>ConventionalPrefixConfig</code> class:</p> <pre><code>from flask_x_openapi_schema import ConventionalPrefixConfig, configure_prefixes\n\n# Create a custom configuration\ncustom_config = ConventionalPrefixConfig(\n    request_body_prefix=\"req_body\",\n    request_query_prefix=\"req_query\",\n    request_path_prefix=\"req_path\",\n    request_file_prefix=\"req_file\"\n)\n\n# Configure globally\nconfigure_prefixes(custom_config)\n</code></pre>"},{"location":"parameter_binding/#global-configuration","title":"Global Configuration","text":"<p>To configure the prefixes globally for all endpoints:</p> <pre><code>from flask_x_openapi_schema import ConventionalPrefixConfig, configure_prefixes\n\n# Create a custom configuration\ncustom_config = ConventionalPrefixConfig(\n    request_body_prefix=\"req_body\",\n    request_query_prefix=\"req_query\",\n    request_path_prefix=\"req_path\",\n    request_file_prefix=\"req_file\"\n)\n\n# Configure globally\nconfigure_prefixes(custom_config)\n\n# Now you can use the custom prefixes in your endpoints\n@openapi_metadata(\n    summary=\"Create a new user\",\n    # ...\n)\ndef post(self, req_body: UserCreateRequest):\n    # req_body is automatically populated from the request JSON\n    user = {\n        \"id\": \"123\",\n        \"username\": req_body.username,\n        \"email\": req_body.email,\n        \"full_name\": req_body.full_name,\n    }\n    return user, 201\n</code></pre>"},{"location":"parameter_binding/#per-function-configuration","title":"Per-Function Configuration","text":"<p>To configure the prefixes for a specific endpoint:</p> <pre><code>from flask_x_openapi_schema import ConventionalPrefixConfig\n\n# Create a custom configuration\ncustom_config = ConventionalPrefixConfig(\n    request_body_prefix=\"req_body\",\n    request_query_prefix=\"req_query\",\n    request_path_prefix=\"req_path\",\n    request_file_prefix=\"req_file\"\n)\n\n@openapi_metadata(\n    summary=\"Create a new user\",\n    prefix_config=custom_config,\n    # ...\n)\ndef post(self, req_body: UserCreateRequest):\n    # req_body is automatically populated from the request JSON\n    user = {\n        \"id\": \"123\",\n        \"username\": req_body.username,\n        \"email\": req_body.email,\n        \"full_name\": req_body.full_name,\n    }\n    return user, 201\n</code></pre>"},{"location":"parameter_binding/#advanced-parameter-binding","title":"Advanced Parameter Binding","text":""},{"location":"parameter_binding/#combining-parameter-types","title":"Combining Parameter Types","text":"<p>You can combine different parameter types in a single endpoint:</p> <pre><code>@openapi_metadata(\n    summary=\"Search users\",\n    # ...\n)\ndef get(\n    self,\n    _x_query: UserSearchParams = None,\n    _x_body: UserAdvancedSearchRequest = None,\n):\n    # _x_query is populated from query parameters\n    # _x_body is populated from the request body\n\n    # Combine search criteria\n    search_criteria = {}\n\n    if _x_query:\n        search_criteria.update(_x_query.model_dump(exclude_none=True))\n\n    if _x_body:\n        search_criteria.update(_x_body.model_dump(exclude_none=True))\n\n    # Perform search\n    # ...\n\n    return results, 200\n</code></pre>"},{"location":"parameter_binding/#optional-parameters","title":"Optional Parameters","text":"<p>Parameters can be made optional by providing a default value:</p> <pre><code>@openapi_metadata(\n    summary=\"Get all users\",\n    # ...\n)\ndef get(self, _x_query: UserFilterParams = None):\n    # _x_query is None if no query parameters are provided\n    if _x_query is None:\n        # Return all users\n        return all_users, 200\n\n    # Filter users based on query parameters\n    # ...\n\n    return filtered_users, 200\n</code></pre>"},{"location":"parameter_binding/#nested-models","title":"Nested Models","text":"<p>You can use nested Pydantic models for complex parameter structures:</p> <pre><code>from pydantic import BaseModel, Field\nfrom typing import List, Dict, Optional\n\nclass Address(BaseModel):\n    street: str = Field(..., description=\"Street address\")\n    city: str = Field(..., description=\"City\")\n    state: str = Field(..., description=\"State or province\")\n    postal_code: str = Field(..., description=\"Postal code\")\n    country: str = Field(..., description=\"Country\")\n\nclass UserCreateRequest(BaseModel):\n    username: str = Field(..., description=\"User's username\")\n    email: str = Field(..., description=\"User's email address\")\n    password: str = Field(..., description=\"User's password\")\n    full_name: Optional[str] = Field(None, description=\"User's full name\")\n    addresses: List[Address] = Field([], description=\"User's addresses\")\n    metadata: Dict[str, str] = Field({}, description=\"Additional metadata\")\n\n@openapi_metadata(\n    summary=\"Create a new user\",\n    # ...\n)\ndef post(self, _x_body: UserCreateRequest):\n    # _x_body is automatically populated from the request JSON\n    # You can access nested fields like _x_body.addresses[0].city\n\n    # Process the request\n    # ...\n\n    return user, 201\n</code></pre>"},{"location":"parameter_binding/#working-examples","title":"Working Examples","text":"<p>For complete working examples of parameter binding, check out the example applications in the repository:</p> <ul> <li>Flask MethodView Parameter Binding Example: Demonstrates binding path, query, and body parameters</li> <li>Flask-RESTful Parameter Binding Example: Demonstrates binding path, query, and body parameters</li> <li>Custom Prefix Configuration Example: Demonstrates customizing parameter prefixes</li> </ul> <p>These examples show how to:</p> <ul> <li>Bind request body parameters using <code>_x_body</code></li> <li>Bind query parameters using <code>_x_query</code></li> <li>Bind path parameters automatically</li> <li>Customize parameter prefixes</li> <li>Validate parameters using Pydantic models</li> </ul> <p>You can run the examples using the provided justfile commands:</p> <pre><code># Run the Flask MethodView example\njust run-example-flask\n\n# Run the Flask-RESTful example\njust run-example-flask-restful\n</code></pre>"},{"location":"parameter_binding/#conclusion","title":"Conclusion","text":"<p>Flask-X-OpenAPI-Schema's parameter binding system provides a powerful and flexible way to handle request parameters in your API endpoints. By using special prefixes and Pydantic models, you can automatically extract, convert, validate, and document parameters from different parts of the request. You can also customize the parameter prefixes to match your preferred naming convention.</p>"},{"location":"response_handling/","title":"Response Handling in Flask-X-OpenAPI-Schema","text":"<p>This document explains how to handle API responses in Flask-X-OpenAPI-Schema, including defining response models, documenting responses in OpenAPI schemas, and returning responses from your API endpoints.</p>"},{"location":"response_handling/#overview","title":"Overview","text":"<p>Flask-X-OpenAPI-Schema provides a comprehensive system for handling API responses:</p> <ol> <li>Response Models: Define response structures using Pydantic models</li> <li>Response Documentation: Document responses in OpenAPI schemas using the <code>OpenAPIMetaResponse</code> class</li> <li>Response Generation: Convert Pydantic models to Flask responses using the <code>BaseRespModel</code> class</li> </ol>"},{"location":"response_handling/#response-models","title":"Response Models","text":""},{"location":"response_handling/#basic-response-models","title":"Basic Response Models","text":"<p>You can define response models using Pydantic's <code>BaseModel</code>:</p> <pre><code>from pydantic import BaseModel, Field\nfrom typing import List, Optional\n\nclass UserResponse(BaseModel):\n    id: str = Field(..., description=\"User ID\")\n    username: str = Field(..., description=\"User's username\")\n    email: str = Field(..., description=\"User's email address\")\n    full_name: Optional[str] = Field(None, description=\"User's full name\")\n    created_at: str = Field(..., description=\"Creation timestamp\")\n</code></pre>"},{"location":"response_handling/#using-baserespmodel","title":"Using BaseRespModel","text":"<p>For more advanced response handling, you can use the <code>BaseRespModel</code> class, which provides additional functionality for converting models to Flask responses:</p> <pre><code>from flask_x_openapi_schema import BaseRespModel\nfrom pydantic import Field\nfrom typing import Optional\n\nclass UserResponse(BaseRespModel):\n    id: str = Field(..., description=\"User ID\")\n    username: str = Field(..., description=\"User's username\")\n    email: str = Field(..., description=\"User's email address\")\n    full_name: Optional[str] = Field(None, description=\"User's full name\")\n    created_at: str = Field(..., description=\"Creation timestamp\")\n</code></pre> <p>The <code>BaseRespModel</code> class provides a <code>to_response</code> method that converts the model to a Flask response:</p> <pre><code>@openapi_metadata(\n    summary=\"Get a user by ID\",\n    # ...\n)\ndef get(self, user_id: str):\n    # Get user from database\n    user = get_user_from_db(user_id)\n\n    if not user:\n        return {\"error\": \"User not found\"}, 404\n\n    # Create response model\n    response = UserResponse(\n        id=user.id,\n        username=user.username,\n        email=user.email,\n        full_name=user.full_name,\n        created_at=user.created_at.isoformat(),\n    )\n\n    # Convert to Flask response\n    return response.to_response(200)\n</code></pre>"},{"location":"response_handling/#documenting-responses","title":"Documenting Responses","text":""},{"location":"response_handling/#using-openapimetaresponse","title":"Using OpenAPIMetaResponse","text":"<p>The <code>OpenAPIMetaResponse</code> class provides a structured way to document responses in OpenAPI schemas:</p> <pre><code>from flask_x_openapi_schema import OpenAPIMetaResponse, OpenAPIMetaResponseItem\n\n@openapi_metadata(\n    summary=\"Create a new user\",\n    description=\"Create a new user with the provided information\",\n    tags=[\"users\"],\n    operation_id=\"createUser\",\n    responses=OpenAPIMetaResponse(\n        responses={\n            \"201\": OpenAPIMetaResponseItem(\n                model=UserResponse,\n                description=\"User created successfully\",\n            ),\n            \"400\": OpenAPIMetaResponseItem(\n                model=ErrorResponse,\n                description=\"Invalid request data\",\n            ),\n            \"409\": OpenAPIMetaResponseItem(\n                model=ErrorResponse,\n                description=\"Username or email already exists\",\n            ),\n            \"500\": OpenAPIMetaResponseItem(\n                model=ErrorResponse,\n                description=\"Internal server error\",\n            ),\n        }\n    ),\n)\ndef post(self, _x_body: UserCreateRequest):\n    # Implementation...\n</code></pre> <p>This will generate the following OpenAPI schema:</p> <pre><code>paths:\n  /users:\n    post:\n      summary: Create a new user\n      description: Create a new user with the provided information\n      tags:\n        - users\n      operationId: createUser\n      requestBody:\n        content:\n          application/json:\n            schema:\n              $ref: '#/components/schemas/UserCreateRequest'\n      responses:\n        '201':\n          description: User created successfully\n          content:\n            application/json:\n              schema:\n                $ref: '#/components/schemas/UserResponse'\n        '400':\n          description: Invalid request data\n          content:\n            application/json:\n              schema:\n                $ref: '#/components/schemas/ErrorResponse'\n        '409':\n          description: Username or email already exists\n          content:\n            application/json:\n              schema:\n                $ref: '#/components/schemas/ErrorResponse'\n        '500':\n          description: Internal server error\n          content:\n            application/json:\n              schema:\n                $ref: '#/components/schemas/ErrorResponse'\n</code></pre>"},{"location":"response_handling/#response-without-model","title":"Response Without Model","text":"<p>You can also document responses without a model:</p> <pre><code>@openapi_metadata(\n    summary=\"Delete a user\",\n    description=\"Delete a user by ID\",\n    tags=[\"users\"],\n    operation_id=\"deleteUser\",\n    responses=OpenAPIMetaResponse(\n        responses={\n            \"204\": OpenAPIMetaResponseItem(\n                description=\"User deleted successfully\",\n                msg=\"User deleted successfully\",\n            ),\n            \"404\": OpenAPIMetaResponseItem(\n                model=ErrorResponse,\n                description=\"User not found\",\n            ),\n            \"500\": OpenAPIMetaResponseItem(\n                model=ErrorResponse,\n                description=\"Internal server error\",\n            ),\n        }\n    ),\n)\ndef delete(self, user_id: str):\n    # Implementation...\n</code></pre>"},{"location":"response_handling/#returning-responses","title":"Returning Responses","text":""},{"location":"response_handling/#basic-responses","title":"Basic Responses","text":"<p>You can return basic responses using Flask's standard response format:</p> <pre><code>@openapi_metadata(\n    summary=\"Get all users\",\n    # ...\n)\ndef get(self):\n    # Get users from database\n    users = get_users_from_db()\n\n    # Convert to response format\n    response = [\n        {\n            \"id\": user.id,\n            \"username\": user.username,\n            \"email\": user.email,\n            \"full_name\": user.full_name,\n            \"created_at\": user.created_at.isoformat(),\n        }\n        for user in users\n    ]\n\n    return response, 200\n</code></pre>"},{"location":"response_handling/#using-baserespmodel_1","title":"Using BaseRespModel","text":"<p>For more advanced response handling, you can use the <code>BaseRespModel</code> class:</p> <pre><code>@openapi_metadata(\n    summary=\"Get a user by ID\",\n    # ...\n)\ndef get(self, user_id: str):\n    # Get user from database\n    user = get_user_from_db(user_id)\n\n    if not user:\n        error = ErrorResponse(\n            error_code=\"USER_NOT_FOUND\",\n            message=f\"User with ID {user_id} not found\",\n        )\n        return error.to_response(404)\n\n    # Create response model\n    response = UserResponse(\n        id=user.id,\n        username=user.username,\n        email=user.email,\n        full_name=user.full_name,\n        created_at=user.created_at.isoformat(),\n    )\n\n    # Convert to Flask response\n    return response.to_response(200)\n</code></pre>"},{"location":"response_handling/#list-responses","title":"List Responses","text":"<p>For list responses, you can use a list of response models:</p> <pre><code>@openapi_metadata(\n    summary=\"Get all users\",\n    # ...\n)\ndef get(self):\n    # Get users from database\n    users = get_users_from_db()\n\n    # Convert to response models\n    response = [\n        UserResponse(\n            id=user.id,\n            username=user.username,\n            email=user.email,\n            full_name=user.full_name,\n            created_at=user.created_at.isoformat(),\n        )\n        for user in users\n    ]\n\n    # Convert to Flask response\n    return [r.model_dump() for r in response], 200\n</code></pre>"},{"location":"response_handling/#advanced-response-handling","title":"Advanced Response Handling","text":""},{"location":"response_handling/#pagination","title":"Pagination","text":"<p>For paginated responses, you can create a pagination wrapper model:</p> <pre><code>from flask_x_openapi_schema import BaseRespModel\nfrom pydantic import Field\nfrom typing import List, Generic, TypeVar\n\nT = TypeVar('T')\n\nclass PaginatedResponse(BaseRespModel, Generic[T]):\n    items: List[T] = Field(..., description=\"List of items\")\n    total: int = Field(..., description=\"Total number of items\")\n    page: int = Field(..., description=\"Current page number\")\n    per_page: int = Field(..., description=\"Number of items per page\")\n    pages: int = Field(..., description=\"Total number of pages\")\n\n@openapi_metadata(\n    summary=\"Get all users\",\n    # ...\n)\ndef get(self, _x_query: PaginationParams = None):\n    # Get pagination parameters\n    page = _x_query.page if _x_query else 1\n    per_page = _x_query.per_page if _x_query else 10\n\n    # Get users from database with pagination\n    users, total = get_users_from_db_paginated(page, per_page)\n\n    # Calculate total pages\n    pages = (total + per_page - 1) // per_page\n\n    # Convert to response models\n    user_responses = [\n        UserResponse(\n            id=user.id,\n            username=user.username,\n            email=user.email,\n            full_name=user.full_name,\n            created_at=user.created_at.isoformat(),\n        )\n        for user in users\n    ]\n\n    # Create paginated response\n    response = PaginatedResponse(\n        items=user_responses,\n        total=total,\n        page=page,\n        per_page=per_page,\n        pages=pages,\n    )\n\n    # Convert to Flask response\n    return response.to_response(200)\n</code></pre>"},{"location":"response_handling/#error-responses","title":"Error Responses","text":"<p>For error responses, you can create an error response model:</p> <pre><code>from flask_x_openapi_schema import BaseRespModel\nfrom pydantic import Field\nfrom typing import Optional, Dict, Any\n\nclass ErrorResponse(BaseRespModel):\n    error_code: str = Field(..., description=\"Error code\")\n    message: str = Field(..., description=\"Error message\")\n    details: Optional[Dict[str, Any]] = Field(None, description=\"Additional error details\")\n\n@openapi_metadata(\n    summary=\"Create a new user\",\n    # ...\n)\ndef post(self, _x_body: UserCreateRequest):\n    # Check if username already exists\n    if username_exists(_x_body.username):\n        error = ErrorResponse(\n            error_code=\"USERNAME_EXISTS\",\n            message=\"Username already exists\",\n            details={\"username\": _x_body.username},\n        )\n        return error.to_response(409)\n\n    # Check if email already exists\n    if email_exists(_x_body.email):\n        error = ErrorResponse(\n            error_code=\"EMAIL_EXISTS\",\n            message=\"Email already exists\",\n            details={\"email\": _x_body.email},\n        )\n        return error.to_response(409)\n\n    # Create user\n    # ...\n</code></pre>"},{"location":"response_handling/#custom-response-headers","title":"Custom Response Headers","text":"<p>You can add custom headers to your responses:</p> <pre><code>@openapi_metadata(\n    summary=\"Get a user by ID\",\n    # ...\n)\ndef get(self, user_id: str):\n    # Get user from database\n    user = get_user_from_db(user_id)\n\n    if not user:\n        error = ErrorResponse(\n            error_code=\"USER_NOT_FOUND\",\n            message=f\"User with ID {user_id} not found\",\n        )\n        return error.to_response(404)\n\n    # Create response model\n    response = UserResponse(\n        id=user.id,\n        username=user.username,\n        email=user.email,\n        full_name=user.full_name,\n        created_at=user.created_at.isoformat(),\n    )\n\n    # Convert to Flask response with custom headers\n    return response.to_response(\n        200,\n        headers={\n            \"X-RateLimit-Limit\": \"100\",\n            \"X-RateLimit-Remaining\": \"99\",\n            \"X-RateLimit-Reset\": \"1619789983\",\n        },\n    )\n</code></pre>"},{"location":"response_handling/#working-examples","title":"Working Examples","text":"<p>For complete working examples of response handling, check out the example applications in the repository:</p> <ul> <li>Flask MethodView Response Example: Demonstrates structured responses with OpenAPIMetaResponse</li> <li>Flask-RESTful Response Example: Demonstrates structured responses with OpenAPIMetaResponse</li> <li>Error Response Example: Demonstrates error response handling</li> </ul> <p>These examples show how to:</p> <ul> <li>Define response models using Pydantic</li> <li>Document responses using OpenAPIMetaResponse</li> <li>Return responses with appropriate status codes</li> <li>Handle error responses</li> <li>Use BaseRespModel for automatic response conversion</li> </ul> <p>You can run the examples using the provided justfile commands:</p> <pre><code># Run the Flask MethodView response example\njust run-response-example-flask\n\n# Run the Flask-RESTful response example\njust run-response-example-flask-restful\n</code></pre>"},{"location":"response_handling/#conclusion","title":"Conclusion","text":"<p>Flask-X-OpenAPI-Schema provides a comprehensive system for handling API responses. By using Pydantic models, the <code>OpenAPIMetaResponse</code> class, and the <code>BaseRespModel</code> class, you can define, document, and return responses from your API endpoints in a structured and consistent way.</p>"},{"location":"schema_generation/","title":"OpenAPI Schema Generation in Flask-X-OpenAPI-Schema","text":"<p>This document explains how to generate OpenAPI schemas using Flask-X-OpenAPI-Schema, including customizing the schema, adding additional components, and serving the schema to clients.</p>"},{"location":"schema_generation/#overview","title":"Overview","text":"<p>Flask-X-OpenAPI-Schema provides tools for generating OpenAPI 3.0.x schemas from your Flask and Flask-RESTful applications. The schema generation process is automatic and based on the metadata provided in your API endpoints.</p>"},{"location":"schema_generation/#basic-schema-generation","title":"Basic Schema Generation","text":""},{"location":"schema_generation/#with-flaskmethodview","title":"With Flask.MethodView","text":"<pre><code>from flask import Flask, Blueprint\nfrom flask_x_openapi_schema.x.flask.views import MethodViewOpenAPISchemaGenerator\nimport yaml\n\n# Create a Flask app\napp = Flask(__name__)\nblueprint = Blueprint(\"api\", __name__, url_prefix=\"/api\")\n\n# Register your views\n# ...\n\n# Register the blueprint\napp.register_blueprint(blueprint)\n\n# Generate OpenAPI schema\n@app.route(\"/openapi.yaml\")\ndef get_openapi_spec():\n    generator = MethodViewOpenAPISchemaGenerator(\n        title=\"My API\",\n        version=\"1.0.0\",\n        description=\"API for managing resources\",\n    )\n\n    # Process MethodView resources\n    generator.process_methodview_resources(blueprint)\n\n    # Generate the schema\n    schema = generator.generate_schema()\n\n    # Convert to YAML\n    yaml_content = yaml.dump(\n        schema,\n        sort_keys=False,\n        default_flow_style=False,\n        allow_unicode=True,\n    )\n\n    return yaml_content, 200, {\"Content-Type\": \"text/yaml\"}\n</code></pre>"},{"location":"schema_generation/#with-flask-restful","title":"With Flask-RESTful","text":"<pre><code>from flask import Flask\nfrom flask_restful import Api\nfrom flask_x_openapi_schema.x.flask_restful import OpenAPIIntegrationMixin\nimport yaml\n\n# Create a Flask app\napp = Flask(__name__)\n\n# Create an OpenAPI-enabled API\nclass OpenAPIApi(OpenAPIIntegrationMixin, Api):\n    pass\n\napi = OpenAPIApi(app)\n\n# Register your resources\n# ...\n\n# Generate OpenAPI schema\n@app.route(\"/openapi.yaml\")\ndef get_openapi_spec():\n    schema = api.generate_openapi_schema(\n        title=\"My API\",\n        version=\"1.0.0\",\n        description=\"API for managing resources\",\n        output_format=\"json\",\n    )\n\n    # Convert to YAML\n    yaml_content = yaml.dump(\n        schema,\n        sort_keys=False,\n        default_flow_style=False,\n        allow_unicode=True,\n    )\n\n    return yaml_content, 200, {\"Content-Type\": \"text/yaml\"}\n</code></pre>"},{"location":"schema_generation/#customizing-the-schema","title":"Customizing the Schema","text":""},{"location":"schema_generation/#schema-information","title":"Schema Information","text":"<p>You can customize the schema information by providing parameters to the schema generator:</p> <pre><code>generator = MethodViewOpenAPISchemaGenerator(\n    title=\"My API\",\n    version=\"1.0.0\",\n    description=\"API for managing resources\",\n    terms_of_service=\"https://example.com/terms/\",\n    contact={\n        \"name\": \"API Support\",\n        \"url\": \"https://example.com/support/\",\n        \"email\": \"support@example.com\",\n    },\n    license={\n        \"name\": \"MIT\",\n        \"url\": \"https://opensource.org/licenses/MIT\",\n    },\n)\n</code></pre> <p>Or with Flask-RESTful:</p> <pre><code>schema = api.generate_openapi_schema(\n    title=\"My API\",\n    version=\"1.0.0\",\n    description=\"API for managing resources\",\n    terms_of_service=\"https://example.com/terms/\",\n    contact={\n        \"name\": \"API Support\",\n        \"url\": \"https://example.com/support/\",\n        \"email\": \"support@example.com\",\n    },\n    license={\n        \"name\": \"MIT\",\n        \"url\": \"https://opensource.org/licenses/MIT\",\n    },\n    output_format=\"json\",\n)\n</code></pre>"},{"location":"schema_generation/#servers","title":"Servers","text":"<p>You can specify the servers that the API is available on:</p> <pre><code>generator = MethodViewOpenAPISchemaGenerator(\n    # ...\n    servers=[\n        {\n            \"url\": \"https://api.example.com/v1\",\n            \"description\": \"Production server\",\n        },\n        {\n            \"url\": \"https://staging-api.example.com/v1\",\n            \"description\": \"Staging server\",\n        },\n        {\n            \"url\": \"https://dev-api.example.com/v1\",\n            \"description\": \"Development server\",\n        },\n    ],\n)\n</code></pre> <p>Or with Flask-RESTful:</p> <pre><code>schema = api.generate_openapi_schema(\n    # ...\n    servers=[\n        {\n            \"url\": \"https://api.example.com/v1\",\n            \"description\": \"Production server\",\n        },\n        {\n            \"url\": \"https://staging-api.example.com/v1\",\n            \"description\": \"Staging server\",\n        },\n        {\n            \"url\": \"https://dev-api.example.com/v1\",\n            \"description\": \"Development server\",\n        },\n    ],\n    output_format=\"json\",\n)\n</code></pre>"},{"location":"schema_generation/#security-schemes","title":"Security Schemes","text":"<p>You can define security schemes for your API:</p> <pre><code>generator = MethodViewOpenAPISchemaGenerator(\n    # ...\n    security_schemes={\n        \"bearerAuth\": {\n            \"type\": \"http\",\n            \"scheme\": \"bearer\",\n            \"bearerFormat\": \"JWT\",\n        },\n        \"apiKeyAuth\": {\n            \"type\": \"apiKey\",\n            \"in\": \"header\",\n            \"name\": \"X-API-Key\",\n        },\n    },\n)\n</code></pre> <p>Or with Flask-RESTful:</p> <pre><code>schema = api.generate_openapi_schema(\n    # ...\n    security_schemes={\n        \"bearerAuth\": {\n            \"type\": \"http\",\n            \"scheme\": \"bearer\",\n            \"bearerFormat\": \"JWT\",\n        },\n        \"apiKeyAuth\": {\n            \"type\": \"apiKey\",\n            \"in\": \"header\",\n            \"name\": \"X-API-Key\",\n        },\n    },\n    output_format=\"json\",\n)\n</code></pre>"},{"location":"schema_generation/#registering-additional-components","title":"Registering Additional Components","text":""},{"location":"schema_generation/#manually-registering-models","title":"Manually Registering Models","text":"<p>You can manually register additional models that might not be automatically detected:</p> <pre><code>from flask_x_openapi_schema.x.flask.views import MethodViewOpenAPISchemaGenerator\nfrom flask_x_openapi_schema.core.utils import pydantic_to_openapi_schema\n\n# Create the schema generator\ngenerator = MethodViewOpenAPISchemaGenerator(\n    title=\"My API\",\n    version=\"1.0.0\",\n    description=\"API for managing resources\",\n)\n\n# Manually register models\ngenerator._register_model(UserResponse)\ngenerator._register_model(ErrorResponse)\ngenerator._register_model(ProductCategory)\ngenerator._register_model(ProductStatus)\n\n# Process MethodView resources\ngenerator.process_methodview_resources(blueprint)\n\n# Generate the schema\nschema = generator.generate_schema()\n</code></pre> <p>Or with Flask-RESTful:</p> <pre><code># Generate the schema\nschema = api.generate_openapi_schema(\n    title=\"My API\",\n    version=\"1.0.0\",\n    description=\"API for managing resources\",\n    output_format=\"json\",\n)\n\n# Manually register models\nif \"components\" not in schema:\n    schema[\"components\"] = {}\nif \"schemas\" not in schema[\"components\"]:\n    schema[\"components\"][\"schemas\"] = {}\n\nfor model in [UserResponse, ErrorResponse, ProductCategory, ProductStatus]:\n    model_schema = pydantic_to_openapi_schema(model)\n    schema[\"components\"][\"schemas\"][model.__name__] = model_schema\n</code></pre>"},{"location":"schema_generation/#adding-tags","title":"Adding Tags","text":"<p>You can add tags to your OpenAPI schema to group operations:</p> <pre><code>generator = MethodViewOpenAPISchemaGenerator(\n    # ...\n    tags=[\n        {\n            \"name\": \"users\",\n            \"description\": \"Operations related to users\",\n        },\n        {\n            \"name\": \"products\",\n            \"description\": \"Operations related to products\",\n        },\n        {\n            \"name\": \"orders\",\n            \"description\": \"Operations related to orders\",\n        },\n    ],\n)\n</code></pre> <p>Or with Flask-RESTful:</p> <pre><code>schema = api.generate_openapi_schema(\n    # ...\n    tags=[\n        {\n            \"name\": \"users\",\n            \"description\": \"Operations related to users\",\n        },\n        {\n            \"name\": \"products\",\n            \"description\": \"Operations related to products\",\n        },\n        {\n            \"name\": \"orders\",\n            \"description\": \"Operations related to orders\",\n        },\n    ],\n    output_format=\"json\",\n)\n</code></pre>"},{"location":"schema_generation/#serving-the-schema","title":"Serving the Schema","text":""},{"location":"schema_generation/#serving-as-yaml","title":"Serving as YAML","text":"<pre><code>@app.route(\"/openapi.yaml\")\ndef get_openapi_yaml():\n    # Generate the schema\n    # ...\n\n    # Convert to YAML\n    yaml_content = yaml.dump(\n        schema,\n        sort_keys=False,\n        default_flow_style=False,\n        allow_unicode=True,\n    )\n\n    return yaml_content, 200, {\"Content-Type\": \"text/yaml\"}\n</code></pre>"},{"location":"schema_generation/#serving-as-json","title":"Serving as JSON","text":"<pre><code>@app.route(\"/openapi.json\")\ndef get_openapi_json():\n    # Generate the schema\n    # ...\n\n    # Convert to JSON\n    import json\n    json_content = json.dumps(schema, ensure_ascii=False)\n\n    return json_content, 200, {\"Content-Type\": \"application/json\"}\n</code></pre>"},{"location":"schema_generation/#serving-swagger-ui","title":"Serving Swagger UI","text":"<pre><code>@app.route(\"/\")\ndef index():\n    return \"\"\"\n    &lt;!DOCTYPE html&gt;\n    &lt;html&gt;\n    &lt;head&gt;\n        &lt;title&gt;API Documentation&lt;/title&gt;\n        &lt;link rel=\"stylesheet\" type=\"text/css\" href=\"https://cdnjs.cloudflare.com/ajax/libs/swagger-ui/5.9.1/swagger-ui.min.css\"&gt;\n    &lt;/head&gt;\n    &lt;body&gt;\n        &lt;div id=\"swagger-ui\"&gt;&lt;/div&gt;\n        &lt;script src=\"https://cdnjs.cloudflare.com/ajax/libs/swagger-ui/5.9.1/swagger-ui-bundle.min.js\"&gt;&lt;/script&gt;\n        &lt;script&gt;\n            window.onload = function() {\n                SwaggerUIBundle({\n                    url: \"/openapi.yaml\",\n                    dom_id: \"#swagger-ui\",\n                    presets: [\n                        SwaggerUIBundle.presets.apis,\n                        SwaggerUIBundle.SwaggerUIStandalonePreset\n                    ],\n                    layout: \"BaseLayout\",\n                    validatorUrl: null,\n                    displayRequestDuration: true,\n                    syntaxHighlight: {\n                        activated: true,\n                        theme: \"agate\"\n                    }\n                });\n            }\n        &lt;/script&gt;\n    &lt;/body&gt;\n    &lt;/html&gt;\n    \"\"\"\n</code></pre>"},{"location":"schema_generation/#serving-redoc","title":"Serving ReDoc","text":"<pre><code>@app.route(\"/redoc\")\ndef redoc():\n    return \"\"\"\n    &lt;!DOCTYPE html&gt;\n    &lt;html&gt;\n    &lt;head&gt;\n        &lt;title&gt;API Documentation&lt;/title&gt;\n        &lt;meta charset=\"utf-8\"/&gt;\n        &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1\"&gt;\n        &lt;link href=\"https://fonts.googleapis.com/css?family=Montserrat:300,400,700|Roboto:300,400,700\" rel=\"stylesheet\"&gt;\n        &lt;style&gt;\n            body {\n                margin: 0;\n                padding: 0;\n            }\n        &lt;/style&gt;\n    &lt;/head&gt;\n    &lt;body&gt;\n        &lt;redoc spec-url=\"/openapi.yaml\"&gt;&lt;/redoc&gt;\n        &lt;script src=\"https://cdn.jsdelivr.net/npm/redoc@next/bundles/redoc.standalone.js\"&gt;&lt;/script&gt;\n    &lt;/body&gt;\n    &lt;/html&gt;\n    \"\"\"\n</code></pre>"},{"location":"schema_generation/#advanced-schema-generation","title":"Advanced Schema Generation","text":""},{"location":"schema_generation/#internationalization","title":"Internationalization","text":"<p>You can generate schemas in different languages using the internationalization support:</p> <pre><code>from flask_x_openapi_schema import set_current_language\n\n# Set the language for schema generation\nset_current_language(\"zh-Hans\")\n\n# Generate the schema\n# ...\n</code></pre>"},{"location":"schema_generation/#customizing-schema-generation","title":"Customizing Schema Generation","text":"<p>You can customize the schema generation process by subclassing the schema generator:</p> <pre><code>from flask_x_openapi_schema.x.flask.views import MethodViewOpenAPISchemaGenerator\n\nclass CustomSchemaGenerator(MethodViewOpenAPISchemaGenerator):\n    def process_methodview_resources(self, blueprint):\n        # Custom processing logic\n        super().process_methodview_resources(blueprint)\n\n    def generate_schema(self):\n        # Custom schema generation logic\n        schema = super().generate_schema()\n\n        # Add custom components\n        if \"components\" not in schema:\n            schema[\"components\"] = {}\n\n        # Add custom security schemes\n        if \"securitySchemes\" not in schema[\"components\"]:\n            schema[\"components\"][\"securitySchemes\"] = {}\n\n        schema[\"components\"][\"securitySchemes\"][\"customAuth\"] = {\n            \"type\": \"apiKey\",\n            \"in\": \"header\",\n            \"name\": \"X-Custom-Auth\",\n        }\n\n        return schema\n\n# Use the custom generator\ngenerator = CustomSchemaGenerator(\n    title=\"My API\",\n    version=\"1.0.0\",\n    description=\"API for managing resources\",\n)\n</code></pre>"},{"location":"schema_generation/#generating-multiple-schemas","title":"Generating Multiple Schemas","text":"<p>You can generate multiple schemas for different parts of your API:</p> <pre><code># Generate schema for the main API\nmain_generator = MethodViewOpenAPISchemaGenerator(\n    title=\"Main API\",\n    version=\"1.0.0\",\n    description=\"Main API for managing resources\",\n)\nmain_generator.process_methodview_resources(main_blueprint)\nmain_schema = main_generator.generate_schema()\n\n# Generate schema for the admin API\nadmin_generator = MethodViewOpenAPISchemaGenerator(\n    title=\"Admin API\",\n    version=\"1.0.0\",\n    description=\"Admin API for managing resources\",\n)\nadmin_generator.process_methodview_resources(admin_blueprint)\nadmin_schema = admin_generator.generate_schema()\n\n# Serve the schemas\n@app.route(\"/openapi.yaml\")\ndef get_openapi_yaml():\n    return yaml.dump(main_schema, sort_keys=False, default_flow_style=False), 200, {\"Content-Type\": \"text/yaml\"}\n\n@app.route(\"/admin/openapi.yaml\")\ndef get_admin_openapi_yaml():\n    return yaml.dump(admin_schema, sort_keys=False, default_flow_style=False), 200, {\"Content-Type\": \"text/yaml\"}\n</code></pre>"},{"location":"schema_generation/#working-examples","title":"Working Examples","text":"<p>For complete working examples of schema generation, check out the example applications in the repository:</p> <ul> <li>Flask MethodView Schema Generation: Demonstrates generating OpenAPI schema from Flask.MethodView classes</li> <li>Flask-RESTful Schema Generation: Demonstrates generating OpenAPI schema from Flask-RESTful resources</li> <li>Swagger UI Integration: Demonstrates integrating Swagger UI for API documentation</li> </ul> <p>These examples show how to:</p> <ul> <li>Generate OpenAPI schema from Flask.MethodView classes and Flask-RESTful resources</li> <li>Customize schema information (title, version, description)</li> <li>Serve the schema as YAML or JSON</li> <li>Integrate Swagger UI for interactive API documentation</li> </ul> <p>You can run the examples using the provided justfile commands:</p> <pre><code># Run the Flask MethodView example\njust run-example-flask\n\n# Run the Flask-RESTful example\njust run-example-flask-restful\n</code></pre>"},{"location":"schema_generation/#conclusion","title":"Conclusion","text":"<p>Flask-X-OpenAPI-Schema provides powerful tools for generating OpenAPI schemas from your Flask and Flask-RESTful applications. By using the schema generators and customizing the schema generation process, you can create comprehensive API documentation that accurately reflects your API's capabilities.</p>"},{"location":"usage_guide/","title":"Usage Guide for Flask-X-OpenAPI-Schema","text":"<p>This guide provides comprehensive examples and best practices for using Flask-X-OpenAPI-Schema in your Flask and Flask-RESTful applications.</p>"},{"location":"usage_guide/#table-of-contents","title":"Table of Contents","text":"<ul> <li>Basic Setup</li> <li>Flask.MethodView Integration</li> <li>Flask-RESTful Integration</li> <li>Parameter Binding</li> <li>Response Handling</li> <li>File Uploads</li> <li>Internationalization</li> <li>Schema Generation</li> <li>Best Practices</li> </ul>"},{"location":"usage_guide/#basic-setup","title":"Basic Setup","text":""},{"location":"usage_guide/#installation","title":"Installation","text":"<pre><code># Basic installation\npip install flask-x-openapi-schema\n\n# With Flask-RESTful support\npip install flask-x-openapi-schema[flask-restful]\n</code></pre>"},{"location":"usage_guide/#project-structure","title":"Project Structure","text":"<p>A typical project structure might look like this:</p> <pre><code>my_api/\n\u251c\u2500\u2500 __init__.py\n\u251c\u2500\u2500 app.py\n\u251c\u2500\u2500 models/\n\u2502   \u251c\u2500\u2500 __init__.py\n\u2502   \u251c\u2500\u2500 request_models.py\n\u2502   \u2514\u2500\u2500 response_models.py\n\u251c\u2500\u2500 resources/\n\u2502   \u251c\u2500\u2500 __init__.py\n\u2502   \u251c\u2500\u2500 user_resource.py\n\u2502   \u2514\u2500\u2500 item_resource.py\n\u251c\u2500\u2500 views/\n\u2502   \u251c\u2500\u2500 __init__.py\n\u2502   \u251c\u2500\u2500 user_view.py\n\u2502   \u2514\u2500\u2500 item_view.py\n\u2514\u2500\u2500 utils/\n    \u251c\u2500\u2500 __init__.py\n    \u2514\u2500\u2500 schema_utils.py\n</code></pre>"},{"location":"usage_guide/#basic-configuration","title":"Basic Configuration","text":"<pre><code># app.py\nfrom flask import Flask\nfrom flask_x_openapi_schema import configure_prefixes, ConventionalPrefixConfig\n\n# Create a Flask app\napp = Flask(__name__)\n\n# Configure parameter prefixes (optional)\ncustom_config = ConventionalPrefixConfig(\n    request_body_prefix=\"_x_body\",\n    request_query_prefix=\"_x_query\",\n    request_path_prefix=\"_x_path\",\n    request_file_prefix=\"_x_file\"\n)\nconfigure_prefixes(custom_config)\n</code></pre>"},{"location":"usage_guide/#flaskmethodview-integration","title":"Flask.MethodView Integration","text":""},{"location":"usage_guide/#basic-methodview-example","title":"Basic MethodView Example","text":"<pre><code># views/user_view.py\nfrom flask.views import MethodView\nfrom flask import jsonify\nfrom flask_x_openapi_schema.x.flask import openapi_metadata, OpenAPIMethodViewMixin\nfrom flask_x_openapi_schema import OpenAPIMetaResponse, OpenAPIMetaResponseItem\n\nfrom my_api.models.request_models import UserCreateRequest, UserUpdateRequest\nfrom my_api.models.response_models import UserResponse, ErrorResponse\n\nclass UserView(OpenAPIMethodViewMixin, MethodView):\n    @openapi_metadata(\n        summary=\"Get all users\",\n        description=\"Retrieve a list of all users\",\n        tags=[\"users\"],\n        operation_id=\"getUsers\",\n        responses=OpenAPIMetaResponse(\n            responses={\n                \"200\": OpenAPIMetaResponseItem(\n                    model=UserResponse,\n                    description=\"List of users retrieved successfully\",\n                ),\n                \"500\": OpenAPIMetaResponseItem(\n                    model=ErrorResponse,\n                    description=\"Internal server error\",\n                ),\n            }\n        ),\n    )\n    def get(self):\n        # Implementation...\n        users = [\n            {\"id\": \"1\", \"username\": \"user1\", \"email\": \"user1@example.com\"},\n            {\"id\": \"2\", \"username\": \"user2\", \"email\": \"user2@example.com\"},\n        ]\n        return jsonify(users), 200\n\n    @openapi_metadata(\n        summary=\"Create a new user\",\n        description=\"Create a new user with the provided information\",\n        tags=[\"users\"],\n        operation_id=\"createUser\",\n        responses=OpenAPIMetaResponse(\n            responses={\n                \"201\": OpenAPIMetaResponseItem(\n                    model=UserResponse,\n                    description=\"User created successfully\",\n                ),\n                \"400\": OpenAPIMetaResponseItem(\n                    model=ErrorResponse,\n                    description=\"Invalid request data\",\n                ),\n                \"500\": OpenAPIMetaResponseItem(\n                    model=ErrorResponse,\n                    description=\"Internal server error\",\n                ),\n            }\n        ),\n    )\n    def post(self, _x_body: UserCreateRequest):\n        # Implementation...\n        user = {\n            \"id\": \"3\",\n            \"username\": _x_body.username,\n            \"email\": _x_body.email,\n        }\n        return jsonify(user), 201\n</code></pre>"},{"location":"usage_guide/#registering-methodviews","title":"Registering MethodViews","text":"<pre><code># app.py\nfrom flask import Flask, Blueprint\nfrom my_api.views.user_view import UserView\nfrom my_api.views.item_view import ItemView, ItemDetailView\n\n# Create a Flask app\napp = Flask(__name__)\n\n# Create a blueprint\nblueprint = Blueprint(\"api\", __name__, url_prefix=\"/api\")\n\n# Register the views\nUserView.register_to_blueprint(blueprint, \"/users\", \"users\")\nItemView.register_to_blueprint(blueprint, \"/items\", \"items\")\nItemDetailView.register_to_blueprint(blueprint, \"/items/&lt;item_id&gt;\", \"item_detail\")\n\n# Register the blueprint\napp.register_blueprint(blueprint)\n</code></pre>"},{"location":"usage_guide/#generating-openapi-schema","title":"Generating OpenAPI Schema","text":"<pre><code># app.py\nfrom flask_x_openapi_schema.x.flask.views import MethodViewOpenAPISchemaGenerator\nimport yaml\n\n@app.route(\"/openapi.yaml\")\ndef get_openapi_spec():\n    generator = MethodViewOpenAPISchemaGenerator(\n        title=\"My API\",\n        version=\"1.0.0\",\n        description=\"API for managing users and items\",\n    )\n\n    # Process MethodView resources\n    generator.process_methodview_resources(blueprint)\n\n    # Generate the schema\n    schema = generator.generate_schema()\n\n    # Convert to YAML\n    yaml_content = yaml.dump(\n        schema,\n        sort_keys=False,\n        default_flow_style=False,\n        allow_unicode=True,\n    )\n\n    return yaml_content, 200, {\"Content-Type\": \"text/yaml\"}\n</code></pre>"},{"location":"usage_guide/#flask-restful-integration","title":"Flask-RESTful Integration","text":""},{"location":"usage_guide/#basic-resource-example","title":"Basic Resource Example","text":"<pre><code># resources/user_resource.py\nfrom flask_restful import Resource\nfrom flask_x_openapi_schema.x.flask_restful import openapi_metadata\nfrom flask_x_openapi_schema import OpenAPIMetaResponse, OpenAPIMetaResponseItem\n\nfrom my_api.models.request_models import UserCreateRequest, UserUpdateRequest\nfrom my_api.models.response_models import UserResponse, ErrorResponse\n\nclass UserListResource(Resource):\n    @openapi_metadata(\n        summary=\"Get all users\",\n        description=\"Retrieve a list of all users\",\n        tags=[\"users\"],\n        operation_id=\"getUsers\",\n        responses=OpenAPIMetaResponse(\n            responses={\n                \"200\": OpenAPIMetaResponseItem(\n                    model=UserResponse,\n                    description=\"List of users retrieved successfully\",\n                ),\n                \"500\": OpenAPIMetaResponseItem(\n                    model=ErrorResponse,\n                    description=\"Internal server error\",\n                ),\n            }\n        ),\n    )\n    def get(self):\n        # Implementation...\n        users = [\n            {\"id\": \"1\", \"username\": \"user1\", \"email\": \"user1@example.com\"},\n            {\"id\": \"2\", \"username\": \"user2\", \"email\": \"user2@example.com\"},\n        ]\n        return users, 200\n\n    @openapi_metadata(\n        summary=\"Create a new user\",\n        description=\"Create a new user with the provided information\",\n        tags=[\"users\"],\n        operation_id=\"createUser\",\n        responses=OpenAPIMetaResponse(\n            responses={\n                \"201\": OpenAPIMetaResponseItem(\n                    model=UserResponse,\n                    description=\"User created successfully\",\n                ),\n                \"400\": OpenAPIMetaResponseItem(\n                    model=ErrorResponse,\n                    description=\"Invalid request data\",\n                ),\n                \"500\": OpenAPIMetaResponseItem(\n                    model=ErrorResponse,\n                    description=\"Internal server error\",\n                ),\n            }\n        ),\n    )\n    def post(self, _x_body: UserCreateRequest):\n        # Implementation...\n        user = {\n            \"id\": \"3\",\n            \"username\": _x_body.username,\n            \"email\": _x_body.email,\n        }\n        return user, 201\n\nclass UserResource(Resource):\n    @openapi_metadata(\n        summary=\"Get a user by ID\",\n        description=\"Retrieve a user by its unique identifier\",\n        tags=[\"users\"],\n        operation_id=\"getUser\",\n        responses=OpenAPIMetaResponse(\n            responses={\n                \"200\": OpenAPIMetaResponseItem(\n                    model=UserResponse,\n                    description=\"User retrieved successfully\",\n                ),\n                \"404\": OpenAPIMetaResponseItem(\n                    model=ErrorResponse,\n                    description=\"User not found\",\n                ),\n                \"500\": OpenAPIMetaResponseItem(\n                    model=ErrorResponse,\n                    description=\"Internal server error\",\n                ),\n            }\n        ),\n    )\n    def get(self, user_id: str):\n        # Implementation...\n        if user_id not in [\"1\", \"2\"]:\n            return {\"error_code\": \"USER_NOT_FOUND\", \"message\": \"User not found\"}, 404\n\n        user = {\n            \"id\": user_id,\n            \"username\": f\"user{user_id}\",\n            \"email\": f\"user{user_id}@example.com\",\n        }\n        return user, 200\n</code></pre>"},{"location":"usage_guide/#registering-resources","title":"Registering Resources","text":"<pre><code># app.py\nfrom flask import Flask\nfrom flask_restful import Api\nfrom flask_x_openapi_schema.x.flask_restful import OpenAPIIntegrationMixin\n\nfrom my_api.resources.user_resource import UserListResource, UserResource\nfrom my_api.resources.item_resource import ItemListResource, ItemResource\n\n# Create a Flask app\napp = Flask(__name__)\n\n# Create an OpenAPI-enabled API\nclass OpenAPIApi(OpenAPIIntegrationMixin, Api):\n    pass\n\napi = OpenAPIApi(app)\n\n# Register the resources\napi.add_resource(UserListResource, \"/api/users\")\napi.add_resource(UserResource, \"/api/users/&lt;string:user_id&gt;\")\napi.add_resource(ItemListResource, \"/api/items\")\napi.add_resource(ItemResource, \"/api/items/&lt;string:item_id&gt;\")\n</code></pre>"},{"location":"usage_guide/#generating-openapi-schema_1","title":"Generating OpenAPI Schema","text":"<pre><code># app.py\nimport yaml\n\n@app.route(\"/openapi.yaml\")\ndef get_openapi_spec():\n    schema = api.generate_openapi_schema(\n        title=\"My API\",\n        version=\"1.0.0\",\n        description=\"API for managing users and items\",\n        output_format=\"json\",\n    )\n\n    # Convert to YAML\n    yaml_content = yaml.dump(\n        schema,\n        sort_keys=False,\n        default_flow_style=False,\n        allow_unicode=True,\n    )\n\n    return yaml_content, 200, {\"Content-Type\": \"text/yaml\"}\n</code></pre>"},{"location":"usage_guide/#parameter-binding","title":"Parameter Binding","text":""},{"location":"usage_guide/#request-body","title":"Request Body","text":"<pre><code>@openapi_metadata(\n    summary=\"Create a new item\",\n    # ...\n)\ndef post(self, _x_body: ItemCreateRequest):\n    # _x_body is automatically populated from the request JSON\n    item = {\n        \"id\": \"123\",\n        \"name\": _x_body.name,\n        \"description\": _x_body.description,\n        \"price\": _x_body.price,\n    }\n    return item, 201\n</code></pre>"},{"location":"usage_guide/#query-parameters","title":"Query Parameters","text":"<pre><code>@openapi_metadata(\n    summary=\"Get all items\",\n    # ...\n)\ndef get(self, _x_query: ItemFilterParams = None):\n    # _x_query is automatically populated from the query parameters\n    items = [...]\n\n    if _x_query:\n        if _x_query.category:\n            items = [item for item in items if item[\"category\"] == _x_query.category]\n\n        if _x_query.min_price is not None:\n            items = [item for item in items if item[\"price\"] &gt;= _x_query.min_price]\n\n        if _x_query.max_price is not None:\n            items = [item for item in items if item[\"price\"] &lt;= _x_query.max_price]\n\n        # Apply pagination\n        items = items[_x_query.offset:_x_query.offset + _x_query.limit]\n\n    return items, 200\n</code></pre>"},{"location":"usage_guide/#path-parameters","title":"Path Parameters","text":"<pre><code>@openapi_metadata(\n    summary=\"Get an item by ID\",\n    # ...\n)\ndef get(self, item_id: str):\n    # item_id is automatically populated from the path parameter\n    if item_id not in [\"123\", \"456\"]:\n        return {\"error_code\": \"ITEM_NOT_FOUND\", \"message\": \"Item not found\"}, 404\n\n    item = {\n        \"id\": item_id,\n        \"name\": f\"Item {item_id}\",\n        \"description\": f\"Description for item {item_id}\",\n        \"price\": float(item_id),\n    }\n    return item, 200\n</code></pre>"},{"location":"usage_guide/#file-uploads","title":"File Uploads","text":"<pre><code>@openapi_metadata(\n    summary=\"Upload an item image\",\n    # ...\n)\ndef post(self, item_id: str, _x_file: ImageUploadModel):\n    # _x_file.file is automatically populated from the uploaded file\n    file = _x_file.file\n\n    # Save the file\n    file.save(f\"uploads/{item_id}_{file.filename}\")\n\n    return {\"message\": \"File uploaded successfully\"}, 201\n</code></pre>"},{"location":"usage_guide/#custom-parameter-prefixes","title":"Custom Parameter Prefixes","text":"<pre><code>from flask_x_openapi_schema import ConventionalPrefixConfig\n\n# Create a custom configuration\ncustom_config = ConventionalPrefixConfig(\n    request_body_prefix=\"req_body\",\n    request_query_prefix=\"req_query\",\n    request_path_prefix=\"req_path\",\n    request_file_prefix=\"req_file\"\n)\n\n@openapi_metadata(\n    summary=\"Create a new item\",\n    prefix_config=custom_config,\n    # ...\n)\ndef post(self, req_body: ItemCreateRequest):\n    # req_body is automatically populated from the request JSON\n    item = {\n        \"id\": \"123\",\n        \"name\": req_body.name,\n        \"description\": req_body.description,\n        \"price\": req_body.price,\n    }\n    return item, 201\n</code></pre>"},{"location":"usage_guide/#response-handling","title":"Response Handling","text":""},{"location":"usage_guide/#basic-responses","title":"Basic Responses","text":"<pre><code>@openapi_metadata(\n    summary=\"Get all items\",\n    # ...\n)\ndef get(self):\n    # Implementation...\n    items = [\n        {\"id\": \"123\", \"name\": \"Item 1\", \"price\": 10.99},\n        {\"id\": \"456\", \"name\": \"Item 2\", \"price\": 20.99},\n    ]\n    return items, 200\n</code></pre>"},{"location":"usage_guide/#using-baserespmodel","title":"Using BaseRespModel","text":"<pre><code>from flask_x_openapi_schema import BaseRespModel\nfrom pydantic import Field\n\nclass ItemResponse(BaseRespModel):\n    id: str = Field(..., description=\"Item ID\")\n    name: str = Field(..., description=\"Item name\")\n    description: str = Field(None, description=\"Item description\")\n    price: float = Field(..., description=\"Item price\")\n\n@openapi_metadata(\n    summary=\"Get an item by ID\",\n    # ...\n)\ndef get(self, item_id: str):\n    # Implementation...\n    if item_id not in [\"123\", \"456\"]:\n        error = ErrorResponse(\n            error_code=\"ITEM_NOT_FOUND\",\n            message=\"Item not found\",\n        )\n        return error.to_response(404)\n\n    item = ItemResponse(\n        id=item_id,\n        name=f\"Item {item_id}\",\n        description=f\"Description for item {item_id}\",\n        price=float(item_id),\n    )\n    return item.to_response(200)\n</code></pre>"},{"location":"usage_guide/#documenting-responses","title":"Documenting Responses","text":"<pre><code>@openapi_metadata(\n    summary=\"Create a new item\",\n    description=\"Create a new item with the provided information\",\n    tags=[\"items\"],\n    operation_id=\"createItem\",\n    responses=OpenAPIMetaResponse(\n        responses={\n            \"201\": OpenAPIMetaResponseItem(\n                model=ItemResponse,\n                description=\"Item created successfully\",\n            ),\n            \"400\": OpenAPIMetaResponseItem(\n                model=ErrorResponse,\n                description=\"Invalid request data\",\n            ),\n            \"500\": OpenAPIMetaResponseItem(\n                model=ErrorResponse,\n                description=\"Internal server error\",\n            ),\n        }\n    ),\n)\ndef post(self, _x_body: ItemCreateRequest):\n    # Implementation...\n</code></pre>"},{"location":"usage_guide/#file-uploads_1","title":"File Uploads","text":""},{"location":"usage_guide/#basic-file-upload","title":"Basic File Upload","text":"<pre><code>from flask_x_openapi_schema import ImageUploadModel\n\n@openapi_metadata(\n    summary=\"Upload an item image\",\n    # ...\n)\ndef post(self, item_id: str, _x_file: ImageUploadModel):\n    # _x_file.file is automatically populated from the uploaded file\n    file = _x_file.file\n\n    # Save the file\n    file.save(f\"uploads/{item_id}_{file.filename}\")\n\n    return {\"message\": \"File uploaded successfully\"}, 201\n</code></pre>"},{"location":"usage_guide/#custom-file-upload-model","title":"Custom File Upload Model","text":"<pre><code>from flask_x_openapi_schema import ImageUploadModel\nfrom pydantic import Field\n\nclass ItemImageUpload(ImageUploadModel):\n    description: str = Field(..., description=\"Image description\")\n    is_primary: bool = Field(False, description=\"Whether this is the primary item image\")\n\n@openapi_metadata(\n    summary=\"Upload an item image\",\n    # ...\n)\ndef post(self, item_id: str, _x_file: ItemImageUpload):\n    # _x_file.file is automatically populated from the uploaded file\n    file = _x_file.file\n\n    # Access additional fields\n    description = _x_file.description\n    is_primary = _x_file.is_primary\n\n    # Save the file\n    file.save(f\"uploads/{item_id}_{file.filename}\")\n\n    return {\n        \"message\": \"File uploaded successfully\",\n        \"description\": description,\n        \"is_primary\": is_primary,\n    }, 201\n</code></pre>"},{"location":"usage_guide/#multiple-file-uploads","title":"Multiple File Uploads","text":"<pre><code>@openapi_metadata(\n    summary=\"Upload item files\",\n    # ...\n)\ndef post(\n    self,\n    item_id: str,\n    _x_file_image: ImageUploadModel,\n    _x_file_document: DocumentUploadModel,\n):\n    # Access each file\n    image = _x_file_image.file\n    document = _x_file_document.file\n\n    # Save the files\n    image.save(f\"uploads/{item_id}_image_{image.filename}\")\n    document.save(f\"uploads/{item_id}_document_{document.filename}\")\n\n    return {\"message\": \"Files uploaded successfully\"}, 201\n</code></pre>"},{"location":"usage_guide/#internationalization","title":"Internationalization","text":""},{"location":"usage_guide/#using-i18nstr","title":"Using I18nStr","text":"<pre><code>from flask_x_openapi_schema import I18nStr, set_current_language\n\n# Set the current language\nset_current_language(\"zh-Hans\")\n\n@openapi_metadata(\n    summary=I18nStr({\n        \"en-US\": \"Get an item\",\n        \"zh-Hans\": \"\u83b7\u53d6\u4e00\u4e2a\u9879\u76ee\",\n        \"ja-JP\": \"\u30a2\u30a4\u30c6\u30e0\u3092\u53d6\u5f97\u3059\u308b\",\n    }),\n    description=I18nStr({\n        \"en-US\": \"Get an item by ID from the database\",\n        \"zh-Hans\": \"\u901a\u8fc7ID\u4ece\u6570\u636e\u5e93\u83b7\u53d6\u4e00\u4e2a\u9879\u76ee\",\n        \"ja-JP\": \"ID\u304b\u3089\u30c7\u30fc\u30bf\u30d9\u30fc\u30b9\u304b\u3089\u30a2\u30a4\u30c6\u30e0\u3092\u53d6\u5f97\u3059\u308b\",\n    }),\n    tags=[\"items\"],\n    operation_id=\"getItem\",\n    # ...\n)\ndef get(self, item_id: str):\n    # Implementation...\n</code></pre>"},{"location":"usage_guide/#language-switching","title":"Language Switching","text":"<pre><code>import contextlib\nfrom flask_x_openapi_schema import set_current_language, get_current_language\n\n@contextlib.contextmanager\ndef language_context(language):\n    \"\"\"Temporarily switch to a different language.\"\"\"\n    previous_language = get_current_language()\n    set_current_language(language)\n    try:\n        yield\n    finally:\n        set_current_language(previous_language)\n\n# Use the context manager\nwith language_context(\"zh-Hans\"):\n    # Generate schema in Chinese\n    schema_zh = generator.generate_schema()\n\nwith language_context(\"ja-JP\"):\n    # Generate schema in Japanese\n    schema_ja = generator.generate_schema()\n</code></pre>"},{"location":"usage_guide/#schema-generation","title":"Schema Generation","text":""},{"location":"usage_guide/#basic-schema-generation","title":"Basic Schema Generation","text":"<pre><code>from flask_x_openapi_schema.x.flask.views import MethodViewOpenAPISchemaGenerator\nimport yaml\n\n@app.route(\"/openapi.yaml\")\ndef get_openapi_spec():\n    generator = MethodViewOpenAPISchemaGenerator(\n        title=\"My API\",\n        version=\"1.0.0\",\n        description=\"API for managing resources\",\n    )\n\n    # Process MethodView resources\n    generator.process_methodview_resources(blueprint)\n\n    # Generate the schema\n    schema = generator.generate_schema()\n\n    # Convert to YAML\n    yaml_content = yaml.dump(\n        schema,\n        sort_keys=False,\n        default_flow_style=False,\n        allow_unicode=True,\n    )\n\n    return yaml_content, 200, {\"Content-Type\": \"text/yaml\"}\n</code></pre>"},{"location":"usage_guide/#serving-swagger-ui","title":"Serving Swagger UI","text":"<pre><code>@app.route(\"/\")\ndef index():\n    return \"\"\"\n    &lt;!DOCTYPE html&gt;\n    &lt;html&gt;\n    &lt;head&gt;\n        &lt;title&gt;API Documentation&lt;/title&gt;\n        &lt;link rel=\"stylesheet\" type=\"text/css\" href=\"https://cdnjs.cloudflare.com/ajax/libs/swagger-ui/5.9.1/swagger-ui.min.css\"&gt;\n    &lt;/head&gt;\n    &lt;body&gt;\n        &lt;div id=\"swagger-ui\"&gt;&lt;/div&gt;\n        &lt;script src=\"https://cdnjs.cloudflare.com/ajax/libs/swagger-ui/5.9.1/swagger-ui-bundle.min.js\"&gt;&lt;/script&gt;\n        &lt;script&gt;\n            window.onload = function() {\n                SwaggerUIBundle({\n                    url: \"/openapi.yaml\",\n                    dom_id: \"#swagger-ui\",\n                    presets: [\n                        SwaggerUIBundle.presets.apis,\n                        SwaggerUIBundle.SwaggerUIStandalonePreset\n                    ],\n                    layout: \"BaseLayout\",\n                    validatorUrl: null,\n                    displayRequestDuration: true,\n                    syntaxHighlight: {\n                        activated: true,\n                        theme: \"agate\"\n                    }\n                });\n            }\n        &lt;/script&gt;\n    &lt;/body&gt;\n    &lt;/html&gt;\n    \"\"\"\n</code></pre>"},{"location":"usage_guide/#best-practices","title":"Best Practices","text":""},{"location":"usage_guide/#1-use-descriptive-operation-ids","title":"1. Use Descriptive Operation IDs","text":"<p>Operation IDs should be unique and descriptive:</p> <pre><code>@openapi_metadata(\n    summary=\"Get all users\",\n    operation_id=\"getAllUsers\",  # Good\n    # ...\n)\n</code></pre> <p>Instead of:</p> <pre><code>@openapi_metadata(\n    summary=\"Get all users\",\n    operation_id=\"get\",  # Bad - not descriptive\n    # ...\n)\n</code></pre>"},{"location":"usage_guide/#2-group-related-operations-with-tags","title":"2. Group Related Operations with Tags","text":"<p>Use tags to group related operations:</p> <pre><code>@openapi_metadata(\n    summary=\"Get all users\",\n    tags=[\"users\"],  # Group with other user operations\n    # ...\n)\n</code></pre>"},{"location":"usage_guide/#3-provide-comprehensive-response-documentation","title":"3. Provide Comprehensive Response Documentation","text":"<p>Document all possible response types:</p> <pre><code>@openapi_metadata(\n    summary=\"Create a new user\",\n    responses=OpenAPIMetaResponse(\n        responses={\n            \"201\": OpenAPIMetaResponseItem(\n                model=UserResponse,\n                description=\"User created successfully\",\n            ),\n            \"400\": OpenAPIMetaResponseItem(\n                model=ErrorResponse,\n                description=\"Invalid request data\",\n            ),\n            \"409\": OpenAPIMetaResponseItem(\n                model=ErrorResponse,\n                description=\"Username already exists\",\n            ),\n            \"500\": OpenAPIMetaResponseItem(\n                model=ErrorResponse,\n                description=\"Internal server error\",\n            ),\n        }\n    ),\n    # ...\n)\n</code></pre>"},{"location":"usage_guide/#4-use-pydantic-field-descriptions","title":"4. Use Pydantic Field Descriptions","text":"<p>Add descriptions to all Pydantic fields:</p> <pre><code>from pydantic import BaseModel, Field\n\nclass UserCreateRequest(BaseModel):\n    username: str = Field(..., description=\"User's username\")\n    email: str = Field(..., description=\"User's email address\")\n    password: str = Field(..., description=\"User's password\")\n    full_name: str = Field(None, description=\"User's full name\")\n</code></pre>"},{"location":"usage_guide/#5-centralize-model-definitions","title":"5. Centralize Model Definitions","text":"<p>Keep model definitions in a central location:</p> <pre><code>my_api/\n\u251c\u2500\u2500 models/\n\u2502   \u251c\u2500\u2500 __init__.py\n\u2502   \u251c\u2500\u2500 request_models.py\n\u2502   \u2514\u2500\u2500 response_models.py\n</code></pre>"},{"location":"usage_guide/#6-use-consistent-naming-conventions","title":"6. Use Consistent Naming Conventions","text":"<p>Use consistent naming conventions for models and endpoints:</p> <ul> <li>Request models: <code>{Resource}CreateRequest</code>, <code>{Resource}UpdateRequest</code></li> <li>Response models: <code>{Resource}Response</code></li> <li>Error models: <code>ErrorResponse</code></li> <li>List resources: <code>{Resource}ListResource</code></li> <li>Individual resources: <code>{Resource}Resource</code></li> </ul>"},{"location":"usage_guide/#7-implement-proper-error-handling","title":"7. Implement Proper Error Handling","text":"<p>Use structured error responses:</p> <pre><code>from flask_x_openapi_schema import BaseRespModel\nfrom pydantic import Field\n\nclass ErrorResponse(BaseRespModel):\n    error_code: str = Field(..., description=\"Error code\")\n    message: str = Field(..., description=\"Error message\")\n    details: dict = Field(None, description=\"Additional error details\")\n\n@openapi_metadata(\n    summary=\"Get a user by ID\",\n    # ...\n)\ndef get(self, user_id: str):\n    if user_id not in [\"1\", \"2\"]:\n        error = ErrorResponse(\n            error_code=\"USER_NOT_FOUND\",\n            message=f\"User with ID {user_id} not found\",\n        )\n        return error.to_response(404)\n\n    # ...\n</code></pre>"},{"location":"usage_guide/#8-use-pagination-for-list-endpoints","title":"8. Use Pagination for List Endpoints","text":"<p>Implement pagination for list endpoints:</p> <pre><code>from pydantic import BaseModel, Field\n\nclass PaginationParams(BaseModel):\n    page: int = Field(1, description=\"Page number\")\n    per_page: int = Field(10, description=\"Items per page\")\n\nclass UserFilterParams(PaginationParams):\n    username: str = Field(None, description=\"Filter by username\")\n    email: str = Field(None, description=\"Filter by email\")\n\n@openapi_metadata(\n    summary=\"Get all users\",\n    # ...\n)\ndef get(self, _x_query: UserFilterParams = None):\n    # Implementation with pagination\n    # ...\n</code></pre>"},{"location":"usage_guide/#9-use-enums-for-fixed-values","title":"9. Use Enums for Fixed Values","text":"<p>Use enums for fields with fixed values:</p> <pre><code>from enum import Enum\nfrom pydantic import BaseModel, Field\n\nclass UserRole(str, Enum):\n    ADMIN = \"admin\"\n    USER = \"user\"\n    GUEST = \"guest\"\n\nclass UserCreateRequest(BaseModel):\n    username: str = Field(..., description=\"User's username\")\n    email: str = Field(..., description=\"User's email address\")\n    password: str = Field(..., description=\"User's password\")\n    role: UserRole = Field(UserRole.USER, description=\"User's role\")\n</code></pre>"},{"location":"usage_guide/#10-implement-validation","title":"10. Implement Validation","text":"<p>Use Pydantic validators for custom validation:</p> <pre><code>from pydantic import BaseModel, Field, validator\nimport re\n\nclass UserCreateRequest(BaseModel):\n    username: str = Field(..., description=\"User's username\")\n    email: str = Field(..., description=\"User's email address\")\n    password: str = Field(..., description=\"User's password\")\n\n    @validator(\"username\")\n    def username_must_be_valid(cls, v):\n        if not re.match(r\"^[a-zA-Z0-9_]+$\", v):\n            raise ValueError(\"Username must contain only letters, numbers, and underscores\")\n        return v\n\n    @validator(\"email\")\n    def email_must_be_valid(cls, v):\n        if not re.match(r\"^[a-zA-Z0-9_.+-]+@[a-zA-Z0-9-]+\\.[a-zA-Z0-9-.]+$\", v):\n            raise ValueError(\"Email must be a valid email address\")\n        return v\n\n    @validator(\"password\")\n    def password_must_be_strong(cls, v):\n        if len(v) &lt; 8:\n            raise ValueError(\"Password must be at least 8 characters long\")\n        return v\n</code></pre>"},{"location":"api/","title":"API Reference","text":"<p>This section provides detailed API documentation for the Flask-X-OpenAPI-Schema library. The documentation is generated directly from the source code, ensuring it always stays in sync with the latest code.</p>"},{"location":"api/#overview","title":"Overview","text":"<p>Flask-X-OpenAPI-Schema is organized into several main components:</p> <ul> <li>Core Modules: The foundation of the library, including configuration, caching, and schema generation.</li> <li>Flask Integration: Components for integrating with Flask applications.</li> <li>Flask-RESTful Integration: Components for integrating with Flask-RESTful applications.</li> <li>Models: Pydantic models for requests, responses, and file uploads.</li> <li>Internationalization: Support for multiple languages in your API documentation.</li> </ul>"},{"location":"api/#common-usage-patterns","title":"Common Usage Patterns","text":""},{"location":"api/#basic-setup","title":"Basic Setup","text":"<pre><code>from flask import Flask\nfrom flask_x_openapi_schema.core.config import ConventionalPrefixConfig, configure_prefixes\nfrom flask_x_openapi_schema.x.flask import openapi_metadata\n\n# Configure global prefix settings\nconfig = ConventionalPrefixConfig(\n    request_body_prefix=\"body\",\n    request_query_prefix=\"query\",\n    request_path_prefix=\"path\"\n)\nconfigure_prefixes(config)\n\napp = Flask(__name__)\n</code></pre>"},{"location":"api/#using-with-flask-methodview","title":"Using with Flask MethodView","text":"<pre><code>from flask.views import MethodView\nfrom flask_x_openapi_schema.x.flask import openapi_metadata\nfrom pydantic import BaseModel\n\nclass UserRequest(BaseModel):\n    name: str\n    email: str\n\nclass UserResponse(BaseModel):\n    id: int\n    name: str\n    email: str\n\nclass UserView(MethodView):\n    @openapi_metadata(\n        summary=\"Create a new user\",\n        description=\"Creates a new user with the provided information\",\n        tags=[\"users\"]\n    )\n    def post(self, x_request_body_user: UserRequest) -&gt; UserResponse:\n        # The parameter will be automatically bound from request body\n        user_data = x_request_body_user\n        # Process the data...\n        return UserResponse(id=1, name=user_data.name, email=user_data.email)\n</code></pre>"},{"location":"api/#using-with-flask-restful","title":"Using with Flask-RESTful","text":"<pre><code>from flask_restful import Resource\nfrom flask_x_openapi_schema.x.flask_restful import openapi_metadata\nfrom pydantic import BaseModel\n\nclass UserRequest(BaseModel):\n    name: str\n    email: str\n\nclass UserResponse(BaseModel):\n    id: int\n    name: str\n    email: str\n\nclass UserResource(Resource):\n    @openapi_metadata(\n        summary=\"Create a new user\",\n        description=\"Creates a new user with the provided information\",\n        tags=[\"users\"]\n    )\n    def post(self, x_request_body_user: UserRequest) -&gt; UserResponse:\n        # The parameter will be automatically bound from request body\n        user_data = x_request_body_user\n        # Process the data...\n        return UserResponse(id=1, name=user_data.name, email=user_data.email).model_dump()\n</code></pre>"},{"location":"api/#api-documentation","title":"API Documentation","text":"<p>For detailed API documentation, please refer to the following sections:</p> <ul> <li>Core Modules</li> <li>Flask Integration</li> <li>Flask-RESTful Integration</li> <li>Models</li> <li>Internationalization Support</li> </ul>"},{"location":"api/core/","title":"Core Modules","text":"<p>This section provides documentation for the core components of Flask-X-OpenAPI-Schema.</p>"},{"location":"api/core/#configuration","title":"Configuration","text":"<p>Configuration management for OpenAPI schema generation.</p> <p>This module provides configuration classes and utilities for managing parameter prefixes and other settings for OpenAPI schema generation.</p> <p>Includes classes for managing conventional parameter prefixes, caching behavior, and OpenAPI schema generation settings, along with thread-safe global configuration.</p>"},{"location":"api/core/#flask_x_openapi_schema.core.config.CacheConfig","title":"<code>CacheConfig</code>  <code>dataclass</code>","text":"<p>Configuration class for caching behavior.</p> <p>This class holds configuration settings for controlling cache behavior in the library.</p> <p>Attributes:</p> Name Type Description <code>enabled</code> <code>bool</code> <p>Global flag to enable/disable function metadata caching (default: True)</p> Source code in <code>src/flask_x_openapi_schema/core/config.py</code> <pre><code>@dataclass(frozen=True)\nclass CacheConfig:\n    \"\"\"Configuration class for caching behavior.\n\n    This class holds configuration settings for controlling cache behavior\n    in the library.\n\n    Attributes:\n        enabled: Global flag to enable/disable function metadata caching (default: True)\n\n    \"\"\"\n\n    enabled: bool = True\n</code></pre>"},{"location":"api/core/#flask_x_openapi_schema.core.config.ConventionalPrefixConfig","title":"<code>ConventionalPrefixConfig</code>  <code>dataclass</code>","text":"<p>Configuration class for OpenAPI parameter prefixes.</p> <p>This class holds configuration settings for parameter prefixes used in binding request data to function parameters.</p> <p>Attributes:</p> Name Type Description <code>request_body_prefix</code> <code>str</code> <p>Prefix for request body parameters (default: \"_x_body\")</p> <code>request_query_prefix</code> <code>str</code> <p>Prefix for query parameters (default: \"_x_query\")</p> <code>request_path_prefix</code> <code>str</code> <p>Prefix for path parameters (default: \"_x_path\")</p> <code>request_file_prefix</code> <code>str</code> <p>Prefix for file parameters (default: \"_x_file\")</p> <code>extra_options</code> <code>dict[str, Any]</code> <p>Additional configuration options</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from flask_x_openapi_schema import ConventionalPrefixConfig\n&gt;&gt;&gt; config = ConventionalPrefixConfig(\n...     request_body_prefix=\"req_body\",\n...     request_query_prefix=\"req_query\",\n...     request_path_prefix=\"req_path\",\n...     request_file_prefix=\"req_file\",\n... )\n</code></pre> Source code in <code>src/flask_x_openapi_schema/core/config.py</code> <pre><code>@dataclass(frozen=True)\nclass ConventionalPrefixConfig:\n    \"\"\"Configuration class for OpenAPI parameter prefixes.\n\n    This class holds configuration settings for parameter prefixes used in\n    binding request data to function parameters.\n\n    Attributes:\n        request_body_prefix: Prefix for request body parameters (default: \"_x_body\")\n        request_query_prefix: Prefix for query parameters (default: \"_x_query\")\n        request_path_prefix: Prefix for path parameters (default: \"_x_path\")\n        request_file_prefix: Prefix for file parameters (default: \"_x_file\")\n        extra_options: Additional configuration options\n\n    Examples:\n        &gt;&gt;&gt; from flask_x_openapi_schema import ConventionalPrefixConfig\n        &gt;&gt;&gt; config = ConventionalPrefixConfig(\n        ...     request_body_prefix=\"req_body\",\n        ...     request_query_prefix=\"req_query\",\n        ...     request_path_prefix=\"req_path\",\n        ...     request_file_prefix=\"req_file\",\n        ... )\n\n    \"\"\"\n\n    request_body_prefix: str = DEFAULT_BODY_PREFIX\n    request_query_prefix: str = DEFAULT_QUERY_PREFIX\n    request_path_prefix: str = DEFAULT_PATH_PREFIX\n    request_file_prefix: str = DEFAULT_FILE_PREFIX\n    extra_options: dict[str, Any] = field(default_factory=dict)\n</code></pre>"},{"location":"api/core/#flask_x_openapi_schema.core.config.OpenAPIConfig","title":"<code>OpenAPIConfig</code>  <code>dataclass</code>","text":"<p>Configuration class for OpenAPI schema generation.</p> <p>This class holds configuration settings for OpenAPI schema generation.</p> <p>Attributes:</p> Name Type Description <code>title</code> <code>str</code> <p>API title</p> <code>version</code> <code>str</code> <p>API version</p> <code>description</code> <code>str</code> <p>API description</p> <code>prefix_config</code> <code>ConventionalPrefixConfig</code> <p>Parameter prefix configuration</p> <code>security_schemes</code> <code>dict[str, dict[str, Any]]</code> <p>Security schemes configuration</p> <code>openapi_version</code> <code>str</code> <p>OpenAPI specification version</p> <code>servers</code> <code>list[dict[str, Any]]</code> <p>List of server objects</p> <code>external_docs</code> <code>dict[str, Any] | None</code> <p>External documentation</p> <code>webhooks</code> <code>dict[str, dict[str, Any]]</code> <p>Webhook definitions</p> <code>json_schema_dialect</code> <code>str | None</code> <p>JSON Schema dialect</p> <code>cache_config</code> <code>CacheConfig</code> <p>Configuration for caching behavior</p> Source code in <code>src/flask_x_openapi_schema/core/config.py</code> <pre><code>@dataclass(frozen=True)\nclass OpenAPIConfig:\n    \"\"\"Configuration class for OpenAPI schema generation.\n\n    This class holds configuration settings for OpenAPI schema generation.\n\n    Attributes:\n        title: API title\n        version: API version\n        description: API description\n        prefix_config: Parameter prefix configuration\n        security_schemes: Security schemes configuration\n        openapi_version: OpenAPI specification version\n        servers: List of server objects\n        external_docs: External documentation\n        webhooks: Webhook definitions\n        json_schema_dialect: JSON Schema dialect\n        cache_config: Configuration for caching behavior\n\n    \"\"\"\n\n    title: str = DEFAULT_TITLE\n    version: str = DEFAULT_VERSION\n    description: str = DEFAULT_DESCRIPTION\n    prefix_config: ConventionalPrefixConfig = field(default_factory=ConventionalPrefixConfig)\n    security_schemes: dict[str, dict[str, Any]] = field(default_factory=dict)\n    openapi_version: str = \"3.1.0\"\n    servers: list[dict[str, Any]] = field(default_factory=list)\n    external_docs: dict[str, Any] | None = None\n    webhooks: dict[str, dict[str, Any]] = field(default_factory=dict)\n    json_schema_dialect: str | None = None\n    cache_config: CacheConfig = field(default_factory=CacheConfig)\n</code></pre>"},{"location":"api/core/#flask_x_openapi_schema.core.config.ThreadSafeConfig","title":"<code>ThreadSafeConfig</code>","text":"<p>Thread-safe configuration holder.</p> <p>This class provides thread-safe access to configuration settings.</p> Source code in <code>src/flask_x_openapi_schema/core/config.py</code> <pre><code>class ThreadSafeConfig:\n    \"\"\"Thread-safe configuration holder.\n\n    This class provides thread-safe access to configuration settings.\n    \"\"\"\n\n    def __init__(self) -&gt; None:  # noqa: D107\n        self._prefix_config = ConventionalPrefixConfig()\n        self._openapi_config = OpenAPIConfig()\n        self._cache_config = CacheConfig(enabled=True)\n        self._lock = threading.RLock()\n\n    def get(self) -&gt; ConventionalPrefixConfig:\n        \"\"\"Get the current prefix configuration.\n\n        Returns:\n            ConventionalPrefixConfig: Current prefix configuration\n\n        \"\"\"\n        with self._lock:\n            # Return a copy to prevent modification\n            return ConventionalPrefixConfig(\n                request_body_prefix=self._prefix_config.request_body_prefix,\n                request_query_prefix=self._prefix_config.request_query_prefix,\n                request_path_prefix=self._prefix_config.request_path_prefix,\n                request_file_prefix=self._prefix_config.request_file_prefix,\n                extra_options=dict(self._prefix_config.extra_options),\n            )\n\n    def get_cache_config(self) -&gt; CacheConfig:\n        \"\"\"Get the current cache configuration.\n\n        Returns:\n            CacheConfig: Current cache configuration\n\n        \"\"\"\n        with self._lock:\n            # Return a copy to prevent modification\n            return CacheConfig(\n                enabled=self._cache_config.enabled,\n            )\n\n    def get_openapi_config(self) -&gt; OpenAPIConfig:\n        \"\"\"Get the current OpenAPI configuration.\n\n        Returns:\n            OpenAPIConfig: Current OpenAPI configuration\n\n        \"\"\"\n        with self._lock:\n            # Return a copy to prevent modification\n            return OpenAPIConfig(\n                title=self._openapi_config.title,\n                version=self._openapi_config.version,\n                description=self._openapi_config.description,\n                prefix_config=self.get(),\n                security_schemes=dict(self._openapi_config.security_schemes),\n                openapi_version=self._openapi_config.openapi_version,\n                servers=[dict(server) for server in self._openapi_config.servers]\n                if self._openapi_config.servers\n                else [],\n                external_docs=dict(self._openapi_config.external_docs) if self._openapi_config.external_docs else None,\n                webhooks=dict(self._openapi_config.webhooks) if self._openapi_config.webhooks else {},\n                json_schema_dialect=self._openapi_config.json_schema_dialect,\n                cache_config=self.get_cache_config(),\n            )\n\n    def set(self, config: ConventionalPrefixConfig) -&gt; None:\n        \"\"\"Set a new prefix configuration.\n\n        Args:\n            config: New prefix configuration\n\n        \"\"\"\n        with self._lock:\n            self._prefix_config = ConventionalPrefixConfig(\n                request_body_prefix=config.request_body_prefix,\n                request_query_prefix=config.request_query_prefix,\n                request_path_prefix=config.request_path_prefix,\n                request_file_prefix=config.request_file_prefix,\n                extra_options=dict(config.extra_options),\n            )\n\n    def set_openapi_config(self, config: OpenAPIConfig) -&gt; None:\n        \"\"\"Set a new OpenAPI configuration.\n\n        Args:\n            config: New OpenAPI configuration\n\n        \"\"\"\n        with self._lock:\n            self._openapi_config = OpenAPIConfig(\n                title=config.title,\n                version=config.version,\n                description=config.description,\n                prefix_config=config.prefix_config,\n                security_schemes=dict(config.security_schemes),\n                openapi_version=config.openapi_version,\n                servers=[dict(server) for server in config.servers] if config.servers else [],\n                external_docs=dict(config.external_docs) if config.external_docs else None,\n                webhooks=dict(config.webhooks) if config.webhooks else {},\n                json_schema_dialect=config.json_schema_dialect,\n                cache_config=config.cache_config,\n            )\n            # Also update prefix config\n            self.set(config.prefix_config)\n            # Also update cache config\n            self.set_cache_config(config.cache_config)\n\n    def set_cache_config(self, config: CacheConfig) -&gt; None:\n        \"\"\"Set a new cache configuration.\n\n        Args:\n            config: New cache configuration\n\n        \"\"\"\n        with self._lock:\n            self._cache_config = CacheConfig(\n                enabled=config.enabled,\n            )\n\n    def reset(self) -&gt; None:\n        \"\"\"Reset to default prefix configuration.\n\n        Returns:\n            None\n\n        \"\"\"\n        with self._lock:\n            self._prefix_config = ConventionalPrefixConfig(\n                request_body_prefix=DEFAULT_BODY_PREFIX,\n                request_query_prefix=DEFAULT_QUERY_PREFIX,\n                request_path_prefix=DEFAULT_PATH_PREFIX,\n                request_file_prefix=DEFAULT_FILE_PREFIX,\n                extra_options={},\n            )\n\n    def reset_all(self) -&gt; None:\n        \"\"\"Reset all configurations to defaults.\n\n        Returns:\n            None\n\n        \"\"\"\n        with self._lock:\n            self.reset()\n            self._openapi_config = OpenAPIConfig()\n            self._cache_config = CacheConfig(enabled=True)\n</code></pre>"},{"location":"api/core/#flask_x_openapi_schema.core.config.ThreadSafeConfig.get","title":"<code>get()</code>","text":"<p>Get the current prefix configuration.</p> <p>Returns:</p> Name Type Description <code>ConventionalPrefixConfig</code> <code>ConventionalPrefixConfig</code> <p>Current prefix configuration</p> Source code in <code>src/flask_x_openapi_schema/core/config.py</code> <pre><code>def get(self) -&gt; ConventionalPrefixConfig:\n    \"\"\"Get the current prefix configuration.\n\n    Returns:\n        ConventionalPrefixConfig: Current prefix configuration\n\n    \"\"\"\n    with self._lock:\n        # Return a copy to prevent modification\n        return ConventionalPrefixConfig(\n            request_body_prefix=self._prefix_config.request_body_prefix,\n            request_query_prefix=self._prefix_config.request_query_prefix,\n            request_path_prefix=self._prefix_config.request_path_prefix,\n            request_file_prefix=self._prefix_config.request_file_prefix,\n            extra_options=dict(self._prefix_config.extra_options),\n        )\n</code></pre>"},{"location":"api/core/#flask_x_openapi_schema.core.config.ThreadSafeConfig.get_cache_config","title":"<code>get_cache_config()</code>","text":"<p>Get the current cache configuration.</p> <p>Returns:</p> Name Type Description <code>CacheConfig</code> <code>CacheConfig</code> <p>Current cache configuration</p> Source code in <code>src/flask_x_openapi_schema/core/config.py</code> <pre><code>def get_cache_config(self) -&gt; CacheConfig:\n    \"\"\"Get the current cache configuration.\n\n    Returns:\n        CacheConfig: Current cache configuration\n\n    \"\"\"\n    with self._lock:\n        # Return a copy to prevent modification\n        return CacheConfig(\n            enabled=self._cache_config.enabled,\n        )\n</code></pre>"},{"location":"api/core/#flask_x_openapi_schema.core.config.ThreadSafeConfig.get_openapi_config","title":"<code>get_openapi_config()</code>","text":"<p>Get the current OpenAPI configuration.</p> <p>Returns:</p> Name Type Description <code>OpenAPIConfig</code> <code>OpenAPIConfig</code> <p>Current OpenAPI configuration</p> Source code in <code>src/flask_x_openapi_schema/core/config.py</code> <pre><code>def get_openapi_config(self) -&gt; OpenAPIConfig:\n    \"\"\"Get the current OpenAPI configuration.\n\n    Returns:\n        OpenAPIConfig: Current OpenAPI configuration\n\n    \"\"\"\n    with self._lock:\n        # Return a copy to prevent modification\n        return OpenAPIConfig(\n            title=self._openapi_config.title,\n            version=self._openapi_config.version,\n            description=self._openapi_config.description,\n            prefix_config=self.get(),\n            security_schemes=dict(self._openapi_config.security_schemes),\n            openapi_version=self._openapi_config.openapi_version,\n            servers=[dict(server) for server in self._openapi_config.servers]\n            if self._openapi_config.servers\n            else [],\n            external_docs=dict(self._openapi_config.external_docs) if self._openapi_config.external_docs else None,\n            webhooks=dict(self._openapi_config.webhooks) if self._openapi_config.webhooks else {},\n            json_schema_dialect=self._openapi_config.json_schema_dialect,\n            cache_config=self.get_cache_config(),\n        )\n</code></pre>"},{"location":"api/core/#flask_x_openapi_schema.core.config.ThreadSafeConfig.reset","title":"<code>reset()</code>","text":"<p>Reset to default prefix configuration.</p> <p>Returns:</p> Type Description <code>None</code> <p>None</p> Source code in <code>src/flask_x_openapi_schema/core/config.py</code> <pre><code>def reset(self) -&gt; None:\n    \"\"\"Reset to default prefix configuration.\n\n    Returns:\n        None\n\n    \"\"\"\n    with self._lock:\n        self._prefix_config = ConventionalPrefixConfig(\n            request_body_prefix=DEFAULT_BODY_PREFIX,\n            request_query_prefix=DEFAULT_QUERY_PREFIX,\n            request_path_prefix=DEFAULT_PATH_PREFIX,\n            request_file_prefix=DEFAULT_FILE_PREFIX,\n            extra_options={},\n        )\n</code></pre>"},{"location":"api/core/#flask_x_openapi_schema.core.config.ThreadSafeConfig.reset_all","title":"<code>reset_all()</code>","text":"<p>Reset all configurations to defaults.</p> <p>Returns:</p> Type Description <code>None</code> <p>None</p> Source code in <code>src/flask_x_openapi_schema/core/config.py</code> <pre><code>def reset_all(self) -&gt; None:\n    \"\"\"Reset all configurations to defaults.\n\n    Returns:\n        None\n\n    \"\"\"\n    with self._lock:\n        self.reset()\n        self._openapi_config = OpenAPIConfig()\n        self._cache_config = CacheConfig(enabled=True)\n</code></pre>"},{"location":"api/core/#flask_x_openapi_schema.core.config.ThreadSafeConfig.set","title":"<code>set(config)</code>","text":"<p>Set a new prefix configuration.</p> <p>Parameters:</p> Name Type Description Default <code>config</code> <code>ConventionalPrefixConfig</code> <p>New prefix configuration</p> required Source code in <code>src/flask_x_openapi_schema/core/config.py</code> <pre><code>def set(self, config: ConventionalPrefixConfig) -&gt; None:\n    \"\"\"Set a new prefix configuration.\n\n    Args:\n        config: New prefix configuration\n\n    \"\"\"\n    with self._lock:\n        self._prefix_config = ConventionalPrefixConfig(\n            request_body_prefix=config.request_body_prefix,\n            request_query_prefix=config.request_query_prefix,\n            request_path_prefix=config.request_path_prefix,\n            request_file_prefix=config.request_file_prefix,\n            extra_options=dict(config.extra_options),\n        )\n</code></pre>"},{"location":"api/core/#flask_x_openapi_schema.core.config.ThreadSafeConfig.set_cache_config","title":"<code>set_cache_config(config)</code>","text":"<p>Set a new cache configuration.</p> <p>Parameters:</p> Name Type Description Default <code>config</code> <code>CacheConfig</code> <p>New cache configuration</p> required Source code in <code>src/flask_x_openapi_schema/core/config.py</code> <pre><code>def set_cache_config(self, config: CacheConfig) -&gt; None:\n    \"\"\"Set a new cache configuration.\n\n    Args:\n        config: New cache configuration\n\n    \"\"\"\n    with self._lock:\n        self._cache_config = CacheConfig(\n            enabled=config.enabled,\n        )\n</code></pre>"},{"location":"api/core/#flask_x_openapi_schema.core.config.ThreadSafeConfig.set_openapi_config","title":"<code>set_openapi_config(config)</code>","text":"<p>Set a new OpenAPI configuration.</p> <p>Parameters:</p> Name Type Description Default <code>config</code> <code>OpenAPIConfig</code> <p>New OpenAPI configuration</p> required Source code in <code>src/flask_x_openapi_schema/core/config.py</code> <pre><code>def set_openapi_config(self, config: OpenAPIConfig) -&gt; None:\n    \"\"\"Set a new OpenAPI configuration.\n\n    Args:\n        config: New OpenAPI configuration\n\n    \"\"\"\n    with self._lock:\n        self._openapi_config = OpenAPIConfig(\n            title=config.title,\n            version=config.version,\n            description=config.description,\n            prefix_config=config.prefix_config,\n            security_schemes=dict(config.security_schemes),\n            openapi_version=config.openapi_version,\n            servers=[dict(server) for server in config.servers] if config.servers else [],\n            external_docs=dict(config.external_docs) if config.external_docs else None,\n            webhooks=dict(config.webhooks) if config.webhooks else {},\n            json_schema_dialect=config.json_schema_dialect,\n            cache_config=config.cache_config,\n        )\n        # Also update prefix config\n        self.set(config.prefix_config)\n        # Also update cache config\n        self.set_cache_config(config.cache_config)\n</code></pre>"},{"location":"api/core/#flask_x_openapi_schema.core.config.configure_cache","title":"<code>configure_cache(config)</code>","text":"<p>Configure global cache settings.</p> <p>Parameters:</p> Name Type Description Default <code>config</code> <code>CacheConfig</code> <p>Configuration object with cache settings</p> required <p>Examples:</p> <pre><code>&gt;&gt;&gt; from flask_x_openapi_schema import CacheConfig, configure_cache\n&gt;&gt;&gt; cache_config = CacheConfig(enabled=True)\n&gt;&gt;&gt; configure_cache(cache_config)\n</code></pre> Source code in <code>src/flask_x_openapi_schema/core/config.py</code> <pre><code>def configure_cache(config: CacheConfig) -&gt; None:\n    \"\"\"Configure global cache settings.\n\n    Args:\n        config: Configuration object with cache settings\n\n    Examples:\n        &gt;&gt;&gt; from flask_x_openapi_schema import CacheConfig, configure_cache\n        &gt;&gt;&gt; cache_config = CacheConfig(enabled=True)\n        &gt;&gt;&gt; configure_cache(cache_config)\n\n    \"\"\"\n    # Update the configuration in a thread-safe manner\n    GLOBAL_CONFIG_HOLDER.set_cache_config(config)\n</code></pre>"},{"location":"api/core/#flask_x_openapi_schema.core.config.configure_openapi","title":"<code>configure_openapi(config)</code>","text":"<p>Configure global OpenAPI settings.</p> <p>Parameters:</p> Name Type Description Default <code>config</code> <code>OpenAPIConfig</code> <p>Configuration object with OpenAPI settings</p> required Source code in <code>src/flask_x_openapi_schema/core/config.py</code> <pre><code>def configure_openapi(config: OpenAPIConfig) -&gt; None:\n    \"\"\"Configure global OpenAPI settings.\n\n    Args:\n        config: Configuration object with OpenAPI settings\n\n    \"\"\"\n    # Update the configuration in a thread-safe manner\n    GLOBAL_CONFIG_HOLDER.set_openapi_config(config)\n</code></pre>"},{"location":"api/core/#flask_x_openapi_schema.core.config.configure_prefixes","title":"<code>configure_prefixes(config)</code>","text":"<p>Configure global parameter prefixes.</p> <p>Sets the global configuration for parameter prefixes used in binding request data to function parameters. This affects all decorators that don't specify their own prefix configuration.</p> <p>Parameters:</p> Name Type Description Default <code>config</code> <code>ConventionalPrefixConfig</code> <p>Configuration object with parameter prefixes</p> required <p>Examples:</p> <pre><code>&gt;&gt;&gt; from flask_x_openapi_schema import ConventionalPrefixConfig, configure_prefixes\n&gt;&gt;&gt; custom_config = ConventionalPrefixConfig(request_body_prefix=\"req_body\", request_query_prefix=\"req_query\")\n&gt;&gt;&gt; configure_prefixes(custom_config)\n</code></pre> Source code in <code>src/flask_x_openapi_schema/core/config.py</code> <pre><code>def configure_prefixes(config: ConventionalPrefixConfig) -&gt; None:\n    \"\"\"Configure global parameter prefixes.\n\n    Sets the global configuration for parameter prefixes used in binding request data\n    to function parameters. This affects all decorators that don't specify their own\n    prefix configuration.\n\n    Args:\n        config: Configuration object with parameter prefixes\n\n    Examples:\n        &gt;&gt;&gt; from flask_x_openapi_schema import ConventionalPrefixConfig, configure_prefixes\n        &gt;&gt;&gt; custom_config = ConventionalPrefixConfig(request_body_prefix=\"req_body\", request_query_prefix=\"req_query\")\n        &gt;&gt;&gt; configure_prefixes(custom_config)\n\n    \"\"\"\n    # Update the configuration in a thread-safe manner\n    GLOBAL_CONFIG_HOLDER.set(config)\n</code></pre>"},{"location":"api/core/#flask_x_openapi_schema.core.config.get_cache_config","title":"<code>get_cache_config()</code>","text":"<p>Get the current cache configuration.</p> <p>Returns:</p> Name Type Description <code>CacheConfig</code> <code>CacheConfig</code> <p>Current cache configuration</p> Source code in <code>src/flask_x_openapi_schema/core/config.py</code> <pre><code>def get_cache_config() -&gt; CacheConfig:\n    \"\"\"Get the current cache configuration.\n\n    Returns:\n        CacheConfig: Current cache configuration\n\n    \"\"\"\n    return GLOBAL_CONFIG_HOLDER.get_cache_config()\n</code></pre>"},{"location":"api/core/#flask_x_openapi_schema.core.config.get_openapi_config","title":"<code>get_openapi_config()</code>","text":"<p>Get the current OpenAPI configuration.</p> <p>Returns:</p> Name Type Description <code>OpenAPIConfig</code> <code>OpenAPIConfig</code> <p>Current OpenAPI configuration</p> Source code in <code>src/flask_x_openapi_schema/core/config.py</code> <pre><code>def get_openapi_config() -&gt; OpenAPIConfig:\n    \"\"\"Get the current OpenAPI configuration.\n\n    Returns:\n        OpenAPIConfig: Current OpenAPI configuration\n\n    \"\"\"\n    return GLOBAL_CONFIG_HOLDER.get_openapi_config()\n</code></pre>"},{"location":"api/core/#flask_x_openapi_schema.core.config.reset_all_config","title":"<code>reset_all_config()</code>","text":"<p>Reset all configuration to default values.</p> <p>Resets all configuration settings to their default values, including parameter prefixes, OpenAPI settings, and cache configuration.</p> Source code in <code>src/flask_x_openapi_schema/core/config.py</code> <pre><code>def reset_all_config() -&gt; None:\n    \"\"\"Reset all configuration to default values.\n\n    Resets all configuration settings to their default values, including\n    parameter prefixes, OpenAPI settings, and cache configuration.\n    \"\"\"\n    # Reset the configuration in a thread-safe manner\n    GLOBAL_CONFIG_HOLDER.reset_all()\n</code></pre>"},{"location":"api/core/#flask_x_openapi_schema.core.config.reset_prefixes","title":"<code>reset_prefixes()</code>","text":"<p>Reset parameter prefixes to default values.</p> <p>Resets the global parameter prefix configuration to the default values: - request_body_prefix: \"_x_body\" - request_query_prefix: \"_x_query\" - request_path_prefix: \"_x_path\" - request_file_prefix: \"_x_file\"</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from flask_x_openapi_schema import reset_prefixes\n&gt;&gt;&gt; reset_prefixes()  # Resets to default prefixes\n</code></pre> Source code in <code>src/flask_x_openapi_schema/core/config.py</code> <pre><code>def reset_prefixes() -&gt; None:\n    \"\"\"Reset parameter prefixes to default values.\n\n    Resets the global parameter prefix configuration to the default values:\n    - request_body_prefix: \"_x_body\"\n    - request_query_prefix: \"_x_query\"\n    - request_path_prefix: \"_x_path\"\n    - request_file_prefix: \"_x_file\"\n\n    Examples:\n        &gt;&gt;&gt; from flask_x_openapi_schema import reset_prefixes\n        &gt;&gt;&gt; reset_prefixes()  # Resets to default prefixes\n\n    \"\"\"\n    # Reset the configuration in a thread-safe manner\n    GLOBAL_CONFIG_HOLDER.reset()\n</code></pre>"},{"location":"api/core/#cache","title":"Cache","text":"<p>Simplified caching mechanism for OpenAPI schema generation.</p> <p>This module provides a minimal caching system focused only on the essential caching needs for the @openapi_metadata decorator. It uses WeakKeyDictionary to avoid memory leaks when functions are garbage collected.</p> Cache Types <ul> <li>WeakKeyDictionary: For function metadata to avoid memory leaks</li> </ul> Thread Safety <p>This module is designed to be thread-safe for use in multi-threaded web servers.</p>"},{"location":"api/core/#flask_x_openapi_schema.core.cache.clear_all_caches","title":"<code>clear_all_caches()</code>","text":"<p>Clear all caches to free memory or force regeneration.</p> <p>This function clears the function metadata cache.</p> Source code in <code>src/flask_x_openapi_schema/core/cache.py</code> <pre><code>def clear_all_caches() -&gt; None:\n    \"\"\"Clear all caches to free memory or force regeneration.\n\n    This function clears the function metadata cache.\n    \"\"\"\n    FUNCTION_METADATA_CACHE.clear()\n</code></pre>"},{"location":"api/core/#flask_x_openapi_schema.core.cache.get_parameter_prefixes","title":"<code>get_parameter_prefixes(config=None)</code>","text":"<p>Get parameter prefixes from config or global defaults.</p> <p>This function retrieves parameter prefixes from the provided config or global defaults.</p> <p>Parameters:</p> Name Type Description Default <code>config</code> <code>Any | None</code> <p>Optional configuration object with custom prefixes</p> <code>None</code> <p>Returns:</p> Type Description <code>tuple[str, str, str, str]</code> <p>Tuple of (body_prefix, query_prefix, path_prefix, file_prefix)</p> Source code in <code>src/flask_x_openapi_schema/core/cache.py</code> <pre><code>def get_parameter_prefixes(config: Any | None = None) -&gt; tuple[str, str, str, str]:\n    \"\"\"Get parameter prefixes from config or global defaults.\n\n    This function retrieves parameter prefixes from the provided config or global defaults.\n\n    Args:\n        config: Optional configuration object with custom prefixes\n\n    Returns:\n        Tuple of (body_prefix, query_prefix, path_prefix, file_prefix)\n\n    \"\"\"\n    from .config import GLOBAL_CONFIG_HOLDER\n\n    # If config is None, use global config\n    prefix_config = GLOBAL_CONFIG_HOLDER.get() if config is None else config\n\n    # Extract the prefixes directly\n    return (\n        prefix_config.request_body_prefix,\n        prefix_config.request_query_prefix,\n        prefix_config.request_path_prefix,\n        prefix_config.request_file_prefix,\n    )\n</code></pre>"},{"location":"api/core/#decorator-base","title":"Decorator Base","text":"<p>Base classes and utilities for OpenAPI metadata decorators.</p> <p>This module provides the core functionality for creating OpenAPI metadata decorators that can be used with Flask and Flask-RESTful applications. It includes utilities for parameter extraction, metadata generation, and request processing.</p> <p>The main classes are: - OpenAPIDecoratorBase: Serves as the foundation for framework-specific decorator implementations.   It handles parameter binding, metadata caching, and OpenAPI schema generation. - DecoratorBase: A base class for framework-specific decorators that encapsulates common   functionality for processing request bodies, query parameters, and path parameters.</p>"},{"location":"api/core/#flask_x_openapi_schema.core.decorator_base.DecoratorBase","title":"<code>DecoratorBase</code>","text":"<p>               Bases: <code>ABC</code></p> <p>Base class for framework-specific decorators.</p> <p>This class encapsulates common functionality for processing request bodies, query parameters, and path parameters. It is designed to be inherited by framework-specific decorator implementations.</p> <p>Attributes:</p> Name Type Description <code>summary</code> <code>str or I18nStr</code> <p>Short summary of the endpoint.</p> <code>description</code> <code>str or I18nStr</code> <p>Detailed description of the endpoint.</p> <code>tags</code> <code>list</code> <p>List of tags to categorize the endpoint.</p> <code>operation_id</code> <code>str</code> <p>Unique identifier for the operation.</p> <code>responses</code> <code>OpenAPIMetaResponse</code> <p>Response models configuration.</p> <code>deprecated</code> <code>bool</code> <p>Whether the endpoint is deprecated.</p> <code>security</code> <code>list</code> <p>Security requirements for the endpoint.</p> <code>external_docs</code> <code>dict</code> <p>External documentation references.</p> <code>language</code> <code>str</code> <p>Language code to use for I18nStr values.</p> <code>prefix_config</code> <code>ConventionalPrefixConfig</code> <p>Configuration for parameter prefixes.</p> <code>content_type</code> <code>str</code> <p>Custom content type for request body.</p> <code>request_content_types</code> <code>RequestContentTypes</code> <p>Multiple content types for request body.</p> <code>response_content_types</code> <code>ResponseContentTypes</code> <p>Multiple content types for response body.</p> <code>content_type_resolver</code> <code>Callable</code> <p>Function to determine content type based on request.</p> <code>default_error_response</code> <code>Type[BaseErrorResponse]</code> <p>Default error response class.</p> Source code in <code>src/flask_x_openapi_schema/core/decorator_base.py</code> <pre><code>class DecoratorBase(ABC):\n    \"\"\"Base class for framework-specific decorators.\n\n    This class encapsulates common functionality for processing request bodies,\n    query parameters, and path parameters. It is designed to be inherited by\n    framework-specific decorator implementations.\n\n    Attributes:\n        summary (str or I18nStr): Short summary of the endpoint.\n        description (str or I18nStr): Detailed description of the endpoint.\n        tags (list): List of tags to categorize the endpoint.\n        operation_id (str): Unique identifier for the operation.\n        responses (OpenAPIMetaResponse): Response models configuration.\n        deprecated (bool): Whether the endpoint is deprecated.\n        security (list): Security requirements for the endpoint.\n        external_docs (dict): External documentation references.\n        language (str): Language code to use for I18nStr values.\n        prefix_config (ConventionalPrefixConfig): Configuration for parameter prefixes.\n        content_type (str): Custom content type for request body.\n        request_content_types (RequestContentTypes): Multiple content types for request body.\n        response_content_types (ResponseContentTypes): Multiple content types for response body.\n        content_type_resolver (Callable): Function to determine content type based on request.\n        default_error_response (Type[BaseErrorResponse]): Default error response class.\n\n    \"\"\"\n\n    def __init__(\n        self,\n        summary: str | I18nStr | None = None,\n        description: str | I18nStr | None = None,\n        tags: list[str] | None = None,\n        operation_id: str | None = None,\n        responses: OpenAPIMetaResponse | None = None,\n        deprecated: bool = False,\n        security: list[dict[str, list[str]]] | None = None,\n        external_docs: dict[str, str] | None = None,\n        language: str | None = None,\n        prefix_config: ConventionalPrefixConfig | None = None,\n        content_type: str | None = None,\n        request_content_types: RequestContentTypes | None = None,\n        response_content_types: ResponseContentTypes | None = None,\n        content_type_resolver: Callable[[Any], str] | None = None,\n    ) -&gt; None:\n        \"\"\"Initialize the decorator with OpenAPI metadata parameters.\n\n        Args:\n            summary: Short summary of the endpoint, can be an I18nStr for localization.\n            description: Detailed description of the endpoint, can be an I18nStr.\n            tags: List of tags to categorize the endpoint.\n            operation_id: Unique identifier for the operation.\n            responses: Response models configuration.\n            deprecated: Whether the endpoint is deprecated. Defaults to False.\n            security: Security requirements for the endpoint.\n            external_docs: External documentation references.\n            language: Language code to use for I18nStr values.\n            prefix_config: Configuration for parameter prefixes.\n            content_type: Custom content type for request body. If None, will be auto-detected.\n            request_content_types: Multiple content types for request body.\n            response_content_types: Multiple content types for response body.\n            content_type_resolver: Function to determine content type based on request.\n\n        \"\"\"\n        self.summary = summary\n        self.description = description\n        self.tags = tags\n        self.operation_id = operation_id\n        self.responses = responses\n        self.deprecated = deprecated\n        self.security = security\n        self.external_docs = external_docs\n        self.language = language\n        self.prefix_config = prefix_config\n        self.content_type = content_type\n        self.request_content_types = request_content_types\n        self.response_content_types = response_content_types\n        self.content_type_resolver = content_type_resolver\n        self.default_error_response = responses.default_error_response if responses else BaseErrorResponse\n\n        # Initialize content type processor\n        self.content_type_processor = ContentTypeProcessor(\n            content_type=content_type,\n            request_content_types=request_content_types,\n            content_type_resolver=content_type_resolver,\n            default_error_response=self.default_error_response,\n        )\n\n    @abstractmethod\n    def __call__(self, func: Callable) -&gt; Callable:\n        \"\"\"Apply the decorator to the function.\n\n        Args:\n            func: The function to decorate\n\n        Returns:\n            The decorated function\n\n        \"\"\"\n        # This method should be implemented by subclasses\n        msg = \"Subclasses must implement __call__\"\n        raise NotImplementedError(msg)\n\n    def extract_parameters_from_models(\n        self,\n        query_model: type[BaseModel] | None,\n        path_params: list[str] | None,\n    ) -&gt; list[dict[str, Any]]:\n        \"\"\"Extract OpenAPI parameters from models.\n\n        Args:\n            query_model: The query parameter model\n            path_params: List of path parameter names\n\n        Returns:\n            List of OpenAPI parameter objects\n\n        \"\"\"\n        parameters = []\n\n        if path_params:\n            parameters.extend(\n                [\n                    {\n                        \"name\": param,\n                        \"in\": \"path\",\n                        \"required\": True,\n                        \"schema\": {\"type\": \"string\"},\n                    }\n                    for param in path_params\n                ]\n            )\n\n        if query_model:\n            schema = query_model.model_json_schema()\n            properties = schema.get(\"properties\", {})\n            required = schema.get(\"required\", [])\n\n            for field_name, field_schema in properties.items():\n                fixed_schema = _fix_references(field_schema)\n                param = {\n                    \"name\": field_name,\n                    \"in\": \"query\",\n                    \"required\": field_name in required,\n                    \"schema\": fixed_schema,\n                }\n\n                if \"description\" in field_schema:\n                    param[\"description\"] = field_schema[\"description\"]\n\n                parameters.append(param)\n\n        return parameters\n\n    def process_request_body(self, param_name: str, model: type[BaseModel], kwargs: dict[str, Any]) -&gt; dict[str, Any]:\n        \"\"\"Process request body parameters.\n\n        Args:\n            param_name: The parameter name to bind the model instance to\n            model: The Pydantic model class to use for validation\n            kwargs: The keyword arguments to update\n\n        Returns:\n            Updated kwargs dictionary with the model instance\n\n        \"\"\"\n        return self.content_type_processor.process_request_body(request, model, param_name, kwargs)\n\n    @abstractmethod\n    def process_query_params(self, param_name: str, model: type[BaseModel], kwargs: dict[str, Any]) -&gt; dict[str, Any]:\n        \"\"\"Process query parameters.\n\n        Args:\n            param_name: The parameter name to bind the model instance to\n            model: The Pydantic model class to use for validation\n            kwargs: The keyword arguments to update\n\n        Returns:\n            Updated kwargs dictionary with the model instance\n\n        \"\"\"\n        # This method should be implemented by subclasses\n        msg = \"Subclasses must implement process_query_params\"\n        raise NotImplementedError(msg)\n\n    def process_additional_params(self, kwargs: dict[str, Any], param_names: list[str]) -&gt; dict[str, Any]:  # noqa: ARG002\n        \"\"\"Process additional framework-specific parameters.\n\n        Args:\n            kwargs: The keyword arguments to update\n            param_names: List of parameter names that have been processed\n\n        Returns:\n            Updated kwargs dictionary\n\n        \"\"\"\n        # This method should be implemented by subclasses\n        return kwargs\n</code></pre>"},{"location":"api/core/#flask_x_openapi_schema.core.decorator_base.DecoratorBase.__call__","title":"<code>__call__(func)</code>  <code>abstractmethod</code>","text":"<p>Apply the decorator to the function.</p> <p>Parameters:</p> Name Type Description Default <code>func</code> <code>Callable</code> <p>The function to decorate</p> required <p>Returns:</p> Type Description <code>Callable</code> <p>The decorated function</p> Source code in <code>src/flask_x_openapi_schema/core/decorator_base.py</code> <pre><code>@abstractmethod\ndef __call__(self, func: Callable) -&gt; Callable:\n    \"\"\"Apply the decorator to the function.\n\n    Args:\n        func: The function to decorate\n\n    Returns:\n        The decorated function\n\n    \"\"\"\n    # This method should be implemented by subclasses\n    msg = \"Subclasses must implement __call__\"\n    raise NotImplementedError(msg)\n</code></pre>"},{"location":"api/core/#flask_x_openapi_schema.core.decorator_base.DecoratorBase.__init__","title":"<code>__init__(summary=None, description=None, tags=None, operation_id=None, responses=None, deprecated=False, security=None, external_docs=None, language=None, prefix_config=None, content_type=None, request_content_types=None, response_content_types=None, content_type_resolver=None)</code>","text":"<p>Initialize the decorator with OpenAPI metadata parameters.</p> <p>Parameters:</p> Name Type Description Default <code>summary</code> <code>str | I18nStr | None</code> <p>Short summary of the endpoint, can be an I18nStr for localization.</p> <code>None</code> <code>description</code> <code>str | I18nStr | None</code> <p>Detailed description of the endpoint, can be an I18nStr.</p> <code>None</code> <code>tags</code> <code>list[str] | None</code> <p>List of tags to categorize the endpoint.</p> <code>None</code> <code>operation_id</code> <code>str | None</code> <p>Unique identifier for the operation.</p> <code>None</code> <code>responses</code> <code>OpenAPIMetaResponse | None</code> <p>Response models configuration.</p> <code>None</code> <code>deprecated</code> <code>bool</code> <p>Whether the endpoint is deprecated. Defaults to False.</p> <code>False</code> <code>security</code> <code>list[dict[str, list[str]]] | None</code> <p>Security requirements for the endpoint.</p> <code>None</code> <code>external_docs</code> <code>dict[str, str] | None</code> <p>External documentation references.</p> <code>None</code> <code>language</code> <code>str | None</code> <p>Language code to use for I18nStr values.</p> <code>None</code> <code>prefix_config</code> <code>ConventionalPrefixConfig | None</code> <p>Configuration for parameter prefixes.</p> <code>None</code> <code>content_type</code> <code>str | None</code> <p>Custom content type for request body. If None, will be auto-detected.</p> <code>None</code> <code>request_content_types</code> <code>RequestContentTypes | None</code> <p>Multiple content types for request body.</p> <code>None</code> <code>response_content_types</code> <code>ResponseContentTypes | None</code> <p>Multiple content types for response body.</p> <code>None</code> <code>content_type_resolver</code> <code>Callable[[Any], str] | None</code> <p>Function to determine content type based on request.</p> <code>None</code> Source code in <code>src/flask_x_openapi_schema/core/decorator_base.py</code> <pre><code>def __init__(\n    self,\n    summary: str | I18nStr | None = None,\n    description: str | I18nStr | None = None,\n    tags: list[str] | None = None,\n    operation_id: str | None = None,\n    responses: OpenAPIMetaResponse | None = None,\n    deprecated: bool = False,\n    security: list[dict[str, list[str]]] | None = None,\n    external_docs: dict[str, str] | None = None,\n    language: str | None = None,\n    prefix_config: ConventionalPrefixConfig | None = None,\n    content_type: str | None = None,\n    request_content_types: RequestContentTypes | None = None,\n    response_content_types: ResponseContentTypes | None = None,\n    content_type_resolver: Callable[[Any], str] | None = None,\n) -&gt; None:\n    \"\"\"Initialize the decorator with OpenAPI metadata parameters.\n\n    Args:\n        summary: Short summary of the endpoint, can be an I18nStr for localization.\n        description: Detailed description of the endpoint, can be an I18nStr.\n        tags: List of tags to categorize the endpoint.\n        operation_id: Unique identifier for the operation.\n        responses: Response models configuration.\n        deprecated: Whether the endpoint is deprecated. Defaults to False.\n        security: Security requirements for the endpoint.\n        external_docs: External documentation references.\n        language: Language code to use for I18nStr values.\n        prefix_config: Configuration for parameter prefixes.\n        content_type: Custom content type for request body. If None, will be auto-detected.\n        request_content_types: Multiple content types for request body.\n        response_content_types: Multiple content types for response body.\n        content_type_resolver: Function to determine content type based on request.\n\n    \"\"\"\n    self.summary = summary\n    self.description = description\n    self.tags = tags\n    self.operation_id = operation_id\n    self.responses = responses\n    self.deprecated = deprecated\n    self.security = security\n    self.external_docs = external_docs\n    self.language = language\n    self.prefix_config = prefix_config\n    self.content_type = content_type\n    self.request_content_types = request_content_types\n    self.response_content_types = response_content_types\n    self.content_type_resolver = content_type_resolver\n    self.default_error_response = responses.default_error_response if responses else BaseErrorResponse\n\n    # Initialize content type processor\n    self.content_type_processor = ContentTypeProcessor(\n        content_type=content_type,\n        request_content_types=request_content_types,\n        content_type_resolver=content_type_resolver,\n        default_error_response=self.default_error_response,\n    )\n</code></pre>"},{"location":"api/core/#flask_x_openapi_schema.core.decorator_base.DecoratorBase.extract_parameters_from_models","title":"<code>extract_parameters_from_models(query_model, path_params)</code>","text":"<p>Extract OpenAPI parameters from models.</p> <p>Parameters:</p> Name Type Description Default <code>query_model</code> <code>type[BaseModel] | None</code> <p>The query parameter model</p> required <code>path_params</code> <code>list[str] | None</code> <p>List of path parameter names</p> required <p>Returns:</p> Type Description <code>list[dict[str, Any]]</code> <p>List of OpenAPI parameter objects</p> Source code in <code>src/flask_x_openapi_schema/core/decorator_base.py</code> <pre><code>def extract_parameters_from_models(\n    self,\n    query_model: type[BaseModel] | None,\n    path_params: list[str] | None,\n) -&gt; list[dict[str, Any]]:\n    \"\"\"Extract OpenAPI parameters from models.\n\n    Args:\n        query_model: The query parameter model\n        path_params: List of path parameter names\n\n    Returns:\n        List of OpenAPI parameter objects\n\n    \"\"\"\n    parameters = []\n\n    if path_params:\n        parameters.extend(\n            [\n                {\n                    \"name\": param,\n                    \"in\": \"path\",\n                    \"required\": True,\n                    \"schema\": {\"type\": \"string\"},\n                }\n                for param in path_params\n            ]\n        )\n\n    if query_model:\n        schema = query_model.model_json_schema()\n        properties = schema.get(\"properties\", {})\n        required = schema.get(\"required\", [])\n\n        for field_name, field_schema in properties.items():\n            fixed_schema = _fix_references(field_schema)\n            param = {\n                \"name\": field_name,\n                \"in\": \"query\",\n                \"required\": field_name in required,\n                \"schema\": fixed_schema,\n            }\n\n            if \"description\" in field_schema:\n                param[\"description\"] = field_schema[\"description\"]\n\n            parameters.append(param)\n\n    return parameters\n</code></pre>"},{"location":"api/core/#flask_x_openapi_schema.core.decorator_base.DecoratorBase.process_additional_params","title":"<code>process_additional_params(kwargs, param_names)</code>","text":"<p>Process additional framework-specific parameters.</p> <p>Parameters:</p> Name Type Description Default <code>kwargs</code> <code>dict[str, Any]</code> <p>The keyword arguments to update</p> required <code>param_names</code> <code>list[str]</code> <p>List of parameter names that have been processed</p> required <p>Returns:</p> Type Description <code>dict[str, Any]</code> <p>Updated kwargs dictionary</p> Source code in <code>src/flask_x_openapi_schema/core/decorator_base.py</code> <pre><code>def process_additional_params(self, kwargs: dict[str, Any], param_names: list[str]) -&gt; dict[str, Any]:  # noqa: ARG002\n    \"\"\"Process additional framework-specific parameters.\n\n    Args:\n        kwargs: The keyword arguments to update\n        param_names: List of parameter names that have been processed\n\n    Returns:\n        Updated kwargs dictionary\n\n    \"\"\"\n    # This method should be implemented by subclasses\n    return kwargs\n</code></pre>"},{"location":"api/core/#flask_x_openapi_schema.core.decorator_base.DecoratorBase.process_query_params","title":"<code>process_query_params(param_name, model, kwargs)</code>  <code>abstractmethod</code>","text":"<p>Process query parameters.</p> <p>Parameters:</p> Name Type Description Default <code>param_name</code> <code>str</code> <p>The parameter name to bind the model instance to</p> required <code>model</code> <code>type[BaseModel]</code> <p>The Pydantic model class to use for validation</p> required <code>kwargs</code> <code>dict[str, Any]</code> <p>The keyword arguments to update</p> required <p>Returns:</p> Type Description <code>dict[str, Any]</code> <p>Updated kwargs dictionary with the model instance</p> Source code in <code>src/flask_x_openapi_schema/core/decorator_base.py</code> <pre><code>@abstractmethod\ndef process_query_params(self, param_name: str, model: type[BaseModel], kwargs: dict[str, Any]) -&gt; dict[str, Any]:\n    \"\"\"Process query parameters.\n\n    Args:\n        param_name: The parameter name to bind the model instance to\n        model: The Pydantic model class to use for validation\n        kwargs: The keyword arguments to update\n\n    Returns:\n        Updated kwargs dictionary with the model instance\n\n    \"\"\"\n    # This method should be implemented by subclasses\n    msg = \"Subclasses must implement process_query_params\"\n    raise NotImplementedError(msg)\n</code></pre>"},{"location":"api/core/#flask_x_openapi_schema.core.decorator_base.DecoratorBase.process_request_body","title":"<code>process_request_body(param_name, model, kwargs)</code>","text":"<p>Process request body parameters.</p> <p>Parameters:</p> Name Type Description Default <code>param_name</code> <code>str</code> <p>The parameter name to bind the model instance to</p> required <code>model</code> <code>type[BaseModel]</code> <p>The Pydantic model class to use for validation</p> required <code>kwargs</code> <code>dict[str, Any]</code> <p>The keyword arguments to update</p> required <p>Returns:</p> Type Description <code>dict[str, Any]</code> <p>Updated kwargs dictionary with the model instance</p> Source code in <code>src/flask_x_openapi_schema/core/decorator_base.py</code> <pre><code>def process_request_body(self, param_name: str, model: type[BaseModel], kwargs: dict[str, Any]) -&gt; dict[str, Any]:\n    \"\"\"Process request body parameters.\n\n    Args:\n        param_name: The parameter name to bind the model instance to\n        model: The Pydantic model class to use for validation\n        kwargs: The keyword arguments to update\n\n    Returns:\n        Updated kwargs dictionary with the model instance\n\n    \"\"\"\n    return self.content_type_processor.process_request_body(request, model, param_name, kwargs)\n</code></pre>"},{"location":"api/core/#flask_x_openapi_schema.core.decorator_base.OpenAPIDecoratorBase","title":"<code>OpenAPIDecoratorBase</code>","text":"<p>Base class for OpenAPI metadata decorators.</p> <p>This class provides the foundation for framework-specific OpenAPI metadata decorators. It handles parameter extraction, metadata generation, and request processing in a framework-agnostic way, delegating framework-specific operations to subclasses.</p> <p>The decorator adds OpenAPI metadata to API endpoint functions and handles parameter binding between HTTP requests and function parameters based on naming conventions.</p> <p>Attributes:</p> Name Type Description <code>summary</code> <code>str or I18nStr</code> <p>Short summary of the endpoint.</p> <code>description</code> <code>str or I18nStr</code> <p>Detailed description of the endpoint.</p> <code>tags</code> <code>list</code> <p>List of tags to categorize the endpoint.</p> <code>operation_id</code> <code>str</code> <p>Unique identifier for the operation.</p> <code>responses</code> <code>OpenAPIMetaResponse</code> <p>Response models configuration.</p> <code>deprecated</code> <code>bool</code> <p>Whether the endpoint is deprecated.</p> <code>security</code> <code>list</code> <p>Security requirements for the endpoint.</p> <code>external_docs</code> <code>dict</code> <p>External documentation references.</p> <code>language</code> <code>str</code> <p>Language code to use for I18nStr values.</p> <code>prefix_config</code> <code>ConventionalPrefixConfig</code> <p>Configuration for parameter prefixes.</p> <code>framework</code> <code>str</code> <p>Framework name ('flask' or 'flask_restful').</p> <code>framework_decorator</code> <p>Framework-specific decorator instance.</p> Source code in <code>src/flask_x_openapi_schema/core/decorator_base.py</code> <pre><code>class OpenAPIDecoratorBase:\n    \"\"\"Base class for OpenAPI metadata decorators.\n\n    This class provides the foundation for framework-specific OpenAPI metadata decorators.\n    It handles parameter extraction, metadata generation, and request processing in a\n    framework-agnostic way, delegating framework-specific operations to subclasses.\n\n    The decorator adds OpenAPI metadata to API endpoint functions and handles parameter\n    binding between HTTP requests and function parameters based on naming conventions.\n\n    Attributes:\n        summary (str or I18nStr): Short summary of the endpoint.\n        description (str or I18nStr): Detailed description of the endpoint.\n        tags (list): List of tags to categorize the endpoint.\n        operation_id (str): Unique identifier for the operation.\n        responses (OpenAPIMetaResponse): Response models configuration.\n        deprecated (bool): Whether the endpoint is deprecated.\n        security (list): Security requirements for the endpoint.\n        external_docs (dict): External documentation references.\n        language (str): Language code to use for I18nStr values.\n        prefix_config (ConventionalPrefixConfig): Configuration for parameter prefixes.\n        framework (str): Framework name ('flask' or 'flask_restful').\n        framework_decorator: Framework-specific decorator instance.\n\n    \"\"\"\n\n    def __init__(\n        self,\n        summary: str | I18nStr | None = None,\n        description: str | I18nStr | None = None,\n        tags: list[str] | None = None,\n        operation_id: str | None = None,\n        responses: OpenAPIMetaResponse | None = None,\n        deprecated: bool = False,\n        security: list[dict[str, list[str]]] | None = None,\n        external_docs: dict[str, str] | None = None,\n        language: str | None = None,\n        prefix_config: ConventionalPrefixConfig | None = None,\n        framework: str = \"flask\",\n        content_type: str | None = None,\n        request_content_types: RequestContentTypes | None = None,\n        response_content_types: ResponseContentTypes | None = None,\n        content_type_resolver: Callable[[Any], str] | None = None,\n    ) -&gt; None:\n        \"\"\"Initialize the decorator with OpenAPI metadata parameters.\n\n        Args:\n            summary: Short summary of the endpoint, can be an I18nStr for localization.\n            description: Detailed description of the endpoint, can be an I18nStr.\n            tags: List of tags to categorize the endpoint.\n            operation_id: Unique identifier for the operation.\n            responses: Response models configuration.\n            deprecated: Whether the endpoint is deprecated. Defaults to False.\n            security: Security requirements for the endpoint.\n            external_docs: External documentation references.\n            language: Language code to use for I18nStr values.\n            prefix_config: Configuration for parameter prefixes.\n            framework: Framework name ('flask' or 'flask_restful'). Defaults to \"flask\".\n            content_type: Custom content type for request body. If None, will be auto-detected.\n            request_content_types: Multiple content types for request body.\n            response_content_types: Multiple content types for response body.\n            content_type_resolver: Function to determine content type based on request.\n\n\n        \"\"\"\n        self.summary = summary\n        self.description = description\n        self.tags = tags\n        self.operation_id = operation_id\n        self.responses = responses\n        self.deprecated = deprecated\n        self.security = security\n        self.external_docs = external_docs\n        self.language = language\n        self.prefix_config = prefix_config\n        self.framework = framework\n        self.content_type = content_type\n        self.request_content_types = request_content_types\n        self.response_content_types = response_content_types\n        self.content_type_resolver = content_type_resolver\n        self.default_error_response = responses.default_error_response if responses else BaseErrorResponse\n\n        self.framework_decorator = None\n\n    def _initialize_framework_decorator(self) -&gt; None:\n        \"\"\"Initialize the framework-specific decorator.\n\n        This method uses lazy loading to avoid circular imports. It creates the appropriate\n        framework-specific decorator based on the 'framework' attribute.\n\n        Raises:\n            ValueError: If an unsupported framework is specified.\n\n        \"\"\"\n        if self.framework_decorator is None:\n            if self.framework == \"flask\":\n                from flask_x_openapi_schema.x.flask.decorators import FlaskOpenAPIDecorator\n\n                self.framework_decorator = FlaskOpenAPIDecorator(\n                    summary=self.summary,\n                    description=self.description,\n                    tags=self.tags,\n                    operation_id=self.operation_id,\n                    responses=self.responses,\n                    deprecated=self.deprecated,\n                    security=self.security,\n                    external_docs=self.external_docs,\n                    language=self.language,\n                    prefix_config=self.prefix_config,\n                    content_type=self.content_type,\n                    request_content_types=self.request_content_types,\n                    response_content_types=self.response_content_types,\n                    content_type_resolver=self.content_type_resolver,\n                )\n            elif self.framework == \"flask_restful\":\n                from flask_x_openapi_schema.x.flask_restful.decorators import FlaskRestfulOpenAPIDecorator\n\n                self.framework_decorator = FlaskRestfulOpenAPIDecorator(\n                    summary=self.summary,\n                    description=self.description,\n                    tags=self.tags,\n                    operation_id=self.operation_id,\n                    responses=self.responses,\n                    deprecated=self.deprecated,\n                    security=self.security,\n                    external_docs=self.external_docs,\n                    language=self.language,\n                    prefix_config=self.prefix_config,\n                    content_type=self.content_type,\n                    request_content_types=self.request_content_types,\n                    response_content_types=self.response_content_types,\n                    content_type_resolver=self.content_type_resolver,\n                )\n            else:\n                msg = f\"Unsupported framework: {self.framework}\"\n                raise ValueError(msg)\n\n    def _create_cached_wrapper(self, func: Callable[P, R], cached_data: dict[str, Any]) -&gt; Callable[P, R]:\n        \"\"\"Create a wrapper function that reuses cached metadata.\n\n        Args:\n            func: The decorated function\n            cached_data: Cached metadata and other information\n\n        Returns:\n            A wrapper function that reuses cached metadata\n\n        \"\"\"\n        logger.debug(f\"Using cached metadata for function {func.__name__}\")\n        logger.debug(f\"Cached metadata: {cached_data['metadata']}\")\n\n        @wraps(func)\n        def cached_wrapper(*args, **kwargs) -&gt; Any:\n            signature = cached_data[\"signature\"]\n            param_names = cached_data[\"param_names\"]\n\n            for param_name in param_names:\n                if param_name not in kwargs and param_name in signature.parameters:\n                    param = signature.parameters[param_name]\n                    if param.default is param.empty and param_name in cached_data[\"type_hints\"]:\n                        param_type = cached_data[\"type_hints\"][param_name]\n                        if isinstance(param_type, type) and issubclass(param_type, BaseModel):\n                            kwargs[param_name] = param_type()\n\n            return self._process_request(func, cached_data, *args, **kwargs)\n\n        cached_wrapper._openapi_metadata = cached_data[\"metadata\"]\n        cached_wrapper.__annotations__ = cached_data[\"annotations\"]\n\n        return cast(\"Callable[P, R]\", cached_wrapper)\n\n    def _extract_parameters(\n        self, signature: inspect.Signature, type_hints: dict[str, Any]\n    ) -&gt; tuple[type[BaseModel] | None, type[BaseModel] | None, list[str]]:\n        \"\"\"Extract parameters from function signature.\n\n        Args:\n            signature: Function signature\n            type_hints: Function type hints\n\n        Returns:\n            Tuple of (request_body, query_model, path_params)\n\n        \"\"\"\n        return _extract_parameters_from_prefixes(\n            signature,\n            type_hints,\n            self.prefix_config,\n        )\n\n    def _generate_metadata_cache_key(\n        self,\n        actual_request_body: type[BaseModel] | dict[str, Any] | None,\n        actual_query_model: type[BaseModel] | None,\n        actual_path_params: list[str],\n    ) -&gt; tuple:\n        \"\"\"Generate a cache key for metadata.\n\n        Args:\n            actual_request_body: Request body model or dict\n            actual_query_model: Query parameters model\n            actual_path_params: Path parameters\n\n        Returns:\n            A cache key for metadata\n\n        \"\"\"\n        return (\n            str(self.summary),\n            str(self.description),\n            str(self.tags) if self.tags else None,\n            self.operation_id,\n            self.deprecated,\n            str(self.security) if self.security else None,\n            str(self.external_docs) if self.external_docs else None,\n            id(actual_request_body) if isinstance(actual_request_body, type) else str(actual_request_body),\n            str(self.responses) if self.responses else None,\n            id(actual_query_model) if actual_query_model else None,\n            str(actual_path_params) if actual_path_params else None,\n            self.language,\n        )\n\n    def _get_or_generate_metadata(\n        self,\n        cache_key: tuple,  # noqa: ARG002\n        actual_request_body: type[BaseModel] | dict[str, Any] | None,\n    ) -&gt; dict[str, Any]:\n        \"\"\"Generate OpenAPI metadata for an endpoint.\n\n        This method delegates to the module-level _generate_openapi_metadata function\n        using the decorator's attributes.\n\n        Args:\n            cache_key: Cache key for metadata (not used now).\n            actual_request_body: Request body model or dict.\n\n        Returns:\n            dict: OpenAPI metadata dictionary ready to be included in the schema.\n\n        \"\"\"\n        return _generate_openapi_metadata(\n            summary=self.summary,\n            description=self.description,\n            tags=self.tags,\n            operation_id=self.operation_id,\n            deprecated=self.deprecated,\n            security=self.security,\n            external_docs=self.external_docs,\n            actual_request_body=actual_request_body,\n            responses=self.responses,\n            language=self.language,\n            content_type=self.content_type,\n            request_content_types=self.request_content_types,\n            response_content_types=self.response_content_types,\n        )\n\n    def _generate_openapi_parameters(\n        self,\n        actual_query_model: type[BaseModel] | None,\n        actual_path_params: list[str],\n        param_names: list[str],\n        func_annotations: dict[str, Any],\n    ) -&gt; list[dict[str, Any]]:\n        \"\"\"Generate OpenAPI parameters.\n\n        This method generates OpenAPI parameters from query models, path parameters,\n        and file parameters. It uses caching to avoid regenerating parameters for\n        the same models and parameters.\n\n        Args:\n            actual_query_model: Query parameters model\n            actual_path_params: Path parameters\n            param_names: Function parameter names\n            func_annotations: Function type annotations\n\n        Returns:\n            List of OpenAPI parameters\n\n        \"\"\"\n        openapi_parameters = []\n\n        if actual_query_model or actual_path_params:\n            model_parameters = self._get_or_generate_model_parameters(actual_query_model, actual_path_params)\n            if model_parameters:\n                logger.debug(f\"Added parameters to metadata: {model_parameters}\")\n                openapi_parameters.extend(model_parameters)\n\n        file_params = _detect_file_parameters(param_names, func_annotations, self.prefix_config)\n        if file_params:\n            openapi_parameters.extend(file_params)\n\n        return openapi_parameters\n\n    def _get_or_generate_model_parameters(\n        self,\n        query_model: type[BaseModel] | None,\n        path_params: list[str],\n    ) -&gt; list[dict[str, Any]]:\n        \"\"\"Generate parameters from models and path parameters.\n\n        This method is extracted from _generate_openapi_parameters to improve readability.\n        It generates parameters from query models and path parameters.\n\n        Args:\n            query_model: Query parameters model\n            path_params: Path parameters\n\n        Returns:\n            List of OpenAPI parameters\n\n        \"\"\"\n        model_parameters = []\n\n        if path_params:\n            model_parameters.extend(self._generate_path_parameters(path_params))\n\n        if query_model:\n            model_parameters.extend(self._generate_query_parameters(query_model))\n\n        return model_parameters\n\n    def _generate_path_parameters(self, path_params: list[str]) -&gt; list[dict[str, Any]]:\n        \"\"\"Generate OpenAPI parameters for path parameters.\n\n        Args:\n            path_params: List of path parameter names\n\n        Returns:\n            List of OpenAPI parameters for path parameters\n\n        \"\"\"\n        return [\n            {\n                \"name\": param,\n                \"in\": \"path\",\n                \"required\": True,\n                \"schema\": {\"type\": \"string\"},\n            }\n            for param in path_params\n        ]\n\n    def _generate_query_parameters(self, query_model: type[BaseModel]) -&gt; list[dict[str, Any]]:\n        \"\"\"Generate OpenAPI parameters for query parameters.\n\n        Args:\n            query_model: Query parameters model\n\n        Returns:\n            List of OpenAPI parameters for query parameters\n\n        \"\"\"\n        parameters = []\n        schema = query_model.model_json_schema()\n        properties = schema.get(\"properties\", {})\n        required = schema.get(\"required\", [])\n\n        for field_name, field_schema in properties.items():\n            fixed_schema = _fix_references(field_schema)\n            param = {\n                \"name\": field_name,\n                \"in\": \"query\",\n                \"required\": field_name in required,\n                \"schema\": fixed_schema,\n            }\n\n            if \"description\" in field_schema:\n                param[\"description\"] = field_schema[\"description\"]\n\n            parameters.append(param)\n\n        return parameters\n\n    def _create_function_wrapper(\n        self,\n        func: Callable[P, R],\n        cached_data: dict[str, Any],\n        metadata: dict[str, Any],\n        merged_hints: dict[str, Any],\n    ) -&gt; Callable[P, R]:\n        \"\"\"Create a wrapper function for the decorated function.\n\n        Args:\n            func: The decorated function\n            cached_data: Cached metadata and other information\n            metadata: OpenAPI metadata\n            merged_hints: Merged type hints\n\n        Returns:\n            A wrapper function\n\n        \"\"\"\n\n        @wraps(func)\n        def wrapper(*args, **kwargs) -&gt; Any:\n            return self._process_request(func, cached_data, *args, **kwargs)\n\n        wrapper._openapi_metadata = metadata\n\n        wrapper.__annotations__ = merged_hints\n\n        return cast(\"Callable[P, R]\", wrapper)\n\n    def __call__(self, func: Callable[P, R]) -&gt; Callable[P, R]:\n        \"\"\"Apply the decorator to the function.\n\n        This method has been refactored to use smaller, more focused methods.\n\n        Args:\n            func: The function to decorate\n\n        Returns:\n            The decorated function\n\n        \"\"\"\n        self._initialize_framework_decorator()\n\n        if func in FUNCTION_METADATA_CACHE:\n            cached_data = FUNCTION_METADATA_CACHE[func]\n            return self._create_cached_wrapper(func, cached_data)\n\n        signature = inspect.signature(func)\n        param_names = list(signature.parameters.keys())\n\n        type_hints = get_type_hints(func)\n\n        actual_request_body, actual_query_model, actual_path_params = self._extract_parameters(signature, type_hints)\n\n        logger.debug(\n            f\"Generating metadata with request_body={actual_request_body}, query_model={actual_query_model}, path_params={actual_path_params}\",\n        )\n\n        cache_key = self._generate_metadata_cache_key(actual_request_body, actual_query_model, actual_path_params)\n\n        metadata = self._get_or_generate_metadata(cache_key, actual_request_body)\n\n        func_annotations = get_type_hints(func)\n        openapi_parameters = self._generate_openapi_parameters(\n            actual_query_model, actual_path_params, param_names, func_annotations\n        )\n\n        if any(param.get(\"in\") == \"formData\" for param in openapi_parameters):\n            metadata[\"consumes\"] = [\"multipart/form-data\"]\n\n        if openapi_parameters:\n            metadata[\"parameters\"] = openapi_parameters\n\n        func._openapi_metadata = metadata\n\n        param_types = {}\n\n        if (\n            actual_request_body\n            and isinstance(actual_request_body, type)\n            and issubclass(actual_request_body, BaseModel)\n            and hasattr(actual_request_body, \"model_fields\")\n        ):\n            param_types.update(\n                {field_name: field.annotation for field_name, field in actual_request_body.model_fields.items()}\n            )\n\n        if actual_query_model and hasattr(actual_query_model, \"model_fields\"):\n            param_types.update(\n                {field_name: field.annotation for field_name, field in actual_query_model.model_fields.items()}\n            )\n\n        existing_hints = get_type_hints(func)\n        merged_hints = {**existing_hints, **param_types}\n\n        cached_data = {\n            \"metadata\": metadata,\n            \"annotations\": merged_hints,\n            \"signature\": signature,\n            \"param_names\": param_names,\n            \"type_hints\": type_hints,\n            \"actual_request_body\": actual_request_body,\n            \"actual_query_model\": actual_query_model,\n            \"actual_path_params\": actual_path_params,\n        }\n        FUNCTION_METADATA_CACHE[func] = cached_data\n\n        return self._create_function_wrapper(func, cached_data, metadata, merged_hints)\n\n    def _process_request(self, func: Callable[P, R], cached_data: dict[str, Any], *args, **kwargs) -&gt; Any:\n        \"\"\"Process a request using cached metadata.\n\n        This method uses the ParameterProcessor to handle parameter binding using the Strategy pattern.\n        It extracts parameters from the request context, binds them to function parameters,\n        and handles model validation and conversion.\n\n        Args:\n            func: The decorated function to call.\n            cached_data: Cached metadata and other information about the function.\n            args: Positional arguments to the function.\n            kwargs: Keyword arguments to the function.\n\n        Returns:\n            Any: The result of calling the function with bound parameters,\n                processed by _handle_response if needed.\n\n        \"\"\"\n        signature = cached_data[\"signature\"]\n        param_names = cached_data.get(\"param_names\", [])\n\n        from flask import request\n\n        has_request_context = False\n        with contextlib.suppress(RuntimeError):\n            has_request_context = bool(request)\n\n        if has_request_context and request.method == \"POST\" and request.is_json:\n            json_data = request.get_json(silent=True)\n\n            if json_data:\n                for param_name in param_names:\n                    if param_name in signature.parameters and param_name.startswith(\"_x_body\"):\n                        param_type = cached_data[\"type_hints\"].get(param_name)\n                        if param_type and isinstance(param_type, type) and issubclass(param_type, BaseModel):\n                            with contextlib.suppress(Exception):\n                                model_instance = param_type.model_validate(json_data)\n                                kwargs[param_name] = model_instance\n\n        for param_name in param_names:\n            if param_name not in kwargs and param_name in signature.parameters:\n                param = signature.parameters[param_name]\n                if param.default is param.empty and param_name in cached_data[\"type_hints\"]:\n                    param_type = cached_data[\"type_hints\"][param_name]\n                    if isinstance(param_type, type) and issubclass(param_type, BaseModel):\n                        if has_request_context and param_name.startswith(\"_x_body\") and request.is_json:\n                            json_data = request.get_json(silent=True)\n                            if json_data:\n                                with contextlib.suppress(Exception):\n                                    kwargs[param_name] = param_type.model_validate(json_data)\n                                    continue\n\n                        with contextlib.suppress(Exception):\n                            kwargs[param_name] = param_type()\n\n        parameter_processor = ParameterProcessor(\n            prefix_config=self.prefix_config,\n            framework_decorator=self.framework_decorator,\n        )\n\n        if hasattr(kwargs, \"status_code\") and hasattr(kwargs, \"data\"):\n            return kwargs\n\n        kwargs = parameter_processor.process_parameters(func, cached_data, args, kwargs)\n\n        if hasattr(kwargs, \"status_code\") and hasattr(kwargs, \"data\"):\n            return kwargs\n\n        sig_params = signature.parameters\n\n        if not isinstance(kwargs, dict):\n            logger.warning(f\"kwargs is not a dict: {type(kwargs)}\")\n            valid_kwargs = {}\n        else:\n            valid_kwargs = {k: v for k, v in kwargs.items() if k in sig_params}\n\n        for param_name, param in sig_params.items():\n            if param_name not in valid_kwargs and param.default is param.empty:\n                if param_name in {\"self\", \"cls\"}:\n                    continue\n\n                if param_name in cached_data[\"type_hints\"]:\n                    param_type = cached_data[\"type_hints\"][param_name]\n                    if isinstance(param_type, type) and issubclass(param_type, BaseModel):\n                        if has_request_context and param_name.startswith(\"_x_body\") and request.is_json:\n                            json_data = request.get_json(silent=True)\n                            if json_data:\n                                with contextlib.suppress(Exception):\n                                    valid_kwargs[param_name] = param_type.model_validate(json_data)\n                                    continue\n\n                        if hasattr(param_type, \"model_json_schema\"):\n                            schema = param_type.model_json_schema()\n                            required_fields = schema.get(\"required\", [])\n                            default_data = {}\n                            for field in required_fields:\n                                if field in param_type.model_fields:\n                                    field_info = param_type.model_fields[field]\n                                    if field_info.annotation is str:\n                                        default_data[field] = \"\"\n                                    elif field_info.annotation is int:\n                                        default_data[field] = 0\n                                    elif field_info.annotation is float:\n                                        default_data[field] = 0.0\n                                    elif field_info.annotation is bool:\n                                        default_data[field] = False\n                                    else:\n                                        default_data[field] = None\n\n                            with contextlib.suppress(Exception):\n                                valid_kwargs[param_name] = param_type.model_validate(default_data)\n                        else:\n                            with contextlib.suppress(Exception):\n                                valid_kwargs[param_name] = param_type()\n\n        result = func(*args, **valid_kwargs)\n\n        return _handle_response(result)\n</code></pre>"},{"location":"api/core/#flask_x_openapi_schema.core.decorator_base.OpenAPIDecoratorBase.__call__","title":"<code>__call__(func)</code>","text":"<p>Apply the decorator to the function.</p> <p>This method has been refactored to use smaller, more focused methods.</p> <p>Parameters:</p> Name Type Description Default <code>func</code> <code>Callable[P, R]</code> <p>The function to decorate</p> required <p>Returns:</p> Type Description <code>Callable[P, R]</code> <p>The decorated function</p> Source code in <code>src/flask_x_openapi_schema/core/decorator_base.py</code> <pre><code>def __call__(self, func: Callable[P, R]) -&gt; Callable[P, R]:\n    \"\"\"Apply the decorator to the function.\n\n    This method has been refactored to use smaller, more focused methods.\n\n    Args:\n        func: The function to decorate\n\n    Returns:\n        The decorated function\n\n    \"\"\"\n    self._initialize_framework_decorator()\n\n    if func in FUNCTION_METADATA_CACHE:\n        cached_data = FUNCTION_METADATA_CACHE[func]\n        return self._create_cached_wrapper(func, cached_data)\n\n    signature = inspect.signature(func)\n    param_names = list(signature.parameters.keys())\n\n    type_hints = get_type_hints(func)\n\n    actual_request_body, actual_query_model, actual_path_params = self._extract_parameters(signature, type_hints)\n\n    logger.debug(\n        f\"Generating metadata with request_body={actual_request_body}, query_model={actual_query_model}, path_params={actual_path_params}\",\n    )\n\n    cache_key = self._generate_metadata_cache_key(actual_request_body, actual_query_model, actual_path_params)\n\n    metadata = self._get_or_generate_metadata(cache_key, actual_request_body)\n\n    func_annotations = get_type_hints(func)\n    openapi_parameters = self._generate_openapi_parameters(\n        actual_query_model, actual_path_params, param_names, func_annotations\n    )\n\n    if any(param.get(\"in\") == \"formData\" for param in openapi_parameters):\n        metadata[\"consumes\"] = [\"multipart/form-data\"]\n\n    if openapi_parameters:\n        metadata[\"parameters\"] = openapi_parameters\n\n    func._openapi_metadata = metadata\n\n    param_types = {}\n\n    if (\n        actual_request_body\n        and isinstance(actual_request_body, type)\n        and issubclass(actual_request_body, BaseModel)\n        and hasattr(actual_request_body, \"model_fields\")\n    ):\n        param_types.update(\n            {field_name: field.annotation for field_name, field in actual_request_body.model_fields.items()}\n        )\n\n    if actual_query_model and hasattr(actual_query_model, \"model_fields\"):\n        param_types.update(\n            {field_name: field.annotation for field_name, field in actual_query_model.model_fields.items()}\n        )\n\n    existing_hints = get_type_hints(func)\n    merged_hints = {**existing_hints, **param_types}\n\n    cached_data = {\n        \"metadata\": metadata,\n        \"annotations\": merged_hints,\n        \"signature\": signature,\n        \"param_names\": param_names,\n        \"type_hints\": type_hints,\n        \"actual_request_body\": actual_request_body,\n        \"actual_query_model\": actual_query_model,\n        \"actual_path_params\": actual_path_params,\n    }\n    FUNCTION_METADATA_CACHE[func] = cached_data\n\n    return self._create_function_wrapper(func, cached_data, metadata, merged_hints)\n</code></pre>"},{"location":"api/core/#flask_x_openapi_schema.core.decorator_base.OpenAPIDecoratorBase.__init__","title":"<code>__init__(summary=None, description=None, tags=None, operation_id=None, responses=None, deprecated=False, security=None, external_docs=None, language=None, prefix_config=None, framework='flask', content_type=None, request_content_types=None, response_content_types=None, content_type_resolver=None)</code>","text":"<p>Initialize the decorator with OpenAPI metadata parameters.</p> <p>Parameters:</p> Name Type Description Default <code>summary</code> <code>str | I18nStr | None</code> <p>Short summary of the endpoint, can be an I18nStr for localization.</p> <code>None</code> <code>description</code> <code>str | I18nStr | None</code> <p>Detailed description of the endpoint, can be an I18nStr.</p> <code>None</code> <code>tags</code> <code>list[str] | None</code> <p>List of tags to categorize the endpoint.</p> <code>None</code> <code>operation_id</code> <code>str | None</code> <p>Unique identifier for the operation.</p> <code>None</code> <code>responses</code> <code>OpenAPIMetaResponse | None</code> <p>Response models configuration.</p> <code>None</code> <code>deprecated</code> <code>bool</code> <p>Whether the endpoint is deprecated. Defaults to False.</p> <code>False</code> <code>security</code> <code>list[dict[str, list[str]]] | None</code> <p>Security requirements for the endpoint.</p> <code>None</code> <code>external_docs</code> <code>dict[str, str] | None</code> <p>External documentation references.</p> <code>None</code> <code>language</code> <code>str | None</code> <p>Language code to use for I18nStr values.</p> <code>None</code> <code>prefix_config</code> <code>ConventionalPrefixConfig | None</code> <p>Configuration for parameter prefixes.</p> <code>None</code> <code>framework</code> <code>str</code> <p>Framework name ('flask' or 'flask_restful'). Defaults to \"flask\".</p> <code>'flask'</code> <code>content_type</code> <code>str | None</code> <p>Custom content type for request body. If None, will be auto-detected.</p> <code>None</code> <code>request_content_types</code> <code>RequestContentTypes | None</code> <p>Multiple content types for request body.</p> <code>None</code> <code>response_content_types</code> <code>ResponseContentTypes | None</code> <p>Multiple content types for response body.</p> <code>None</code> <code>content_type_resolver</code> <code>Callable[[Any], str] | None</code> <p>Function to determine content type based on request.</p> <code>None</code> Source code in <code>src/flask_x_openapi_schema/core/decorator_base.py</code> <pre><code>def __init__(\n    self,\n    summary: str | I18nStr | None = None,\n    description: str | I18nStr | None = None,\n    tags: list[str] | None = None,\n    operation_id: str | None = None,\n    responses: OpenAPIMetaResponse | None = None,\n    deprecated: bool = False,\n    security: list[dict[str, list[str]]] | None = None,\n    external_docs: dict[str, str] | None = None,\n    language: str | None = None,\n    prefix_config: ConventionalPrefixConfig | None = None,\n    framework: str = \"flask\",\n    content_type: str | None = None,\n    request_content_types: RequestContentTypes | None = None,\n    response_content_types: ResponseContentTypes | None = None,\n    content_type_resolver: Callable[[Any], str] | None = None,\n) -&gt; None:\n    \"\"\"Initialize the decorator with OpenAPI metadata parameters.\n\n    Args:\n        summary: Short summary of the endpoint, can be an I18nStr for localization.\n        description: Detailed description of the endpoint, can be an I18nStr.\n        tags: List of tags to categorize the endpoint.\n        operation_id: Unique identifier for the operation.\n        responses: Response models configuration.\n        deprecated: Whether the endpoint is deprecated. Defaults to False.\n        security: Security requirements for the endpoint.\n        external_docs: External documentation references.\n        language: Language code to use for I18nStr values.\n        prefix_config: Configuration for parameter prefixes.\n        framework: Framework name ('flask' or 'flask_restful'). Defaults to \"flask\".\n        content_type: Custom content type for request body. If None, will be auto-detected.\n        request_content_types: Multiple content types for request body.\n        response_content_types: Multiple content types for response body.\n        content_type_resolver: Function to determine content type based on request.\n\n\n    \"\"\"\n    self.summary = summary\n    self.description = description\n    self.tags = tags\n    self.operation_id = operation_id\n    self.responses = responses\n    self.deprecated = deprecated\n    self.security = security\n    self.external_docs = external_docs\n    self.language = language\n    self.prefix_config = prefix_config\n    self.framework = framework\n    self.content_type = content_type\n    self.request_content_types = request_content_types\n    self.response_content_types = response_content_types\n    self.content_type_resolver = content_type_resolver\n    self.default_error_response = responses.default_error_response if responses else BaseErrorResponse\n\n    self.framework_decorator = None\n</code></pre>"},{"location":"api/core/#schema-generator","title":"Schema Generator","text":"<p>OpenAPI Schema Generator for API documentation.</p> <p>This module provides the main class for generating OpenAPI schemas from Flask-RESTful resources. It handles scanning resources, extracting metadata, and generating a complete OpenAPI schema.</p>"},{"location":"api/core/#flask_x_openapi_schema.core.schema_generator.OpenAPISchemaGenerator","title":"<code>OpenAPISchemaGenerator</code>","text":"<p>Generator for OpenAPI schemas from Flask-RESTful resources.</p> <p>This class scans Flask-RESTful resources and generates OpenAPI schemas based on the resource methods, docstrings, and type annotations.</p> Source code in <code>src/flask_x_openapi_schema/core/schema_generator.py</code> <pre><code>class OpenAPISchemaGenerator:\n    \"\"\"Generator for OpenAPI schemas from Flask-RESTful resources.\n\n    This class scans Flask-RESTful resources and generates OpenAPI schemas based on\n    the resource methods, docstrings, and type annotations.\n    \"\"\"\n\n    def __init__(\n        self,\n        title: str | None = None,\n        version: str | None = None,\n        description: str | None = None,\n        language: str | None = None,\n    ) -&gt; None:\n        \"\"\"Initialize the OpenAPI schema generator.\n\n        Args:\n            title: The title of the API (default: from config)\n            version: The version of the API (default: from config)\n            description: The description of the API (default: from config)\n            language: The language to use for internationalized strings (default: current language)\n\n        \"\"\"\n        # Get defaults from config if not provided\n        config = get_openapi_config()\n\n        # Handle I18nString for title and description\n        self.title = title if title is not None else config.title\n        if isinstance(self.title, I18nStr):\n            self.title = self.title.get(language)\n\n        self.version = version if version is not None else config.version\n\n        self.description = description if description is not None else config.description\n        if isinstance(self.description, I18nStr):\n            self.description = self.description.get(language)\n\n        self.language = language or get_current_language()\n\n        # Initialize data structures\n        self.paths: dict[str, dict[str, Any]] = {}\n        self.components: dict[str, dict[str, Any]] = {\n            \"schemas\": {},\n            \"securitySchemes\": config.security_schemes.copy() if config.security_schemes else {},\n        }\n        self.tags: list[dict[str, str]] = []\n        self.webhooks: dict[str, dict[str, Any]] = {}\n        self._registered_models: set[type[BaseModel]] = set()\n\n        # Thread safety locks\n        self._lock = threading.RLock()  # Main lock for coordinating access\n        self._paths_lock = threading.RLock()\n        self._components_lock = threading.RLock()\n        self._tags_lock = threading.RLock()\n        self._models_lock = threading.RLock()\n        self._webhooks_lock = threading.RLock()\n\n    def add_security_scheme(self, name: str, scheme: dict[str, Any]) -&gt; None:\n        \"\"\"Add a security scheme to the OpenAPI schema.\n\n        Args:\n            name: The name of the security scheme\n            scheme: The security scheme definition\n\n        \"\"\"\n        with self._components_lock:\n            self.components[\"securitySchemes\"][name] = scheme\n\n    def add_tag(self, name: str, description: str = \"\") -&gt; None:\n        \"\"\"Add a tag to the OpenAPI schema.\n\n        Args:\n            name: The name of the tag\n            description: The description of the tag\n\n        \"\"\"\n        with self._tags_lock:\n            self.tags.append({\"name\": name, \"description\": description})\n\n    def add_webhook(self, name: str, webhook_data: dict[str, Any]) -&gt; None:\n        \"\"\"Add a webhook to the OpenAPI schema.\n\n        Args:\n            name: The name of the webhook\n            webhook_data: The webhook definition\n\n        \"\"\"\n        with self._webhooks_lock:\n            self.webhooks[name] = webhook_data\n\n    def scan_blueprint(self, blueprint: Blueprint) -&gt; None:\n        \"\"\"Scan a Flask blueprint for API resources and add them to the schema.\n\n        Args:\n            blueprint: The Flask blueprint to scan\n\n        \"\"\"\n        # Get all resources registered to the blueprint\n        if not hasattr(blueprint, \"resources\"):\n            return\n\n        for resource, urls, _ in blueprint.resources:\n            self._process_resource(resource, urls, blueprint.url_prefix)\n\n    def _process_resource(self, resource: Any, urls: tuple[str], prefix: str | None = None) -&gt; None:\n        \"\"\"Process a Flask-RESTful resource and add its endpoints to the schema.\n\n        Args:\n            resource: The Flask-RESTful resource class\n            urls: The URLs registered for the resource\n            prefix: The URL prefix for the resource\n\n        \"\"\"\n        for url in urls:\n            full_url = f\"{prefix or ''}{url}\"\n            # Convert Flask URL parameters to OpenAPI parameters\n            openapi_path = self._convert_flask_path_to_openapi_path(full_url)\n\n            # Process HTTP methods and build operations\n            http_methods = [\n                \"get\",\n                \"post\",\n                \"put\",\n                \"delete\",\n                \"patch\",\n                \"head\",\n                \"options\",\n            ]\n\n            operations = {}\n            for method_name in http_methods:\n                if hasattr(resource, method_name):\n                    method = getattr(resource, method_name)\n                    operation = self._build_operation_from_method(method, resource)\n\n                    # Add parameters from URL\n                    path_params = self._extract_path_parameters(full_url)\n                    if path_params:\n                        if \"parameters\" not in operation:\n                            operation[\"parameters\"] = []\n\n                        # Add path parameters without duplicates\n                        existing_param_names = {p[\"name\"] for p in operation[\"parameters\"] if p[\"in\"] == \"path\"}\n                        for param in path_params:\n                            if param[\"name\"] not in existing_param_names:\n                                operation[\"parameters\"].append(param)\n                                existing_param_names.add(param[\"name\"])\n\n                    operations[method_name] = operation\n\n            # Update paths in a thread-safe manner\n            with self._paths_lock:\n                # Initialize path item if it doesn't exist\n                if openapi_path not in self.paths:\n                    self.paths[openapi_path] = {}\n\n                # Add all operations at once\n                for method_name, operation in operations.items():\n                    self.paths[openapi_path][method_name] = operation\n\n    def _convert_flask_path_to_openapi_path(self, flask_path: str) -&gt; str:\n        \"\"\"Convert a Flask URL path to an OpenAPI path.\n\n        Args:\n            flask_path: The Flask URL path\n\n        Returns:\n            The OpenAPI path\n\n        \"\"\"\n        from .cache import get_parameter_prefixes\n\n        # Get parameter prefixes from current configuration\n        _, _, path_prefix, _ = get_parameter_prefixes()\n        path_prefix_len = len(path_prefix) + 1  # +1 for the underscore\n\n        # Replace Flask's &lt;converter:param&gt; with OpenAPI's {param}\n        # and remove any prefix from the parameter name\n        def replace_param(match: re.Match) -&gt; str:\n            param_name = match.group(1)\n\n            # Remove prefix if present (e.g., _x_path_)\n            if param_name.startswith(f\"{path_prefix}_\"):\n                param_name = param_name[path_prefix_len:]\n\n            return f\"{{{param_name}}}\"\n\n        return re.sub(r\"&lt;(?:[^:&gt;]+:)?([^&gt;]+)&gt;\", replace_param, flask_path)\n\n    def _extract_path_parameters(self, flask_path: str) -&gt; list[dict[str, Any]]:\n        \"\"\"Extract path parameters from a Flask URL path.\n\n        Args:\n            flask_path: The Flask URL path\n\n        Returns:\n            A list of OpenAPI parameter objects\n\n        \"\"\"\n        from .cache import get_parameter_prefixes\n\n        # Get parameter prefixes from current configuration\n        _, _, path_prefix, _ = get_parameter_prefixes()\n        path_prefix_len = len(path_prefix) + 1  # +1 for the underscore\n\n        parameters = []\n        # Match Flask's &lt;converter:param&gt; or &lt;param&gt;\n        for match in re.finditer(r\"&lt;(?:([^:&gt;]+):)?([^&gt;]+)&gt;\", flask_path):\n            converter, param_name = match.groups()\n\n            # Remove prefix if present (e.g., _x_path_)\n            actual_param_name = param_name\n            if param_name.startswith(f\"{path_prefix}_\"):\n                actual_param_name = param_name[path_prefix_len:]\n\n            param = {\n                \"name\": actual_param_name,\n                \"in\": \"path\",\n                \"required\": True,\n                \"schema\": self._get_schema_for_converter(converter or \"string\"),\n            }\n            parameters.append(param)\n        return parameters\n\n    def _get_schema_for_converter(self, converter: str) -&gt; dict[str, Any]:\n        \"\"\"Get an OpenAPI schema for a Flask URL converter.\n\n        Args:\n            converter: The Flask URL converter\n\n        Returns:\n            An OpenAPI schema object\n\n        \"\"\"\n        # Map Flask URL converters to OpenAPI types\n        converter_map = {\n            \"string\": {\"type\": \"string\"},\n            \"int\": {\"type\": \"integer\"},\n            \"float\": {\"type\": \"number\", \"format\": \"float\"},\n            \"path\": {\"type\": \"string\"},\n            \"uuid\": {\"type\": \"string\", \"format\": \"uuid\"},\n            \"any\": {\"type\": \"string\"},\n        }\n        return converter_map.get(converter, {\"type\": \"string\"})\n\n    def _build_operation_from_method(self, method: Any, resource_cls: Any) -&gt; dict[str, Any]:\n        \"\"\"Build an OpenAPI operation object from a Flask-RESTful resource method.\n\n        Args:\n            method: The resource method\n            resource_cls: The resource class\n\n        Returns:\n            An OpenAPI operation object\n\n        \"\"\"\n        operation: dict[str, Any] = {}\n\n        # Get metadata from method if available\n        metadata = getattr(method, \"_openapi_metadata\", {})\n\n        # Process metadata, handling I18nString values\n        for key, value in metadata.items():\n            if isinstance(value, I18nStr):\n                operation[key] = value.get(self.language)\n            elif isinstance(value, dict):\n                # Handle nested dictionaries that might contain I18nString values\n                operation[key] = self._process_i18n_dict(value)\n            else:\n                operation[key] = value\n\n        # Extract summary and description from docstring\n        if method.__doc__:\n            docstring = method.__doc__.strip()\n            lines = docstring.split(\"\\n\")\n            operation[\"summary\"] = lines[0].strip()\n            if len(lines) &gt; 1:\n                operation[\"description\"] = \"\\n\".join(line.strip() for line in lines[1:]).strip()\n\n        # Get operation ID\n        if \"operationId\" not in operation:\n            operation[\"operationId\"] = _get_operation_id(resource_cls.__name__, method.__name__)\n\n        # Extract request and response schemas from type annotations\n        self._add_request_schema(method, operation)\n        self._add_response_schema(method, operation)\n\n        return operation\n\n    def _add_request_schema(self, method: Any, operation: dict[str, Any]) -&gt; None:\n        \"\"\"Add request schema to an OpenAPI operation based on method type annotations.\n\n        Args:\n            method: The resource method\n            operation: The OpenAPI operation object to update\n\n        \"\"\"\n        type_hints = get_type_hints(method)\n\n        # Look for parameters that might be request bodies\n        for param_name, param_type in type_hints.items():\n            if param_name == \"return\":\n                continue\n\n            # Check if the parameter is a Pydantic model\n            if isinstance(param_type, type) and issubclass(param_type, BaseModel):\n                self._register_model(param_type)\n\n                # Check if this is a file upload model\n                is_file_upload = False\n                has_binary_fields = False\n\n                # Check model config for multipart/form-data flag\n                if hasattr(param_type, \"model_config\"):\n                    config = getattr(param_type, \"model_config\", {})\n                    if isinstance(config, dict) and config.get(\"json_schema_extra\", {}).get(\n                        \"multipart/form-data\",\n                        False,\n                    ):\n                        is_file_upload = True\n                elif hasattr(param_type, \"Config\") and hasattr(param_type.Config, \"json_schema_extra\"):\n                    config_extra = getattr(param_type.Config, \"json_schema_extra\", {})\n                    is_file_upload = config_extra.get(\"multipart/form-data\", False)\n\n                # Check if model has any binary fields\n                if hasattr(param_type, \"model_fields\"):\n                    for field_info in param_type.model_fields.values():\n                        field_schema = getattr(field_info, \"json_schema_extra\", None)\n                        if field_schema is not None and field_schema.get(\"format\") == \"binary\":\n                            has_binary_fields = True\n                            break\n\n                # Determine content type based on model properties\n                content_type = \"multipart/form-data\" if (is_file_upload or has_binary_fields) else \"application/json\"\n\n                # Add request body with appropriate content type\n                operation[\"requestBody\"] = {\n                    \"content\": {content_type: {\"schema\": {\"$ref\": f\"#/components/schemas/{param_type.__name__}\"}}},\n                    \"required\": True,\n                }\n\n                # If this is a file upload model, remove any file parameters from parameters\n                # as they will be included in the requestBody\n                if (is_file_upload or has_binary_fields) and \"parameters\" in operation:\n                    # Keep only path and query parameters\n                    operation[\"parameters\"] = [p for p in operation[\"parameters\"] if p[\"in\"] in [\"path\", \"query\"]]\n                break\n\n    def _add_response_schema(self, method: Any, operation: dict[str, Any]) -&gt; None:\n        \"\"\"Add response schema to an OpenAPI operation based on method return type annotation.\n\n        Args:\n            method: The resource method\n            operation: The OpenAPI operation object to update\n\n        \"\"\"\n        type_hints = get_type_hints(method)\n\n        # Check if there's a return type hint\n        if \"return\" in type_hints:\n            return_type = type_hints[\"return\"]\n\n            # Handle Pydantic models\n            if isinstance(return_type, type) and issubclass(return_type, BaseModel):\n                self._register_model(return_type)\n\n                operation[\"responses\"] = {\n                    \"200\": {\n                        \"description\": \"Successful response\",\n                        \"content\": {\n                            \"application/json\": {\"schema\": {\"$ref\": f\"#/components/schemas/{return_type.__name__}\"}},\n                        },\n                    },\n                }\n            else:\n                # Default response\n                operation[\"responses\"] = {\"200\": {\"description\": \"Successful response\"}}\n        else:\n            # Default response if no return type is specified\n            operation[\"responses\"] = {\"200\": {\"description\": \"Successful response\"}}\n\n    def _register_model(self, model: type) -&gt; None:\n        \"\"\"Register a Pydantic model or enum in the components schemas.\n\n        Args:\n            model: The model to register (Pydantic model or enum)\n\n        \"\"\"\n        with self._models_lock:\n            # Skip if already registered\n            if model in self._registered_models:\n                return\n\n            # Add to registered models set\n            self._registered_models.add(model)\n\n        # Handle enum types\n        if hasattr(model, \"__members__\"):\n            # This is an enum type\n            with self._components_lock:\n                enum_schema = {\"type\": \"string\", \"enum\": [e.value for e in model]}\n\n                if model.__name__ not in self.components[\"schemas\"]:\n                    self.components[\"schemas\"][model.__name__] = enum_schema\n            return\n\n        # Handle Pydantic models\n        if not issubclass(model, BaseModel):\n            return\n\n        if issubclass(model, I18nBaseModel):\n            # Create a language-specific version of the model\n            language_model = model.for_language(self.language)\n            schema = pydantic_to_openapi_schema(language_model)\n        else:\n            # Use the cached version from utils.py\n            schema = pydantic_to_openapi_schema(model)\n\n        # Update components in a thread-safe manner\n        with self._components_lock:\n            self.components[\"schemas\"][model.__name__] = schema\n\n        # Register nested models\n        self._register_nested_models(model)\n\n    def _register_nested_models(self, model: type[BaseModel]) -&gt; None:\n        \"\"\"Register nested Pydantic models found in fields of the given model.\n\n        Args:\n            model: The Pydantic model to scan for nested models\n\n        \"\"\"\n        # Get model fields\n        if not hasattr(model, \"model_fields\"):\n            return\n\n        # Check each field for nested models\n        for field_info in model.model_fields.values():\n            field_type = field_info.annotation\n\n            # Handle direct BaseModel references\n            if isinstance(field_type, type) and issubclass(field_type, BaseModel):\n                self._register_model(field_type)\n                continue\n\n            # Handle List[BaseModel] and similar container types\n            origin = getattr(field_type, \"__origin__\", None)\n            args = getattr(field_type, \"__args__\", [])\n\n            if origin and args:\n                for arg in args:\n                    if isinstance(arg, type) and issubclass(arg, BaseModel):\n                        self._register_model(arg)\n                    elif hasattr(arg, \"__members__\"):\n                        # Handle enum types\n                        # Register enum in components/schemas\n                        with self._components_lock:\n                            enum_schema = {\n                                \"type\": \"string\",\n                                \"enum\": [e.value for e in arg],\n                            }\n\n                            if arg.__name__ not in self.components[\"schemas\"]:\n                                self.components[\"schemas\"][arg.__name__] = enum_schema\n\n            # Handle enum types directly\n            elif hasattr(field_type, \"__members__\"):\n                # Register enum in components/schemas\n                with self._components_lock:\n                    enum_schema = {\n                        \"type\": \"string\",\n                        \"enum\": [e.value for e in field_type],\n                    }\n\n                    if field_type.__name__ not in self.components[\"schemas\"]:\n                        self.components[\"schemas\"][field_type.__name__] = enum_schema\n\n    def _process_i18n_dict(self, data: dict[str, Any]) -&gt; dict[str, Any]:\n        \"\"\"Process a dictionary that might contain I18nString values.\n\n        Args:\n            data: The dictionary to process\n\n        Returns:\n            A new dictionary with I18nString values converted to strings\n\n        \"\"\"\n        return process_i18n_dict(data, self.language)\n\n    def _process_i18n_value(self, value: Any) -&gt; Any:\n        \"\"\"Process a value that might be an I18nString or contain I18nString values.\n\n        Args:\n            value: The value to process\n\n        Returns:\n            The processed value\n\n        \"\"\"\n        return process_i18n_value(value, self.language)\n\n    def generate_schema(self) -&gt; dict[str, Any]:\n        \"\"\"Generate the complete OpenAPI schema.\n\n        Returns:\n            The OpenAPI schema as a dictionary\n\n        \"\"\"\n        # Use a lock to ensure consistent state during schema generation\n        with self._lock:\n            # Get OpenAPI configuration\n            config = get_openapi_config()\n\n            schema = {\n                \"openapi\": config.openapi_version,\n                \"info\": {\n                    \"title\": self.title,\n                    \"version\": self.version,\n                    \"description\": self.description,\n                },\n                \"paths\": self.paths,\n                \"components\": self.components,\n                \"tags\": self.tags,\n            }\n\n            # Add webhooks if defined\n            if self.webhooks:\n                schema[\"webhooks\"] = self.webhooks\n\n            # Add servers if defined in config\n            if config.servers:\n                schema[\"servers\"] = config.servers\n\n            # Add external docs if defined in config\n            if config.external_docs:\n                schema[\"externalDocs\"] = config.external_docs\n\n            # Add JSON Schema dialect if defined in config\n            if config.json_schema_dialect:\n                schema[\"jsonSchemaDialect\"] = config.json_schema_dialect\n\n            return schema\n</code></pre>"},{"location":"api/core/#flask_x_openapi_schema.core.schema_generator.OpenAPISchemaGenerator.__init__","title":"<code>__init__(title=None, version=None, description=None, language=None)</code>","text":"<p>Initialize the OpenAPI schema generator.</p> <p>Parameters:</p> Name Type Description Default <code>title</code> <code>str | None</code> <p>The title of the API (default: from config)</p> <code>None</code> <code>version</code> <code>str | None</code> <p>The version of the API (default: from config)</p> <code>None</code> <code>description</code> <code>str | None</code> <p>The description of the API (default: from config)</p> <code>None</code> <code>language</code> <code>str | None</code> <p>The language to use for internationalized strings (default: current language)</p> <code>None</code> Source code in <code>src/flask_x_openapi_schema/core/schema_generator.py</code> <pre><code>def __init__(\n    self,\n    title: str | None = None,\n    version: str | None = None,\n    description: str | None = None,\n    language: str | None = None,\n) -&gt; None:\n    \"\"\"Initialize the OpenAPI schema generator.\n\n    Args:\n        title: The title of the API (default: from config)\n        version: The version of the API (default: from config)\n        description: The description of the API (default: from config)\n        language: The language to use for internationalized strings (default: current language)\n\n    \"\"\"\n    # Get defaults from config if not provided\n    config = get_openapi_config()\n\n    # Handle I18nString for title and description\n    self.title = title if title is not None else config.title\n    if isinstance(self.title, I18nStr):\n        self.title = self.title.get(language)\n\n    self.version = version if version is not None else config.version\n\n    self.description = description if description is not None else config.description\n    if isinstance(self.description, I18nStr):\n        self.description = self.description.get(language)\n\n    self.language = language or get_current_language()\n\n    # Initialize data structures\n    self.paths: dict[str, dict[str, Any]] = {}\n    self.components: dict[str, dict[str, Any]] = {\n        \"schemas\": {},\n        \"securitySchemes\": config.security_schemes.copy() if config.security_schemes else {},\n    }\n    self.tags: list[dict[str, str]] = []\n    self.webhooks: dict[str, dict[str, Any]] = {}\n    self._registered_models: set[type[BaseModel]] = set()\n\n    # Thread safety locks\n    self._lock = threading.RLock()  # Main lock for coordinating access\n    self._paths_lock = threading.RLock()\n    self._components_lock = threading.RLock()\n    self._tags_lock = threading.RLock()\n    self._models_lock = threading.RLock()\n    self._webhooks_lock = threading.RLock()\n</code></pre>"},{"location":"api/core/#flask_x_openapi_schema.core.schema_generator.OpenAPISchemaGenerator.add_security_scheme","title":"<code>add_security_scheme(name, scheme)</code>","text":"<p>Add a security scheme to the OpenAPI schema.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name of the security scheme</p> required <code>scheme</code> <code>dict[str, Any]</code> <p>The security scheme definition</p> required Source code in <code>src/flask_x_openapi_schema/core/schema_generator.py</code> <pre><code>def add_security_scheme(self, name: str, scheme: dict[str, Any]) -&gt; None:\n    \"\"\"Add a security scheme to the OpenAPI schema.\n\n    Args:\n        name: The name of the security scheme\n        scheme: The security scheme definition\n\n    \"\"\"\n    with self._components_lock:\n        self.components[\"securitySchemes\"][name] = scheme\n</code></pre>"},{"location":"api/core/#flask_x_openapi_schema.core.schema_generator.OpenAPISchemaGenerator.add_tag","title":"<code>add_tag(name, description='')</code>","text":"<p>Add a tag to the OpenAPI schema.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name of the tag</p> required <code>description</code> <code>str</code> <p>The description of the tag</p> <code>''</code> Source code in <code>src/flask_x_openapi_schema/core/schema_generator.py</code> <pre><code>def add_tag(self, name: str, description: str = \"\") -&gt; None:\n    \"\"\"Add a tag to the OpenAPI schema.\n\n    Args:\n        name: The name of the tag\n        description: The description of the tag\n\n    \"\"\"\n    with self._tags_lock:\n        self.tags.append({\"name\": name, \"description\": description})\n</code></pre>"},{"location":"api/core/#flask_x_openapi_schema.core.schema_generator.OpenAPISchemaGenerator.add_webhook","title":"<code>add_webhook(name, webhook_data)</code>","text":"<p>Add a webhook to the OpenAPI schema.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name of the webhook</p> required <code>webhook_data</code> <code>dict[str, Any]</code> <p>The webhook definition</p> required Source code in <code>src/flask_x_openapi_schema/core/schema_generator.py</code> <pre><code>def add_webhook(self, name: str, webhook_data: dict[str, Any]) -&gt; None:\n    \"\"\"Add a webhook to the OpenAPI schema.\n\n    Args:\n        name: The name of the webhook\n        webhook_data: The webhook definition\n\n    \"\"\"\n    with self._webhooks_lock:\n        self.webhooks[name] = webhook_data\n</code></pre>"},{"location":"api/core/#flask_x_openapi_schema.core.schema_generator.OpenAPISchemaGenerator.generate_schema","title":"<code>generate_schema()</code>","text":"<p>Generate the complete OpenAPI schema.</p> <p>Returns:</p> Type Description <code>dict[str, Any]</code> <p>The OpenAPI schema as a dictionary</p> Source code in <code>src/flask_x_openapi_schema/core/schema_generator.py</code> <pre><code>def generate_schema(self) -&gt; dict[str, Any]:\n    \"\"\"Generate the complete OpenAPI schema.\n\n    Returns:\n        The OpenAPI schema as a dictionary\n\n    \"\"\"\n    # Use a lock to ensure consistent state during schema generation\n    with self._lock:\n        # Get OpenAPI configuration\n        config = get_openapi_config()\n\n        schema = {\n            \"openapi\": config.openapi_version,\n            \"info\": {\n                \"title\": self.title,\n                \"version\": self.version,\n                \"description\": self.description,\n            },\n            \"paths\": self.paths,\n            \"components\": self.components,\n            \"tags\": self.tags,\n        }\n\n        # Add webhooks if defined\n        if self.webhooks:\n            schema[\"webhooks\"] = self.webhooks\n\n        # Add servers if defined in config\n        if config.servers:\n            schema[\"servers\"] = config.servers\n\n        # Add external docs if defined in config\n        if config.external_docs:\n            schema[\"externalDocs\"] = config.external_docs\n\n        # Add JSON Schema dialect if defined in config\n        if config.json_schema_dialect:\n            schema[\"jsonSchemaDialect\"] = config.json_schema_dialect\n\n        return schema\n</code></pre>"},{"location":"api/core/#flask_x_openapi_schema.core.schema_generator.OpenAPISchemaGenerator.scan_blueprint","title":"<code>scan_blueprint(blueprint)</code>","text":"<p>Scan a Flask blueprint for API resources and add them to the schema.</p> <p>Parameters:</p> Name Type Description Default <code>blueprint</code> <code>Blueprint</code> <p>The Flask blueprint to scan</p> required Source code in <code>src/flask_x_openapi_schema/core/schema_generator.py</code> <pre><code>def scan_blueprint(self, blueprint: Blueprint) -&gt; None:\n    \"\"\"Scan a Flask blueprint for API resources and add them to the schema.\n\n    Args:\n        blueprint: The Flask blueprint to scan\n\n    \"\"\"\n    # Get all resources registered to the blueprint\n    if not hasattr(blueprint, \"resources\"):\n        return\n\n    for resource, urls, _ in blueprint.resources:\n        self._process_resource(resource, urls, blueprint.url_prefix)\n</code></pre>"},{"location":"api/core/#utilities","title":"Utilities","text":"<p>Utility functions for OpenAPI schema generation.</p> <p>This module provides utility functions for converting Pydantic models to OpenAPI schemas, handling references, and processing internationalized strings. It includes functions for:</p> <ul> <li>Converting Pydantic models to OpenAPI schemas</li> <li>Converting Python types to OpenAPI types</li> <li>Generating response schemas for API endpoints</li> <li>Processing internationalized strings in schemas</li> </ul>"},{"location":"api/core/#flask_x_openapi_schema.core.utils.clear_i18n_cache","title":"<code>clear_i18n_cache()</code>","text":"<p>Clear the i18n processing cache.</p> <p>Clears any cached results from I18n string processing functions. Call this function when you need to ensure that I18n strings are re-processed, such as after changing the language configuration.</p> Source code in <code>src/flask_x_openapi_schema/core/utils.py</code> <pre><code>def clear_i18n_cache() -&gt; None:\n    \"\"\"Clear the i18n processing cache.\n\n    Clears any cached results from I18n string processing functions.\n    Call this function when you need to ensure that I18n strings are\n    re-processed, such as after changing the language configuration.\n    \"\"\"\n</code></pre>"},{"location":"api/core/#flask_x_openapi_schema.core.utils.clear_references_cache","title":"<code>clear_references_cache()</code>","text":"<p>Clear the references processing cache.</p> <p>Clears any cached results from schema reference processing functions. Call this function when you need to ensure that schema references are re-processed, such as after modifying schema definitions.</p> Source code in <code>src/flask_x_openapi_schema/core/utils.py</code> <pre><code>def clear_references_cache() -&gt; None:\n    \"\"\"Clear the references processing cache.\n\n    Clears any cached results from schema reference processing functions.\n    Call this function when you need to ensure that schema references are\n    re-processed, such as after modifying schema definitions.\n    \"\"\"\n</code></pre>"},{"location":"api/core/#flask_x_openapi_schema.core.utils.error_response_schema","title":"<code>error_response_schema(description, status_code=400)</code>","text":"<p>Generate an OpenAPI error response schema.</p> <p>Creates a simple OpenAPI error response object with a description. Unlike success responses, error responses don't include content schema.</p> <p>Parameters:</p> Name Type Description Default <code>description</code> <code>str</code> <p>Description of the error</p> required <code>status_code</code> <code>int | str</code> <p>HTTP status code for the error (default: 400)</p> <code>400</code> <p>Returns:</p> Name Type Description <code>dict</code> <code>dict[str, Any]</code> <p>An OpenAPI error response schema object</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; schema = error_response_schema(\"Bad Request\", 400)\n&gt;&gt;&gt; schema[\"400\"][\"description\"]\n'Bad Request'\n</code></pre> Source code in <code>src/flask_x_openapi_schema/core/utils.py</code> <pre><code>def error_response_schema(\n    description: str,\n    status_code: int | str = 400,\n) -&gt; dict[str, Any]:\n    \"\"\"Generate an OpenAPI error response schema.\n\n    Creates a simple OpenAPI error response object with a description.\n    Unlike success responses, error responses don't include content schema.\n\n    Args:\n        description: Description of the error\n        status_code: HTTP status code for the error (default: 400)\n\n    Returns:\n        dict: An OpenAPI error response schema object\n\n    Examples:\n        &gt;&gt;&gt; schema = error_response_schema(\"Bad Request\", 400)\n        &gt;&gt;&gt; schema[\"400\"][\"description\"]\n        'Bad Request'\n\n    \"\"\"\n    return {\n        str(status_code): {\n            \"description\": description,\n        },\n    }\n</code></pre>"},{"location":"api/core/#flask_x_openapi_schema.core.utils.process_i18n_dict","title":"<code>process_i18n_dict(data, language)</code>","text":"<p>Process a dictionary that might contain I18nString values.</p> <p>Recursively processes all I18nString values in a dictionary, converting them to language-specific strings. Also handles nested dictionaries and lists that might contain I18nString values.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>dict[str, Any]</code> <p>The dictionary to process, which might contain I18nString values</p> required <code>language</code> <code>str</code> <p>The language code to use for extracting localized strings</p> required <p>Returns:</p> Name Type Description <code>dict</code> <code>dict[str, Any]</code> <p>A new dictionary with I18nString values converted to language-specific strings</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from flask_x_openapi_schema.i18n.i18n_string import I18nStr\n&gt;&gt;&gt; data = {\n...     \"title\": I18nStr({\"en\": \"Hello\", \"fr\": \"Bonjour\"}),\n...     \"nested\": {\"subtitle\": I18nStr({\"en\": \"World\", \"fr\": \"Monde\"})},\n... }\n&gt;&gt;&gt; result = process_i18n_dict(data, \"en\")\n&gt;&gt;&gt; result[\"title\"]\n'Hello'\n&gt;&gt;&gt; result[\"nested\"][\"subtitle\"]\n'World'\n</code></pre> Source code in <code>src/flask_x_openapi_schema/core/utils.py</code> <pre><code>def process_i18n_dict(data: dict[str, Any], language: str) -&gt; dict[str, Any]:\n    \"\"\"Process a dictionary that might contain I18nString values.\n\n    Recursively processes all I18nString values in a dictionary, converting them\n    to language-specific strings. Also handles nested dictionaries and lists that\n    might contain I18nString values.\n\n    Args:\n        data: The dictionary to process, which might contain I18nString values\n        language: The language code to use for extracting localized strings\n\n    Returns:\n        dict: A new dictionary with I18nString values converted to language-specific strings\n\n    Examples:\n        &gt;&gt;&gt; from flask_x_openapi_schema.i18n.i18n_string import I18nStr\n        &gt;&gt;&gt; data = {\n        ...     \"title\": I18nStr({\"en\": \"Hello\", \"fr\": \"Bonjour\"}),\n        ...     \"nested\": {\"subtitle\": I18nStr({\"en\": \"World\", \"fr\": \"Monde\"})},\n        ... }\n        &gt;&gt;&gt; result = process_i18n_dict(data, \"en\")\n        &gt;&gt;&gt; result[\"title\"]\n        'Hello'\n        &gt;&gt;&gt; result[\"nested\"][\"subtitle\"]\n        'World'\n\n    \"\"\"\n    from flask_x_openapi_schema.i18n.i18n_string import I18nStr\n\n    result = {}\n    for key, value in data.items():\n        if isinstance(value, I18nStr):\n            result[key] = value.get(language)\n        elif isinstance(value, dict):\n            result[key] = process_i18n_dict(value, language)\n        elif isinstance(value, list):\n            result[key] = [process_i18n_value(item, language) for item in value]\n        else:\n            result[key] = value\n\n    return result\n</code></pre>"},{"location":"api/core/#flask_x_openapi_schema.core.utils.process_i18n_value","title":"<code>process_i18n_value(value, language)</code>","text":"<p>Process a value that might be an I18nString or contain I18nString values.</p> <p>Recursively processes values that might be I18nString instances or contain I18nString instances (in lists or dictionaries). For I18nString instances, returns the string for the specified language.</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>Any</code> <p>The value to process, which might be an I18nString or contain I18nString values</p> required <code>language</code> <code>str</code> <p>The language code to use for extracting localized strings</p> required <p>Returns:</p> Name Type Description <code>Any</code> <code>Any</code> <p>The processed value with I18nString instances replaced by their language-specific strings</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from flask_x_openapi_schema.i18n.i18n_string import I18nStr\n&gt;&gt;&gt; i18n_str = I18nStr({\"en\": \"Hello\", \"fr\": \"Bonjour\"})\n&gt;&gt;&gt; process_i18n_value(i18n_str, \"en\")\n'Hello'\n&gt;&gt;&gt; process_i18n_value(i18n_str, \"fr\")\n'Bonjour'\n&gt;&gt;&gt; process_i18n_value({\"greeting\": i18n_str}, \"en\")\n{'greeting': 'Hello'}\n</code></pre> Source code in <code>src/flask_x_openapi_schema/core/utils.py</code> <pre><code>def process_i18n_value(value: Any, language: str) -&gt; Any:\n    \"\"\"Process a value that might be an I18nString or contain I18nString values.\n\n    Recursively processes values that might be I18nString instances or contain\n    I18nString instances (in lists or dictionaries). For I18nString instances,\n    returns the string for the specified language.\n\n    Args:\n        value: The value to process, which might be an I18nString or contain I18nString values\n        language: The language code to use for extracting localized strings\n\n    Returns:\n        Any: The processed value with I18nString instances replaced by their\n            language-specific strings\n\n    Examples:\n        &gt;&gt;&gt; from flask_x_openapi_schema.i18n.i18n_string import I18nStr\n        &gt;&gt;&gt; i18n_str = I18nStr({\"en\": \"Hello\", \"fr\": \"Bonjour\"})\n        &gt;&gt;&gt; process_i18n_value(i18n_str, \"en\")\n        'Hello'\n        &gt;&gt;&gt; process_i18n_value(i18n_str, \"fr\")\n        'Bonjour'\n        &gt;&gt;&gt; process_i18n_value({\"greeting\": i18n_str}, \"en\")\n        {'greeting': 'Hello'}\n\n    \"\"\"\n    from flask_x_openapi_schema.i18n.i18n_string import I18nStr\n\n    if not isinstance(value, (I18nStr, dict, list)):\n        return value\n\n    if isinstance(value, I18nStr):\n        return value.get(language)\n    if isinstance(value, dict):\n        return process_i18n_dict(value, language)\n    if isinstance(value, list):\n        return [process_i18n_value(item, language) for item in value]\n    return value\n</code></pre>"},{"location":"api/core/#flask_x_openapi_schema.core.utils.pydantic_to_openapi_schema","title":"<code>pydantic_to_openapi_schema(model)</code>","text":"<p>Convert a Pydantic model to an OpenAPI schema.</p> <p>Extracts schema information from a Pydantic model and converts it to a format compatible with OpenAPI specifications. The function handles property types, required fields, and includes the model's docstring as the schema description.</p> <p>Parameters:</p> Name Type Description Default <code>model</code> <code>type[BaseModel]</code> <p>The Pydantic model class to convert to an OpenAPI schema</p> required <p>Returns:</p> Name Type Description <code>dict</code> <code>dict[str, Any]</code> <p>The OpenAPI schema representation of the model</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from pydantic import BaseModel, Field\n&gt;&gt;&gt; class User(BaseModel):\n...     '''A user model.'''\n...\n...     name: str = Field(..., description=\"The user's name\")\n...     age: int = Field(..., description=\"The user's age\")\n&gt;&gt;&gt; schema = pydantic_to_openapi_schema(User)\n&gt;&gt;&gt; schema[\"type\"]\n'object'\n&gt;&gt;&gt; \"name\" in schema[\"properties\"]\nTrue\n&gt;&gt;&gt; \"age\" in schema[\"properties\"]\nTrue\n&gt;&gt;&gt; schema[\"description\"]\n'A user model.'\n</code></pre> Source code in <code>src/flask_x_openapi_schema/core/utils.py</code> <pre><code>def pydantic_to_openapi_schema(model: type[BaseModel]) -&gt; dict[str, Any]:\n    \"\"\"Convert a Pydantic model to an OpenAPI schema.\n\n    Extracts schema information from a Pydantic model and converts it to a format\n    compatible with OpenAPI specifications. The function handles property types,\n    required fields, and includes the model's docstring as the schema description.\n\n    Args:\n        model: The Pydantic model class to convert to an OpenAPI schema\n\n    Returns:\n        dict: The OpenAPI schema representation of the model\n\n    Examples:\n        &gt;&gt;&gt; from pydantic import BaseModel, Field\n        &gt;&gt;&gt; class User(BaseModel):\n        ...     '''A user model.'''\n        ...\n        ...     name: str = Field(..., description=\"The user's name\")\n        ...     age: int = Field(..., description=\"The user's age\")\n        &gt;&gt;&gt; schema = pydantic_to_openapi_schema(User)\n        &gt;&gt;&gt; schema[\"type\"]\n        'object'\n        &gt;&gt;&gt; \"name\" in schema[\"properties\"]\n        True\n        &gt;&gt;&gt; \"age\" in schema[\"properties\"]\n        True\n        &gt;&gt;&gt; schema[\"description\"]\n        'A user model.'\n\n    \"\"\"\n    schema: dict[str, Any] = {\"type\": \"object\", \"properties\": {}, \"required\": []}\n\n    model_schema = model.model_json_schema()\n\n    if \"properties\" in model_schema:\n        properties = {}\n        for prop_name, prop_schema in model_schema[\"properties\"].items():\n            properties[prop_name] = _fix_references(prop_schema)\n        schema[\"properties\"] = properties\n\n    if \"required\" in model_schema:\n        schema[\"required\"] = model_schema[\"required\"]\n\n    if model.__doc__:\n        schema[\"description\"] = model.__doc__.strip()\n\n    return schema\n</code></pre>"},{"location":"api/core/#flask_x_openapi_schema.core.utils.python_type_to_openapi_type","title":"<code>python_type_to_openapi_type(python_type)</code>","text":"<p>Convert a Python type to an OpenAPI type.</p> <p>Maps Python types to their corresponding OpenAPI type definitions. Handles basic types, container types (lists, dicts), and special types like UUID and datetime. Also supports Union types and Pydantic models.</p> <p>Parameters:</p> Name Type Description Default <code>python_type</code> <code>Any</code> <p>The Python type to convert to an OpenAPI type</p> required <p>Returns:</p> Name Type Description <code>dict</code> <code>dict[str, Any]</code> <p>The OpenAPI type definition for the given Python type</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; python_type_to_openapi_type(str)\n{'type': 'string'}\n&gt;&gt;&gt; python_type_to_openapi_type(int)\n{'type': 'integer'}\n&gt;&gt;&gt; python_type_to_openapi_type(list[str])[\"type\"]\n'array'\n</code></pre> Source code in <code>src/flask_x_openapi_schema/core/utils.py</code> <pre><code>def python_type_to_openapi_type(python_type: Any) -&gt; dict[str, Any]:\n    \"\"\"Convert a Python type to an OpenAPI type.\n\n    Maps Python types to their corresponding OpenAPI type definitions. Handles\n    basic types, container types (lists, dicts), and special types like UUID\n    and datetime. Also supports Union types and Pydantic models.\n\n    Args:\n        python_type: The Python type to convert to an OpenAPI type\n\n    Returns:\n        dict: The OpenAPI type definition for the given Python type\n\n    Examples:\n        &gt;&gt;&gt; python_type_to_openapi_type(str)\n        {'type': 'string'}\n        &gt;&gt;&gt; python_type_to_openapi_type(int)\n        {'type': 'integer'}\n        &gt;&gt;&gt; python_type_to_openapi_type(list[str])[\"type\"]\n        'array'\n\n    \"\"\"\n    from .config import get_openapi_config\n\n    config = get_openapi_config()\n    is_openapi_31 = config.openapi_version.startswith(\"3.1\")\n\n    if python_type is str:\n        return {\"type\": \"string\"}\n    if python_type is int:\n        return {\"type\": \"integer\"}\n    if python_type is float:\n        return {\"type\": \"number\"}\n    if python_type is bool:\n        return {\"type\": \"boolean\"}\n    if python_type is None or python_type is type(None):\n        return {\"type\": \"null\"} if is_openapi_31 else {\"nullable\": True}\n\n    origin = getattr(python_type, \"__origin__\", None)\n    if python_type is list or origin is list:\n        args = getattr(python_type, \"__args__\", [])\n        if args:\n            item_type = python_type_to_openapi_type(args[0])\n            return {\"type\": \"array\", \"items\": item_type}\n        return {\"type\": \"array\"}\n    if python_type is dict or origin is dict:\n        args = getattr(python_type, \"__args__\", [])\n        if len(args) == 2 and is_openapi_31 and args[0] is str:\n            value_type = python_type_to_openapi_type(args[1])\n            return {\"type\": \"object\", \"additionalProperties\": value_type}\n        return {\"type\": \"object\"}\n\n    if python_type == UUID:\n        return {\"type\": \"string\", \"format\": \"uuid\"}\n    if python_type == datetime:\n        return {\"type\": \"string\", \"format\": \"date-time\"}\n    if python_type == date:\n        return {\"type\": \"string\", \"format\": \"date\"}\n    if python_type == time:\n        return {\"type\": \"string\", \"format\": \"time\"}\n\n    if inspect.isclass(python_type):\n        if issubclass(python_type, Enum):\n            return {\"type\": \"string\", \"enum\": [e.value for e in python_type]}\n        if issubclass(python_type, BaseModel):\n            return {\"$ref\": f\"#/components/schemas/{python_type.__name__}\"}\n\n    if origin is Union:\n        args = getattr(python_type, \"__args__\", [])\n        if len(args) == 2 and args[1] is type(None):\n            inner_type = python_type_to_openapi_type(args[0])\n            if is_openapi_31:\n                if \"type\" in inner_type:\n                    if isinstance(inner_type[\"type\"], list):\n                        if \"null\" not in inner_type[\"type\"]:\n                            inner_type[\"type\"].append(\"null\")\n                    else:\n                        inner_type[\"type\"] = [inner_type[\"type\"], \"null\"]\n                else:\n                    inner_type = {\"oneOf\": [inner_type, {\"type\": \"null\"}]}\n            else:\n                inner_type[\"nullable\"] = True\n            return inner_type\n\n        if is_openapi_31 and len(args) &gt; 1:\n            return {\"oneOf\": [python_type_to_openapi_type(arg) for arg in args]}\n\n    return {\"type\": \"string\"}\n</code></pre>"},{"location":"api/core/#flask_x_openapi_schema.core.utils.response_schema","title":"<code>response_schema(model, description, status_code=200)</code>","text":"<p>Generate an OpenAPI response schema for a Pydantic model.</p> <p>Creates an OpenAPI response object that references a Pydantic model schema. The response includes a description and specifies that the content type is application/json.</p> <p>Parameters:</p> Name Type Description Default <code>model</code> <code>type[BaseModel]</code> <p>The Pydantic model to use for the response schema</p> required <code>description</code> <code>str</code> <p>Description of the response</p> required <code>status_code</code> <code>int | str</code> <p>HTTP status code for the response (default: 200)</p> <code>200</code> <p>Returns:</p> Name Type Description <code>dict</code> <code>dict[str, Any]</code> <p>An OpenAPI response schema object</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from pydantic import BaseModel\n&gt;&gt;&gt; class User(BaseModel):\n...     name: str\n...     age: int\n&gt;&gt;&gt; schema = response_schema(User, \"A user object\", 200)\n&gt;&gt;&gt; schema[\"200\"][\"description\"]\n'A user object'\n&gt;&gt;&gt; schema[\"200\"][\"content\"][\"application/json\"][\"schema\"][\"$ref\"]\n'#/components/schemas/User'\n</code></pre> Source code in <code>src/flask_x_openapi_schema/core/utils.py</code> <pre><code>def response_schema(\n    model: type[BaseModel],\n    description: str,\n    status_code: int | str = 200,\n) -&gt; dict[str, Any]:\n    \"\"\"Generate an OpenAPI response schema for a Pydantic model.\n\n    Creates an OpenAPI response object that references a Pydantic model schema.\n    The response includes a description and specifies that the content type is\n    application/json.\n\n    Args:\n        model: The Pydantic model to use for the response schema\n        description: Description of the response\n        status_code: HTTP status code for the response (default: 200)\n\n    Returns:\n        dict: An OpenAPI response schema object\n\n    Examples:\n        &gt;&gt;&gt; from pydantic import BaseModel\n        &gt;&gt;&gt; class User(BaseModel):\n        ...     name: str\n        ...     age: int\n        &gt;&gt;&gt; schema = response_schema(User, \"A user object\", 200)\n        &gt;&gt;&gt; schema[\"200\"][\"description\"]\n        'A user object'\n        &gt;&gt;&gt; schema[\"200\"][\"content\"][\"application/json\"][\"schema\"][\"$ref\"]\n        '#/components/schemas/User'\n\n    \"\"\"\n    return {\n        str(status_code): {\n            \"description\": description,\n            \"content\": {\"application/json\": {\"schema\": {\"$ref\": f\"#/components/schemas/{model.__name__}\"}}},\n        },\n    }\n</code></pre>"},{"location":"api/core/#flask_x_openapi_schema.core.utils.responses_schema","title":"<code>responses_schema(success_responses, errors=None)</code>","text":"<p>Generate a complete OpenAPI responses schema with success and error responses.</p> <p>Creates a comprehensive OpenAPI responses object that includes both success responses (with schemas) and error responses. This is useful for documenting all possible responses from an API endpoint.</p> <p>Parameters:</p> Name Type Description Default <code>success_responses</code> <code>dict[int | str, tuple[type[BaseModel], str]]</code> <p>Dictionary mapping status codes to (model, description) tuples for success responses</p> required <code>errors</code> <code>dict[int | str, str] | None</code> <p>Optional dictionary mapping status codes to descriptions for error responses</p> <code>None</code> <p>Returns:</p> Name Type Description <code>dict</code> <code>dict[str, Any]</code> <p>A complete OpenAPI responses schema object</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from pydantic import BaseModel\n&gt;&gt;&gt; class User(BaseModel):\n...     name: str\n&gt;&gt;&gt; class Error(BaseModel):\n...     message: str\n&gt;&gt;&gt; success = {200: success_response(User, \"Success\")}\n&gt;&gt;&gt; errors = {400: \"Bad Request\", 404: \"Not Found\"}\n&gt;&gt;&gt; schema = responses_schema(success, errors)\n&gt;&gt;&gt; \"200\" in schema and \"400\" in schema and \"404\" in schema\nTrue\n</code></pre> Source code in <code>src/flask_x_openapi_schema/core/utils.py</code> <pre><code>def responses_schema(\n    success_responses: dict[int | str, tuple[type[BaseModel], str]],\n    errors: dict[int | str, str] | None = None,\n) -&gt; dict[str, Any]:\n    \"\"\"Generate a complete OpenAPI responses schema with success and error responses.\n\n    Creates a comprehensive OpenAPI responses object that includes both success\n    responses (with schemas) and error responses. This is useful for documenting\n    all possible responses from an API endpoint.\n\n    Args:\n        success_responses: Dictionary mapping status codes to (model, description)\n            tuples for success responses\n        errors: Optional dictionary mapping status codes to descriptions for error\n            responses\n\n    Returns:\n        dict: A complete OpenAPI responses schema object\n\n    Examples:\n        &gt;&gt;&gt; from pydantic import BaseModel\n        &gt;&gt;&gt; class User(BaseModel):\n        ...     name: str\n        &gt;&gt;&gt; class Error(BaseModel):\n        ...     message: str\n        &gt;&gt;&gt; success = {200: success_response(User, \"Success\")}\n        &gt;&gt;&gt; errors = {400: \"Bad Request\", 404: \"Not Found\"}\n        &gt;&gt;&gt; schema = responses_schema(success, errors)\n        &gt;&gt;&gt; \"200\" in schema and \"400\" in schema and \"404\" in schema\n        True\n\n    \"\"\"\n    responses = {}\n\n    for status_code, (model, description) in success_responses.items():\n        responses.update(response_schema(model, description, status_code))\n\n    if errors:\n        for status_code, description in errors.items():\n            responses.update(error_response_schema(description, status_code))\n\n    return responses\n</code></pre>"},{"location":"api/core/#flask_x_openapi_schema.core.utils.success_response","title":"<code>success_response(model, description)</code>","text":"<p>Create a success response tuple for use with responses_schema.</p> <p>Helper function that creates a tuple containing a model and description, which can be used with the responses_schema function to generate complete OpenAPI response schemas.</p> <p>Parameters:</p> Name Type Description Default <code>model</code> <code>type[BaseModel]</code> <p>The Pydantic model to use for the response schema</p> required <code>description</code> <code>str</code> <p>Description of the response</p> required <p>Returns:</p> Name Type Description <code>tuple</code> <code>tuple[type[BaseModel], str]</code> <p>A tuple of (model, description) for use with responses_schema</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from pydantic import BaseModel\n&gt;&gt;&gt; class User(BaseModel):\n...     name: str\n&gt;&gt;&gt; response = success_response(User, \"A user object\")\n&gt;&gt;&gt; response[0] == User\nTrue\n&gt;&gt;&gt; response[1]\n'A user object'\n</code></pre> Source code in <code>src/flask_x_openapi_schema/core/utils.py</code> <pre><code>def success_response(\n    model: type[BaseModel],\n    description: str,\n) -&gt; tuple[type[BaseModel], str]:\n    \"\"\"Create a success response tuple for use with responses_schema.\n\n    Helper function that creates a tuple containing a model and description,\n    which can be used with the responses_schema function to generate complete\n    OpenAPI response schemas.\n\n    Args:\n        model: The Pydantic model to use for the response schema\n        description: Description of the response\n\n    Returns:\n        tuple: A tuple of (model, description) for use with responses_schema\n\n    Examples:\n        &gt;&gt;&gt; from pydantic import BaseModel\n        &gt;&gt;&gt; class User(BaseModel):\n        ...     name: str\n        &gt;&gt;&gt; response = success_response(User, \"A user object\")\n        &gt;&gt;&gt; response[0] == User\n        True\n        &gt;&gt;&gt; response[1]\n        'A user object'\n\n    \"\"\"\n    return (model, description)\n</code></pre>"},{"location":"api/flask/","title":"Flask Integration","text":"<p>This section provides documentation for the Flask-specific components of Flask-X-OpenAPI-Schema.</p>"},{"location":"api/flask/#flask-module","title":"Flask Module","text":"<p>Flask-specific implementations for OpenAPI schema generation.</p>"},{"location":"api/flask/#flask_x_openapi_schema.x.flask.OpenAPIMethodViewMixin","title":"<code>OpenAPIMethodViewMixin</code>","text":"<p>A mixin class for Flask.MethodView to collect OpenAPI metadata.</p> <p>This mixin class adds OpenAPI schema generation capabilities to Flask's MethodView. It provides a method to register the view to a blueprint while collecting metadata for OpenAPI schema generation.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from flask import Blueprint\n&gt;&gt;&gt; from flask.views import MethodView\n&gt;&gt;&gt; from flask_x_openapi_schema.x.flask import OpenAPIMethodViewMixin, openapi_metadata\n&gt;&gt;&gt; from pydantic import BaseModel, Field\n&gt;&gt;&gt;\n&gt;&gt;&gt; class ItemResponse(BaseModel):\n...     id: str = Field(..., description=\"Item ID\")\n...     name: str = Field(..., description=\"Item name\")\n&gt;&gt;&gt;\n&gt;&gt;&gt; class ItemView(OpenAPIMethodViewMixin, MethodView):\n...     @openapi_metadata(summary=\"Get an item\")\n...     def get(self, item_id: str):\n...         return {\"id\": item_id, \"name\": \"Example Item\"}\n&gt;&gt;&gt;\n&gt;&gt;&gt; bp = Blueprint(\"items\", __name__)\n&gt;&gt;&gt; # Register the view to the blueprint\n&gt;&gt;&gt; _ = ItemView.register_to_blueprint(bp, \"/items/&lt;item_id&gt;\")\n</code></pre> Source code in <code>src/flask_x_openapi_schema/x/flask/views.py</code> <pre><code>class OpenAPIMethodViewMixin:\n    \"\"\"A mixin class for Flask.MethodView to collect OpenAPI metadata.\n\n    This mixin class adds OpenAPI schema generation capabilities to Flask's MethodView.\n    It provides a method to register the view to a blueprint while collecting metadata\n    for OpenAPI schema generation.\n\n    Examples:\n        &gt;&gt;&gt; from flask import Blueprint\n        &gt;&gt;&gt; from flask.views import MethodView\n        &gt;&gt;&gt; from flask_x_openapi_schema.x.flask import OpenAPIMethodViewMixin, openapi_metadata\n        &gt;&gt;&gt; from pydantic import BaseModel, Field\n        &gt;&gt;&gt;\n        &gt;&gt;&gt; class ItemResponse(BaseModel):\n        ...     id: str = Field(..., description=\"Item ID\")\n        ...     name: str = Field(..., description=\"Item name\")\n        &gt;&gt;&gt;\n        &gt;&gt;&gt; class ItemView(OpenAPIMethodViewMixin, MethodView):\n        ...     @openapi_metadata(summary=\"Get an item\")\n        ...     def get(self, item_id: str):\n        ...         return {\"id\": item_id, \"name\": \"Example Item\"}\n        &gt;&gt;&gt;\n        &gt;&gt;&gt; bp = Blueprint(\"items\", __name__)\n        &gt;&gt;&gt; # Register the view to the blueprint\n        &gt;&gt;&gt; _ = ItemView.register_to_blueprint(bp, \"/items/&lt;item_id&gt;\")\n\n    \"\"\"\n\n    @classmethod\n    def register_to_blueprint(cls, blueprint: Any, url: str, endpoint: str | None = None, **kwargs: Any) -&gt; Any:\n        \"\"\"Register the MethodView to a blueprint and collect OpenAPI metadata.\n\n        This method registers the view to a blueprint and stores metadata for\n        OpenAPI schema generation.\n\n        Args:\n            blueprint: The Flask blueprint to register to\n            url: The URL rule to register\n            endpoint: The endpoint name (defaults to the class name)\n            **kwargs: Additional arguments to pass to add_url_rule\n\n        Returns:\n            Any: The view function\n\n        Examples:\n            &gt;&gt;&gt; from flask import Blueprint\n            &gt;&gt;&gt; from flask.views import MethodView\n            &gt;&gt;&gt; from flask_x_openapi_schema.x.flask import OpenAPIMethodViewMixin\n            &gt;&gt;&gt; class ItemView(OpenAPIMethodViewMixin, MethodView):\n            ...     def get(self, item_id: str):\n            ...         return {\"id\": item_id, \"name\": \"Example Item\"}\n            &gt;&gt;&gt; bp = Blueprint(\"items\", __name__)\n            &gt;&gt;&gt; # Register the view to the blueprint\n            &gt;&gt;&gt; _ = ItemView.register_to_blueprint(bp, \"/items/&lt;item_id&gt;\")\n\n        \"\"\"\n        view_func = cls.as_view(endpoint or cls.__name__.lower())\n        blueprint.add_url_rule(url, view_func=view_func, **kwargs)\n\n        if not hasattr(blueprint, \"_methodview_openapi_resources\"):\n            blueprint._methodview_openapi_resources = []\n\n        blueprint._methodview_openapi_resources.append((cls, url))\n\n        return view_func\n</code></pre>"},{"location":"api/flask/#flask_x_openapi_schema.x.flask.OpenAPIMethodViewMixin.register_to_blueprint","title":"<code>register_to_blueprint(blueprint, url, endpoint=None, **kwargs)</code>  <code>classmethod</code>","text":"<p>Register the MethodView to a blueprint and collect OpenAPI metadata.</p> <p>This method registers the view to a blueprint and stores metadata for OpenAPI schema generation.</p> <p>Parameters:</p> Name Type Description Default <code>blueprint</code> <code>Any</code> <p>The Flask blueprint to register to</p> required <code>url</code> <code>str</code> <p>The URL rule to register</p> required <code>endpoint</code> <code>str | None</code> <p>The endpoint name (defaults to the class name)</p> <code>None</code> <code>**kwargs</code> <code>Any</code> <p>Additional arguments to pass to add_url_rule</p> <code>{}</code> <p>Returns:</p> Name Type Description <code>Any</code> <code>Any</code> <p>The view function</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from flask import Blueprint\n&gt;&gt;&gt; from flask.views import MethodView\n&gt;&gt;&gt; from flask_x_openapi_schema.x.flask import OpenAPIMethodViewMixin\n&gt;&gt;&gt; class ItemView(OpenAPIMethodViewMixin, MethodView):\n...     def get(self, item_id: str):\n...         return {\"id\": item_id, \"name\": \"Example Item\"}\n&gt;&gt;&gt; bp = Blueprint(\"items\", __name__)\n&gt;&gt;&gt; # Register the view to the blueprint\n&gt;&gt;&gt; _ = ItemView.register_to_blueprint(bp, \"/items/&lt;item_id&gt;\")\n</code></pre> Source code in <code>src/flask_x_openapi_schema/x/flask/views.py</code> <pre><code>@classmethod\ndef register_to_blueprint(cls, blueprint: Any, url: str, endpoint: str | None = None, **kwargs: Any) -&gt; Any:\n    \"\"\"Register the MethodView to a blueprint and collect OpenAPI metadata.\n\n    This method registers the view to a blueprint and stores metadata for\n    OpenAPI schema generation.\n\n    Args:\n        blueprint: The Flask blueprint to register to\n        url: The URL rule to register\n        endpoint: The endpoint name (defaults to the class name)\n        **kwargs: Additional arguments to pass to add_url_rule\n\n    Returns:\n        Any: The view function\n\n    Examples:\n        &gt;&gt;&gt; from flask import Blueprint\n        &gt;&gt;&gt; from flask.views import MethodView\n        &gt;&gt;&gt; from flask_x_openapi_schema.x.flask import OpenAPIMethodViewMixin\n        &gt;&gt;&gt; class ItemView(OpenAPIMethodViewMixin, MethodView):\n        ...     def get(self, item_id: str):\n        ...         return {\"id\": item_id, \"name\": \"Example Item\"}\n        &gt;&gt;&gt; bp = Blueprint(\"items\", __name__)\n        &gt;&gt;&gt; # Register the view to the blueprint\n        &gt;&gt;&gt; _ = ItemView.register_to_blueprint(bp, \"/items/&lt;item_id&gt;\")\n\n    \"\"\"\n    view_func = cls.as_view(endpoint or cls.__name__.lower())\n    blueprint.add_url_rule(url, view_func=view_func, **kwargs)\n\n    if not hasattr(blueprint, \"_methodview_openapi_resources\"):\n        blueprint._methodview_openapi_resources = []\n\n    blueprint._methodview_openapi_resources.append((cls, url))\n\n    return view_func\n</code></pre>"},{"location":"api/flask/#flask_x_openapi_schema.x.flask.openapi_metadata","title":"<code>openapi_metadata(*, summary=None, description=None, tags=None, operation_id=None, responses=None, deprecated=False, security=None, external_docs=None, language=None, prefix_config=None, content_type=None, request_content_types=None, response_content_types=None, content_type_resolver=None)</code>","text":"<p>Decorator to add OpenAPI metadata to a Flask MethodView endpoint.</p> <p>This decorator adds OpenAPI metadata to a Flask MethodView endpoint and handles parameter binding for request data. It automatically binds request body, query parameters, path parameters, and file uploads to function parameters based on their type annotations and parameter name prefixes.</p> <p>Parameters:</p> Name Type Description Default <code>summary</code> <code>str | I18nStr | None</code> <p>A short summary of what the operation does</p> <code>None</code> <code>description</code> <code>str | I18nStr | None</code> <p>A verbose explanation of the operation behavior</p> <code>None</code> <code>tags</code> <code>list[str] | None</code> <p>A list of tags for API documentation control</p> <code>None</code> <code>operation_id</code> <code>str | None</code> <p>Unique string used to identify the operation</p> <code>None</code> <code>responses</code> <code>OpenAPIMetaResponse | None</code> <p>The responses the API can return</p> <code>None</code> <code>deprecated</code> <code>bool</code> <p>Declares this operation to be deprecated</p> <code>False</code> <code>security</code> <code>list[dict[str, list[str]]] | None</code> <p>A declaration of which security mechanisms can be used for this operation</p> <code>None</code> <code>external_docs</code> <code>dict[str, str] | None</code> <p>Additional external documentation</p> <code>None</code> <code>language</code> <code>str | None</code> <p>Language code to use for I18nString values (default: current language)</p> <code>None</code> <code>prefix_config</code> <code>ConventionalPrefixConfig | None</code> <p>Configuration object for parameter prefixes</p> <code>None</code> <code>content_type</code> <code>str | None</code> <p>Custom content type for request body. If None, will be auto-detected.</p> <code>None</code> <code>request_content_types</code> <code>RequestContentTypes | None</code> <p>Multiple content types for request body.</p> <code>None</code> <code>response_content_types</code> <code>ResponseContentTypes | None</code> <p>Multiple content types for response body.</p> <code>None</code> <code>content_type_resolver</code> <code>Callable[[Any], str] | None</code> <p>Function to determine content type based on request.</p> <code>None</code> <p>Returns:</p> Type Description <code>Callable[[F], F]</code> <p>The decorated function with OpenAPI metadata attached</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from flask.views import MethodView\n&gt;&gt;&gt; from flask_x_openapi_schema.x.flask import openapi_metadata\n&gt;&gt;&gt; from flask_x_openapi_schema import OpenAPIMetaResponse, OpenAPIMetaResponseItem\n&gt;&gt;&gt; from pydantic import BaseModel, Field\n&gt;&gt;&gt;\n&gt;&gt;&gt; class ItemRequest(BaseModel):\n...     name: str = Field(..., description=\"Item name\")\n...     price: float = Field(..., description=\"Item price\")\n&gt;&gt;&gt;\n&gt;&gt;&gt; class ItemResponse(BaseModel):\n...     id: str = Field(..., description=\"Item ID\")\n...     name: str = Field(..., description=\"Item name\")\n...     price: float = Field(..., description=\"Item price\")\n&gt;&gt;&gt;\n&gt;&gt;&gt; class ItemView(MethodView):\n...     @openapi_metadata(\n...         summary=\"Create a new item\",\n...         description=\"Create a new item with the provided information\",\n...         tags=[\"items\"],\n...         operation_id=\"createItem\",\n...         responses=OpenAPIMetaResponse(\n...             responses={\n...                 \"201\": OpenAPIMetaResponseItem(model=ItemResponse, description=\"Item created successfully\"),\n...                 \"400\": OpenAPIMetaResponseItem(description=\"Invalid request data\"),\n...             }\n...         ),\n...     )\n...     def post(self, _x_body: ItemRequest):\n...         item = {\"id\": \"123\", \"name\": _x_body.name, \"price\": _x_body.price}\n...         return item, 201\n</code></pre> Source code in <code>src/flask_x_openapi_schema/x/flask/decorators.py</code> <pre><code>def openapi_metadata(\n    *,\n    summary: str | I18nStr | None = None,\n    description: str | I18nStr | None = None,\n    tags: list[str] | None = None,\n    operation_id: str | None = None,\n    responses: OpenAPIMetaResponse | None = None,\n    deprecated: bool = False,\n    security: list[dict[str, list[str]]] | None = None,\n    external_docs: dict[str, str] | None = None,\n    language: str | None = None,\n    prefix_config: ConventionalPrefixConfig | None = None,\n    content_type: str | None = None,\n    request_content_types: RequestContentTypes | None = None,\n    response_content_types: ResponseContentTypes | None = None,\n    content_type_resolver: Callable[[Any], str] | None = None,\n) -&gt; Callable[[F], F]:\n    \"\"\"Decorator to add OpenAPI metadata to a Flask MethodView endpoint.\n\n    This decorator adds OpenAPI metadata to a Flask MethodView endpoint and handles\n    parameter binding for request data. It automatically binds request body, query parameters,\n    path parameters, and file uploads to function parameters based on their type annotations\n    and parameter name prefixes.\n\n    Args:\n        summary: A short summary of what the operation does\n        description: A verbose explanation of the operation behavior\n        tags: A list of tags for API documentation control\n        operation_id: Unique string used to identify the operation\n        responses: The responses the API can return\n        deprecated: Declares this operation to be deprecated\n        security: A declaration of which security mechanisms can be used for this operation\n        external_docs: Additional external documentation\n        language: Language code to use for I18nString values (default: current language)\n        prefix_config: Configuration object for parameter prefixes\n        content_type: Custom content type for request body. If None, will be auto-detected.\n        request_content_types: Multiple content types for request body.\n        response_content_types: Multiple content types for response body.\n        content_type_resolver: Function to determine content type based on request.\n\n\n    Returns:\n        The decorated function with OpenAPI metadata attached\n\n    Examples:\n        &gt;&gt;&gt; from flask.views import MethodView\n        &gt;&gt;&gt; from flask_x_openapi_schema.x.flask import openapi_metadata\n        &gt;&gt;&gt; from flask_x_openapi_schema import OpenAPIMetaResponse, OpenAPIMetaResponseItem\n        &gt;&gt;&gt; from pydantic import BaseModel, Field\n        &gt;&gt;&gt;\n        &gt;&gt;&gt; class ItemRequest(BaseModel):\n        ...     name: str = Field(..., description=\"Item name\")\n        ...     price: float = Field(..., description=\"Item price\")\n        &gt;&gt;&gt;\n        &gt;&gt;&gt; class ItemResponse(BaseModel):\n        ...     id: str = Field(..., description=\"Item ID\")\n        ...     name: str = Field(..., description=\"Item name\")\n        ...     price: float = Field(..., description=\"Item price\")\n        &gt;&gt;&gt;\n        &gt;&gt;&gt; class ItemView(MethodView):\n        ...     @openapi_metadata(\n        ...         summary=\"Create a new item\",\n        ...         description=\"Create a new item with the provided information\",\n        ...         tags=[\"items\"],\n        ...         operation_id=\"createItem\",\n        ...         responses=OpenAPIMetaResponse(\n        ...             responses={\n        ...                 \"201\": OpenAPIMetaResponseItem(model=ItemResponse, description=\"Item created successfully\"),\n        ...                 \"400\": OpenAPIMetaResponseItem(description=\"Invalid request data\"),\n        ...             }\n        ...         ),\n        ...     )\n        ...     def post(self, _x_body: ItemRequest):\n        ...         item = {\"id\": \"123\", \"name\": _x_body.name, \"price\": _x_body.price}\n        ...         return item, 201\n\n    \"\"\"\n    return FlaskOpenAPIDecorator(\n        summary=summary,\n        description=description,\n        tags=tags,\n        operation_id=operation_id,\n        responses=responses,\n        deprecated=deprecated,\n        security=security,\n        external_docs=external_docs,\n        language=language,\n        prefix_config=prefix_config,\n        content_type=content_type,\n        request_content_types=request_content_types,\n        response_content_types=response_content_types,\n        content_type_resolver=content_type_resolver,\n    )\n</code></pre>"},{"location":"api/flask/#decorators","title":"Decorators","text":"<p>Decorators for adding OpenAPI metadata to Flask MethodView endpoints.</p> <p>This module provides decorators that can be used to add OpenAPI metadata to Flask MethodView endpoints. The decorators handle parameter binding for request data, including request body, query parameters, path parameters, and file uploads.</p>"},{"location":"api/flask/#flask_x_openapi_schema.x.flask.decorators.FlaskOpenAPIDecorator","title":"<code>FlaskOpenAPIDecorator</code>","text":"<p>               Bases: <code>DecoratorBase</code></p> <p>OpenAPI metadata decorator for Flask MethodView.</p> <p>This class implements a decorator that adds OpenAPI metadata to Flask MethodView endpoints and handles parameter binding for request data.</p> Source code in <code>src/flask_x_openapi_schema/x/flask/decorators.py</code> <pre><code>class FlaskOpenAPIDecorator(DecoratorBase):\n    \"\"\"OpenAPI metadata decorator for Flask MethodView.\n\n    This class implements a decorator that adds OpenAPI metadata to Flask MethodView\n    endpoints and handles parameter binding for request data.\n    \"\"\"\n\n    def __init__(\n        self,\n        summary: str | I18nStr | None = None,\n        description: str | I18nStr | None = None,\n        tags: list[str] | None = None,\n        operation_id: str | None = None,\n        responses: OpenAPIMetaResponse | None = None,\n        deprecated: bool = False,\n        security: list[dict[str, list[str]]] | None = None,\n        external_docs: dict[str, str] | None = None,\n        language: str | None = None,\n        prefix_config: ConventionalPrefixConfig | None = None,\n        content_type: str | None = None,\n        request_content_types: RequestContentTypes | None = None,\n        response_content_types: ResponseContentTypes | None = None,\n        content_type_resolver: Callable[[Any], str] | None = None,\n    ) -&gt; None:\n        \"\"\"Initialize the decorator with OpenAPI metadata parameters.\n\n        Args:\n            summary: A short summary of what the operation does\n            description: A verbose explanation of the operation behavior\n            tags: A list of tags for API documentation control\n            operation_id: Unique string used to identify the operation\n            responses: The responses the API can return\n            deprecated: Declares this operation to be deprecated\n            security: A declaration of which security mechanisms can be used for this operation\n            external_docs: Additional external documentation\n            language: Language code to use for I18nString values\n            prefix_config: Configuration object for parameter prefixes\n            content_type: Custom content type for request body. If None, will be auto-detected.\n            request_content_types: Multiple content types for request body.\n            response_content_types: Multiple content types for response body.\n            content_type_resolver: Function to determine content type based on request.\n\n        \"\"\"\n        super().__init__(\n            summary=summary,\n            description=description,\n            tags=tags,\n            operation_id=operation_id,\n            responses=responses,\n            deprecated=deprecated,\n            security=security,\n            external_docs=external_docs,\n            language=language,\n            prefix_config=prefix_config,\n            content_type=content_type,\n            request_content_types=request_content_types,\n            response_content_types=response_content_types,\n            content_type_resolver=content_type_resolver,\n        )\n        self.framework = \"flask\"\n        self.base_decorator = None\n\n    def __call__(self, func: Callable) -&gt; Callable:\n        \"\"\"Apply the decorator to the function.\n\n        Args:\n            func: The function to decorate\n\n        Returns:\n            The decorated function\n\n        \"\"\"\n        if self.base_decorator is None:\n            self.base_decorator = OpenAPIDecoratorBase(\n                summary=self.summary,\n                description=self.description,\n                tags=self.tags,\n                operation_id=self.operation_id,\n                responses=self.responses,\n                deprecated=self.deprecated,\n                security=self.security,\n                external_docs=self.external_docs,\n                language=self.language,\n                prefix_config=self.prefix_config,\n                framework=self.framework,\n                content_type=self.content_type,\n                request_content_types=self.request_content_types,\n                response_content_types=self.response_content_types,\n                content_type_resolver=self.content_type_resolver,\n            )\n        return self.base_decorator(func)\n\n    def extract_parameters_from_models(\n        self,\n        query_model: type[BaseModel] | None,\n        path_params: list[str] | None,\n    ) -&gt; list[dict[str, Any]]:\n        \"\"\"Extract OpenAPI parameters from models.\n\n        Args:\n            query_model: The query parameter model\n            path_params: List of path parameter names\n\n        Returns:\n            List of OpenAPI parameter objects\n\n        \"\"\"\n        parameters = [\n            {\n                \"name\": param,\n                \"in\": \"path\",\n                \"required\": True,\n                \"schema\": {\"type\": \"string\"},\n            }\n            for param in path_params\n        ]\n\n        if query_model:\n            schema = query_model.model_json_schema()\n            properties = schema.get(\"properties\", {})\n            required = schema.get(\"required\", [])\n\n            for field_name, field_schema in properties.items():\n                param = {\n                    \"name\": field_name,\n                    \"in\": \"query\",\n                    \"required\": field_name in required,\n                    \"schema\": field_schema,\n                }\n\n                if \"description\" in field_schema:\n                    param[\"description\"] = field_schema[\"description\"]\n\n                parameters.append(param)\n\n        return parameters\n\n    def process_request_body(self, param_name: str, model: type[BaseModel], kwargs: dict[str, Any]) -&gt; dict[str, Any]:\n        \"\"\"Process request body parameters for Flask.\n\n        Args:\n            param_name: The parameter name to bind the model instance to\n            model: The Pydantic model class to use for validation\n            kwargs: The keyword arguments to update\n\n        Returns:\n            Updated kwargs dictionary with the model instance\n\n        \"\"\"\n        from flask import request\n\n        from flask_x_openapi_schema.models.file_models import FileField\n\n        if hasattr(model, \"model_fields\") and hasattr(request, \"files\") and request.files:\n            has_file_fields = False\n            for field_info in model.model_fields.values():\n                field_type = field_info.annotation\n\n                if isinstance(field_type, type) and issubclass(field_type, FileField):\n                    has_file_fields = True\n                    break\n\n                origin = getattr(field_type, \"__origin__\", None)\n                if origin is list or origin is list:\n                    args = getattr(field_type, \"__args__\", [])\n                    if args and isinstance(args[0], type) and issubclass(args[0], FileField):\n                        has_file_fields = True\n                        break\n\n            if has_file_fields:\n                model_data = dict(request.form.items())\n                for field_name in model.model_fields:\n                    if field_name in request.files:\n                        model_data[field_name] = request.files[field_name]\n\n                if model_data:\n                    try:\n                        model_instance = model(**model_data)\n                        kwargs[param_name] = model_instance\n                    except Exception as e:\n                        logger = get_logger(__name__)\n                        logger.exception(\n                            f\"Failed to create model instance with mock files for {model.__name__}\", exc_info=e\n                        )\n                    else:\n                        return kwargs\n\n        return super().process_request_body(param_name, model, kwargs)\n\n    def process_query_params(self, param_name: str, model: type[BaseModel], kwargs: dict[str, Any]) -&gt; dict[str, Any]:\n        \"\"\"Process query parameters for Flask.\n\n        Args:\n            param_name: The parameter name to bind the model instance to\n            model: The Pydantic model class to use for validation\n            kwargs: The keyword arguments to update\n\n        Returns:\n            Updated kwargs dictionary with the model instance\n\n        \"\"\"\n        query_data = {}\n        model_fields = model.model_fields\n\n        for field_name in model_fields:\n            if field_name in request.args:\n                query_data[field_name] = request.args.get(field_name)\n\n        model_instance = model(**query_data)\n\n        kwargs[param_name] = model_instance\n\n        return kwargs\n\n    def process_additional_params(self, kwargs: dict[str, Any], param_names: list[str]) -&gt; dict[str, Any]:\n        \"\"\"Process additional framework-specific parameters.\n\n        Args:\n            kwargs: The keyword arguments to update\n            param_names: List of parameter names that have been processed\n\n        Returns:\n            Updated kwargs dictionary\n\n        \"\"\"\n        logger = get_logger(__name__)\n        logger.debug(f\"Processing additional parameters with kwargs keys: {list(kwargs.keys())}\")\n        logger.debug(f\"Processed parameter names: {param_names}\")\n        return kwargs\n</code></pre>"},{"location":"api/flask/#flask_x_openapi_schema.x.flask.decorators.FlaskOpenAPIDecorator.__call__","title":"<code>__call__(func)</code>","text":"<p>Apply the decorator to the function.</p> <p>Parameters:</p> Name Type Description Default <code>func</code> <code>Callable</code> <p>The function to decorate</p> required <p>Returns:</p> Type Description <code>Callable</code> <p>The decorated function</p> Source code in <code>src/flask_x_openapi_schema/x/flask/decorators.py</code> <pre><code>def __call__(self, func: Callable) -&gt; Callable:\n    \"\"\"Apply the decorator to the function.\n\n    Args:\n        func: The function to decorate\n\n    Returns:\n        The decorated function\n\n    \"\"\"\n    if self.base_decorator is None:\n        self.base_decorator = OpenAPIDecoratorBase(\n            summary=self.summary,\n            description=self.description,\n            tags=self.tags,\n            operation_id=self.operation_id,\n            responses=self.responses,\n            deprecated=self.deprecated,\n            security=self.security,\n            external_docs=self.external_docs,\n            language=self.language,\n            prefix_config=self.prefix_config,\n            framework=self.framework,\n            content_type=self.content_type,\n            request_content_types=self.request_content_types,\n            response_content_types=self.response_content_types,\n            content_type_resolver=self.content_type_resolver,\n        )\n    return self.base_decorator(func)\n</code></pre>"},{"location":"api/flask/#flask_x_openapi_schema.x.flask.decorators.FlaskOpenAPIDecorator.__init__","title":"<code>__init__(summary=None, description=None, tags=None, operation_id=None, responses=None, deprecated=False, security=None, external_docs=None, language=None, prefix_config=None, content_type=None, request_content_types=None, response_content_types=None, content_type_resolver=None)</code>","text":"<p>Initialize the decorator with OpenAPI metadata parameters.</p> <p>Parameters:</p> Name Type Description Default <code>summary</code> <code>str | I18nStr | None</code> <p>A short summary of what the operation does</p> <code>None</code> <code>description</code> <code>str | I18nStr | None</code> <p>A verbose explanation of the operation behavior</p> <code>None</code> <code>tags</code> <code>list[str] | None</code> <p>A list of tags for API documentation control</p> <code>None</code> <code>operation_id</code> <code>str | None</code> <p>Unique string used to identify the operation</p> <code>None</code> <code>responses</code> <code>OpenAPIMetaResponse | None</code> <p>The responses the API can return</p> <code>None</code> <code>deprecated</code> <code>bool</code> <p>Declares this operation to be deprecated</p> <code>False</code> <code>security</code> <code>list[dict[str, list[str]]] | None</code> <p>A declaration of which security mechanisms can be used for this operation</p> <code>None</code> <code>external_docs</code> <code>dict[str, str] | None</code> <p>Additional external documentation</p> <code>None</code> <code>language</code> <code>str | None</code> <p>Language code to use for I18nString values</p> <code>None</code> <code>prefix_config</code> <code>ConventionalPrefixConfig | None</code> <p>Configuration object for parameter prefixes</p> <code>None</code> <code>content_type</code> <code>str | None</code> <p>Custom content type for request body. If None, will be auto-detected.</p> <code>None</code> <code>request_content_types</code> <code>RequestContentTypes | None</code> <p>Multiple content types for request body.</p> <code>None</code> <code>response_content_types</code> <code>ResponseContentTypes | None</code> <p>Multiple content types for response body.</p> <code>None</code> <code>content_type_resolver</code> <code>Callable[[Any], str] | None</code> <p>Function to determine content type based on request.</p> <code>None</code> Source code in <code>src/flask_x_openapi_schema/x/flask/decorators.py</code> <pre><code>def __init__(\n    self,\n    summary: str | I18nStr | None = None,\n    description: str | I18nStr | None = None,\n    tags: list[str] | None = None,\n    operation_id: str | None = None,\n    responses: OpenAPIMetaResponse | None = None,\n    deprecated: bool = False,\n    security: list[dict[str, list[str]]] | None = None,\n    external_docs: dict[str, str] | None = None,\n    language: str | None = None,\n    prefix_config: ConventionalPrefixConfig | None = None,\n    content_type: str | None = None,\n    request_content_types: RequestContentTypes | None = None,\n    response_content_types: ResponseContentTypes | None = None,\n    content_type_resolver: Callable[[Any], str] | None = None,\n) -&gt; None:\n    \"\"\"Initialize the decorator with OpenAPI metadata parameters.\n\n    Args:\n        summary: A short summary of what the operation does\n        description: A verbose explanation of the operation behavior\n        tags: A list of tags for API documentation control\n        operation_id: Unique string used to identify the operation\n        responses: The responses the API can return\n        deprecated: Declares this operation to be deprecated\n        security: A declaration of which security mechanisms can be used for this operation\n        external_docs: Additional external documentation\n        language: Language code to use for I18nString values\n        prefix_config: Configuration object for parameter prefixes\n        content_type: Custom content type for request body. If None, will be auto-detected.\n        request_content_types: Multiple content types for request body.\n        response_content_types: Multiple content types for response body.\n        content_type_resolver: Function to determine content type based on request.\n\n    \"\"\"\n    super().__init__(\n        summary=summary,\n        description=description,\n        tags=tags,\n        operation_id=operation_id,\n        responses=responses,\n        deprecated=deprecated,\n        security=security,\n        external_docs=external_docs,\n        language=language,\n        prefix_config=prefix_config,\n        content_type=content_type,\n        request_content_types=request_content_types,\n        response_content_types=response_content_types,\n        content_type_resolver=content_type_resolver,\n    )\n    self.framework = \"flask\"\n    self.base_decorator = None\n</code></pre>"},{"location":"api/flask/#flask_x_openapi_schema.x.flask.decorators.FlaskOpenAPIDecorator.extract_parameters_from_models","title":"<code>extract_parameters_from_models(query_model, path_params)</code>","text":"<p>Extract OpenAPI parameters from models.</p> <p>Parameters:</p> Name Type Description Default <code>query_model</code> <code>type[BaseModel] | None</code> <p>The query parameter model</p> required <code>path_params</code> <code>list[str] | None</code> <p>List of path parameter names</p> required <p>Returns:</p> Type Description <code>list[dict[str, Any]]</code> <p>List of OpenAPI parameter objects</p> Source code in <code>src/flask_x_openapi_schema/x/flask/decorators.py</code> <pre><code>def extract_parameters_from_models(\n    self,\n    query_model: type[BaseModel] | None,\n    path_params: list[str] | None,\n) -&gt; list[dict[str, Any]]:\n    \"\"\"Extract OpenAPI parameters from models.\n\n    Args:\n        query_model: The query parameter model\n        path_params: List of path parameter names\n\n    Returns:\n        List of OpenAPI parameter objects\n\n    \"\"\"\n    parameters = [\n        {\n            \"name\": param,\n            \"in\": \"path\",\n            \"required\": True,\n            \"schema\": {\"type\": \"string\"},\n        }\n        for param in path_params\n    ]\n\n    if query_model:\n        schema = query_model.model_json_schema()\n        properties = schema.get(\"properties\", {})\n        required = schema.get(\"required\", [])\n\n        for field_name, field_schema in properties.items():\n            param = {\n                \"name\": field_name,\n                \"in\": \"query\",\n                \"required\": field_name in required,\n                \"schema\": field_schema,\n            }\n\n            if \"description\" in field_schema:\n                param[\"description\"] = field_schema[\"description\"]\n\n            parameters.append(param)\n\n    return parameters\n</code></pre>"},{"location":"api/flask/#flask_x_openapi_schema.x.flask.decorators.FlaskOpenAPIDecorator.process_additional_params","title":"<code>process_additional_params(kwargs, param_names)</code>","text":"<p>Process additional framework-specific parameters.</p> <p>Parameters:</p> Name Type Description Default <code>kwargs</code> <code>dict[str, Any]</code> <p>The keyword arguments to update</p> required <code>param_names</code> <code>list[str]</code> <p>List of parameter names that have been processed</p> required <p>Returns:</p> Type Description <code>dict[str, Any]</code> <p>Updated kwargs dictionary</p> Source code in <code>src/flask_x_openapi_schema/x/flask/decorators.py</code> <pre><code>def process_additional_params(self, kwargs: dict[str, Any], param_names: list[str]) -&gt; dict[str, Any]:\n    \"\"\"Process additional framework-specific parameters.\n\n    Args:\n        kwargs: The keyword arguments to update\n        param_names: List of parameter names that have been processed\n\n    Returns:\n        Updated kwargs dictionary\n\n    \"\"\"\n    logger = get_logger(__name__)\n    logger.debug(f\"Processing additional parameters with kwargs keys: {list(kwargs.keys())}\")\n    logger.debug(f\"Processed parameter names: {param_names}\")\n    return kwargs\n</code></pre>"},{"location":"api/flask/#flask_x_openapi_schema.x.flask.decorators.FlaskOpenAPIDecorator.process_query_params","title":"<code>process_query_params(param_name, model, kwargs)</code>","text":"<p>Process query parameters for Flask.</p> <p>Parameters:</p> Name Type Description Default <code>param_name</code> <code>str</code> <p>The parameter name to bind the model instance to</p> required <code>model</code> <code>type[BaseModel]</code> <p>The Pydantic model class to use for validation</p> required <code>kwargs</code> <code>dict[str, Any]</code> <p>The keyword arguments to update</p> required <p>Returns:</p> Type Description <code>dict[str, Any]</code> <p>Updated kwargs dictionary with the model instance</p> Source code in <code>src/flask_x_openapi_schema/x/flask/decorators.py</code> <pre><code>def process_query_params(self, param_name: str, model: type[BaseModel], kwargs: dict[str, Any]) -&gt; dict[str, Any]:\n    \"\"\"Process query parameters for Flask.\n\n    Args:\n        param_name: The parameter name to bind the model instance to\n        model: The Pydantic model class to use for validation\n        kwargs: The keyword arguments to update\n\n    Returns:\n        Updated kwargs dictionary with the model instance\n\n    \"\"\"\n    query_data = {}\n    model_fields = model.model_fields\n\n    for field_name in model_fields:\n        if field_name in request.args:\n            query_data[field_name] = request.args.get(field_name)\n\n    model_instance = model(**query_data)\n\n    kwargs[param_name] = model_instance\n\n    return kwargs\n</code></pre>"},{"location":"api/flask/#flask_x_openapi_schema.x.flask.decorators.FlaskOpenAPIDecorator.process_request_body","title":"<code>process_request_body(param_name, model, kwargs)</code>","text":"<p>Process request body parameters for Flask.</p> <p>Parameters:</p> Name Type Description Default <code>param_name</code> <code>str</code> <p>The parameter name to bind the model instance to</p> required <code>model</code> <code>type[BaseModel]</code> <p>The Pydantic model class to use for validation</p> required <code>kwargs</code> <code>dict[str, Any]</code> <p>The keyword arguments to update</p> required <p>Returns:</p> Type Description <code>dict[str, Any]</code> <p>Updated kwargs dictionary with the model instance</p> Source code in <code>src/flask_x_openapi_schema/x/flask/decorators.py</code> <pre><code>def process_request_body(self, param_name: str, model: type[BaseModel], kwargs: dict[str, Any]) -&gt; dict[str, Any]:\n    \"\"\"Process request body parameters for Flask.\n\n    Args:\n        param_name: The parameter name to bind the model instance to\n        model: The Pydantic model class to use for validation\n        kwargs: The keyword arguments to update\n\n    Returns:\n        Updated kwargs dictionary with the model instance\n\n    \"\"\"\n    from flask import request\n\n    from flask_x_openapi_schema.models.file_models import FileField\n\n    if hasattr(model, \"model_fields\") and hasattr(request, \"files\") and request.files:\n        has_file_fields = False\n        for field_info in model.model_fields.values():\n            field_type = field_info.annotation\n\n            if isinstance(field_type, type) and issubclass(field_type, FileField):\n                has_file_fields = True\n                break\n\n            origin = getattr(field_type, \"__origin__\", None)\n            if origin is list or origin is list:\n                args = getattr(field_type, \"__args__\", [])\n                if args and isinstance(args[0], type) and issubclass(args[0], FileField):\n                    has_file_fields = True\n                    break\n\n        if has_file_fields:\n            model_data = dict(request.form.items())\n            for field_name in model.model_fields:\n                if field_name in request.files:\n                    model_data[field_name] = request.files[field_name]\n\n            if model_data:\n                try:\n                    model_instance = model(**model_data)\n                    kwargs[param_name] = model_instance\n                except Exception as e:\n                    logger = get_logger(__name__)\n                    logger.exception(\n                        f\"Failed to create model instance with mock files for {model.__name__}\", exc_info=e\n                    )\n                else:\n                    return kwargs\n\n    return super().process_request_body(param_name, model, kwargs)\n</code></pre>"},{"location":"api/flask/#flask_x_openapi_schema.x.flask.decorators.openapi_metadata","title":"<code>openapi_metadata(*, summary=None, description=None, tags=None, operation_id=None, responses=None, deprecated=False, security=None, external_docs=None, language=None, prefix_config=None, content_type=None, request_content_types=None, response_content_types=None, content_type_resolver=None)</code>","text":"<p>Decorator to add OpenAPI metadata to a Flask MethodView endpoint.</p> <p>This decorator adds OpenAPI metadata to a Flask MethodView endpoint and handles parameter binding for request data. It automatically binds request body, query parameters, path parameters, and file uploads to function parameters based on their type annotations and parameter name prefixes.</p> <p>Parameters:</p> Name Type Description Default <code>summary</code> <code>str | I18nStr | None</code> <p>A short summary of what the operation does</p> <code>None</code> <code>description</code> <code>str | I18nStr | None</code> <p>A verbose explanation of the operation behavior</p> <code>None</code> <code>tags</code> <code>list[str] | None</code> <p>A list of tags for API documentation control</p> <code>None</code> <code>operation_id</code> <code>str | None</code> <p>Unique string used to identify the operation</p> <code>None</code> <code>responses</code> <code>OpenAPIMetaResponse | None</code> <p>The responses the API can return</p> <code>None</code> <code>deprecated</code> <code>bool</code> <p>Declares this operation to be deprecated</p> <code>False</code> <code>security</code> <code>list[dict[str, list[str]]] | None</code> <p>A declaration of which security mechanisms can be used for this operation</p> <code>None</code> <code>external_docs</code> <code>dict[str, str] | None</code> <p>Additional external documentation</p> <code>None</code> <code>language</code> <code>str | None</code> <p>Language code to use for I18nString values (default: current language)</p> <code>None</code> <code>prefix_config</code> <code>ConventionalPrefixConfig | None</code> <p>Configuration object for parameter prefixes</p> <code>None</code> <code>content_type</code> <code>str | None</code> <p>Custom content type for request body. If None, will be auto-detected.</p> <code>None</code> <code>request_content_types</code> <code>RequestContentTypes | None</code> <p>Multiple content types for request body.</p> <code>None</code> <code>response_content_types</code> <code>ResponseContentTypes | None</code> <p>Multiple content types for response body.</p> <code>None</code> <code>content_type_resolver</code> <code>Callable[[Any], str] | None</code> <p>Function to determine content type based on request.</p> <code>None</code> <p>Returns:</p> Type Description <code>Callable[[F], F]</code> <p>The decorated function with OpenAPI metadata attached</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from flask.views import MethodView\n&gt;&gt;&gt; from flask_x_openapi_schema.x.flask import openapi_metadata\n&gt;&gt;&gt; from flask_x_openapi_schema import OpenAPIMetaResponse, OpenAPIMetaResponseItem\n&gt;&gt;&gt; from pydantic import BaseModel, Field\n&gt;&gt;&gt;\n&gt;&gt;&gt; class ItemRequest(BaseModel):\n...     name: str = Field(..., description=\"Item name\")\n...     price: float = Field(..., description=\"Item price\")\n&gt;&gt;&gt;\n&gt;&gt;&gt; class ItemResponse(BaseModel):\n...     id: str = Field(..., description=\"Item ID\")\n...     name: str = Field(..., description=\"Item name\")\n...     price: float = Field(..., description=\"Item price\")\n&gt;&gt;&gt;\n&gt;&gt;&gt; class ItemView(MethodView):\n...     @openapi_metadata(\n...         summary=\"Create a new item\",\n...         description=\"Create a new item with the provided information\",\n...         tags=[\"items\"],\n...         operation_id=\"createItem\",\n...         responses=OpenAPIMetaResponse(\n...             responses={\n...                 \"201\": OpenAPIMetaResponseItem(model=ItemResponse, description=\"Item created successfully\"),\n...                 \"400\": OpenAPIMetaResponseItem(description=\"Invalid request data\"),\n...             }\n...         ),\n...     )\n...     def post(self, _x_body: ItemRequest):\n...         item = {\"id\": \"123\", \"name\": _x_body.name, \"price\": _x_body.price}\n...         return item, 201\n</code></pre> Source code in <code>src/flask_x_openapi_schema/x/flask/decorators.py</code> <pre><code>def openapi_metadata(\n    *,\n    summary: str | I18nStr | None = None,\n    description: str | I18nStr | None = None,\n    tags: list[str] | None = None,\n    operation_id: str | None = None,\n    responses: OpenAPIMetaResponse | None = None,\n    deprecated: bool = False,\n    security: list[dict[str, list[str]]] | None = None,\n    external_docs: dict[str, str] | None = None,\n    language: str | None = None,\n    prefix_config: ConventionalPrefixConfig | None = None,\n    content_type: str | None = None,\n    request_content_types: RequestContentTypes | None = None,\n    response_content_types: ResponseContentTypes | None = None,\n    content_type_resolver: Callable[[Any], str] | None = None,\n) -&gt; Callable[[F], F]:\n    \"\"\"Decorator to add OpenAPI metadata to a Flask MethodView endpoint.\n\n    This decorator adds OpenAPI metadata to a Flask MethodView endpoint and handles\n    parameter binding for request data. It automatically binds request body, query parameters,\n    path parameters, and file uploads to function parameters based on their type annotations\n    and parameter name prefixes.\n\n    Args:\n        summary: A short summary of what the operation does\n        description: A verbose explanation of the operation behavior\n        tags: A list of tags for API documentation control\n        operation_id: Unique string used to identify the operation\n        responses: The responses the API can return\n        deprecated: Declares this operation to be deprecated\n        security: A declaration of which security mechanisms can be used for this operation\n        external_docs: Additional external documentation\n        language: Language code to use for I18nString values (default: current language)\n        prefix_config: Configuration object for parameter prefixes\n        content_type: Custom content type for request body. If None, will be auto-detected.\n        request_content_types: Multiple content types for request body.\n        response_content_types: Multiple content types for response body.\n        content_type_resolver: Function to determine content type based on request.\n\n\n    Returns:\n        The decorated function with OpenAPI metadata attached\n\n    Examples:\n        &gt;&gt;&gt; from flask.views import MethodView\n        &gt;&gt;&gt; from flask_x_openapi_schema.x.flask import openapi_metadata\n        &gt;&gt;&gt; from flask_x_openapi_schema import OpenAPIMetaResponse, OpenAPIMetaResponseItem\n        &gt;&gt;&gt; from pydantic import BaseModel, Field\n        &gt;&gt;&gt;\n        &gt;&gt;&gt; class ItemRequest(BaseModel):\n        ...     name: str = Field(..., description=\"Item name\")\n        ...     price: float = Field(..., description=\"Item price\")\n        &gt;&gt;&gt;\n        &gt;&gt;&gt; class ItemResponse(BaseModel):\n        ...     id: str = Field(..., description=\"Item ID\")\n        ...     name: str = Field(..., description=\"Item name\")\n        ...     price: float = Field(..., description=\"Item price\")\n        &gt;&gt;&gt;\n        &gt;&gt;&gt; class ItemView(MethodView):\n        ...     @openapi_metadata(\n        ...         summary=\"Create a new item\",\n        ...         description=\"Create a new item with the provided information\",\n        ...         tags=[\"items\"],\n        ...         operation_id=\"createItem\",\n        ...         responses=OpenAPIMetaResponse(\n        ...             responses={\n        ...                 \"201\": OpenAPIMetaResponseItem(model=ItemResponse, description=\"Item created successfully\"),\n        ...                 \"400\": OpenAPIMetaResponseItem(description=\"Invalid request data\"),\n        ...             }\n        ...         ),\n        ...     )\n        ...     def post(self, _x_body: ItemRequest):\n        ...         item = {\"id\": \"123\", \"name\": _x_body.name, \"price\": _x_body.price}\n        ...         return item, 201\n\n    \"\"\"\n    return FlaskOpenAPIDecorator(\n        summary=summary,\n        description=description,\n        tags=tags,\n        operation_id=operation_id,\n        responses=responses,\n        deprecated=deprecated,\n        security=security,\n        external_docs=external_docs,\n        language=language,\n        prefix_config=prefix_config,\n        content_type=content_type,\n        request_content_types=request_content_types,\n        response_content_types=response_content_types,\n        content_type_resolver=content_type_resolver,\n    )\n</code></pre>"},{"location":"api/flask/#views","title":"Views","text":"<p>Utilities for integrating Pydantic models with Flask.MethodView.</p> <p>This module provides utilities for integrating Pydantic models with Flask.MethodView classes. It includes classes and functions for collecting OpenAPI metadata from MethodView classes and generating OpenAPI schema documentation.</p> <p>Examples:</p> <p>Basic usage with Flask blueprint and MethodView:</p> <pre><code>&gt;&gt;&gt; from flask import Blueprint\n&gt;&gt;&gt; from flask.views import MethodView\n&gt;&gt;&gt; from flask_x_openapi_schema.x.flask import OpenAPIMethodViewMixin, openapi_metadata\n&gt;&gt;&gt; from pydantic import BaseModel, Field\n&gt;&gt;&gt;\n&gt;&gt;&gt; class ItemResponse(BaseModel):\n...     id: str = Field(..., description=\"Item ID\")\n...     name: str = Field(..., description=\"Item name\")\n&gt;&gt;&gt;\n&gt;&gt;&gt; class ItemView(OpenAPIMethodViewMixin, MethodView):\n...     @openapi_metadata(summary=\"Get an item\")\n...     def get(self, item_id: str):\n...         return {\"id\": item_id, \"name\": \"Example Item\"}\n&gt;&gt;&gt;\n&gt;&gt;&gt; bp = Blueprint(\"items\", __name__)\n&gt;&gt;&gt; # Register the view to the blueprint\n&gt;&gt;&gt; _ = ItemView.register_to_blueprint(bp, \"/items/&lt;item_id&gt;\")\n</code></pre>"},{"location":"api/flask/#flask_x_openapi_schema.x.flask.views.MethodViewOpenAPISchemaGenerator","title":"<code>MethodViewOpenAPISchemaGenerator</code>","text":"<p>               Bases: <code>OpenAPISchemaGenerator</code></p> <p>OpenAPI schema generator for Flask.MethodView classes.</p> <p>This class extends the base OpenAPISchemaGenerator to provide specific functionality for generating OpenAPI schema from Flask.MethodView classes. It processes MethodView resources registered to blueprints and extracts metadata for OpenAPI schema generation.</p> Source code in <code>src/flask_x_openapi_schema/x/flask/views.py</code> <pre><code>class MethodViewOpenAPISchemaGenerator(OpenAPISchemaGenerator):\n    \"\"\"OpenAPI schema generator for Flask.MethodView classes.\n\n    This class extends the base OpenAPISchemaGenerator to provide specific functionality\n    for generating OpenAPI schema from Flask.MethodView classes. It processes MethodView\n    resources registered to blueprints and extracts metadata for OpenAPI schema generation.\n    \"\"\"\n\n    def process_methodview_resources(self, blueprint: Any) -&gt; None:\n        \"\"\"Process MethodView resources registered to a blueprint.\n\n        Extracts OpenAPI metadata from MethodView classes registered to a blueprint\n        and adds them to the OpenAPI schema.\n\n        Args:\n            blueprint: The Flask blueprint with registered MethodView resources\n\n        \"\"\"\n        if not hasattr(blueprint, \"_methodview_openapi_resources\"):\n            return\n\n        for view_class, url in blueprint._methodview_openapi_resources:\n            self._process_methodview(view_class, url, blueprint.url_prefix or \"\")\n\n    def _register_models_from_method(self, method: Any) -&gt; None:\n        \"\"\"Register Pydantic models from method type hints.\n\n        Extracts Pydantic models from method type hints and registers them\n        in the OpenAPI schema components.\n\n        Args:\n            method: The method to extract models from\n\n        \"\"\"\n        type_hints = get_type_hints(method)\n\n        for param_name, param_type in type_hints.items():\n            if param_name == \"return\":\n                continue\n\n            if isinstance(param_type, type) and issubclass(param_type, BaseModel):\n                self._register_model(param_type)\n\n        metadata = getattr(method, \"_openapi_metadata\", {})\n        if \"responses\" in metadata and hasattr(metadata[\"responses\"], \"responses\"):\n            for response_item in metadata[\"responses\"].responses.values():\n                if response_item.model:\n                    self._register_model(response_item.model)\n\n    def _process_methodview(self, view_class: Any, url: str, url_prefix: str) -&gt; None:\n        \"\"\"Process a MethodView class for OpenAPI schema generation.\n\n        Extracts metadata from a MethodView class and adds it to the OpenAPI schema.\n        Processes HTTP methods, path parameters, request bodies, and responses.\n\n        Args:\n            view_class: The MethodView class\n            url: The URL rule\n            url_prefix: The URL prefix from the blueprint\n\n        \"\"\"\n        methods = [\n            method.upper() for method in [\"get\", \"post\", \"put\", \"delete\", \"patch\"] if hasattr(view_class, method)\n        ]\n\n        if not methods:\n            return\n\n        full_url = (url_prefix + url).replace(\"//\", \"/\")\n\n        from flask_x_openapi_schema.core.cache import get_parameter_prefixes\n\n        _, _, path_prefix, _ = get_parameter_prefixes()\n        path_prefix_len = len(path_prefix) + 1\n\n        path = full_url\n        for segment in full_url.split(\"/\"):\n            if segment.startswith(\"&lt;\") and segment.endswith(\"&gt;\"):\n                if \":\" in segment[1:-1]:\n                    _, name = segment[1:-1].split(\":\", 1)\n                else:\n                    name = segment[1:-1]\n\n                actual_name = name\n                if name.startswith(f\"{path_prefix}_\"):\n                    actual_name = name[path_prefix_len:]\n\n                path = path.replace(segment, \"{\" + actual_name + \"}\")\n\n        for method in methods:\n            method_func = getattr(view_class, method.lower())\n\n            metadata = getattr(method_func, \"_openapi_metadata\", {})\n\n            path_parameters = extract_openapi_parameters_from_methodview(view_class, method.lower(), url)\n\n            if not metadata:\n                metadata = {\n                    \"summary\": method_func.__doc__.split(\"\\n\")[0] if method_func.__doc__ else f\"{method} {path}\",\n                    \"description\": method_func.__doc__ if method_func.__doc__ else \"\",\n                }\n\n                if path_parameters:\n                    metadata[\"parameters\"] = path_parameters\n\n            elif path_parameters:\n                if \"parameters\" in metadata:\n                    existing_path_param_names = [p[\"name\"] for p in metadata[\"parameters\"] if p.get(\"in\") == \"path\"]\n                    new_path_params = [p for p in path_parameters if p[\"name\"] not in existing_path_param_names]\n                    metadata[\"parameters\"].extend(new_path_params)\n                else:\n                    metadata[\"parameters\"] = path_parameters\n\n            self._register_models_from_method(method_func)\n\n            type_hints = get_type_hints(method_func)\n            for param_name, param_type in type_hints.items():\n                if param_name == \"return\":\n                    continue\n\n                if isinstance(param_type, type) and issubclass(param_type, BaseModel):\n                    is_file_upload = False\n                    has_binary_fields = False\n\n                    if hasattr(param_type, \"model_config\"):\n                        config = getattr(param_type, \"model_config\", {})\n                        if isinstance(config, dict) and config.get(\"json_schema_extra\", {}).get(\n                            \"multipart/form-data\",\n                            False,\n                        ):\n                            is_file_upload = True\n                    elif hasattr(param_type, \"Config\") and hasattr(param_type.Config, \"json_schema_extra\"):\n                        config_extra = getattr(param_type.Config, \"json_schema_extra\", {})\n                        is_file_upload = config_extra.get(\"multipart/form-data\", False)\n\n                    if hasattr(param_type, \"model_fields\"):\n                        for field_info in param_type.model_fields.values():\n                            field_schema = getattr(field_info, \"json_schema_extra\", None)\n                            if field_schema is not None and field_schema.get(\"format\") == \"binary\":\n                                has_binary_fields = True\n                                break\n\n                    if is_file_upload or has_binary_fields:\n                        if \"requestBody\" in metadata and \"content\" in metadata[\"requestBody\"]:\n                            if \"application/json\" in metadata[\"requestBody\"][\"content\"]:\n                                schema = metadata[\"requestBody\"][\"content\"][\"application/json\"][\"schema\"]\n                                metadata[\"requestBody\"][\"content\"] = {\"multipart/form-data\": {\"schema\": schema}}\n\n                            elif not metadata[\"requestBody\"][\"content\"]:\n                                metadata[\"requestBody\"][\"content\"] = {\n                                    \"multipart/form-data\": {\n                                        \"schema\": {\"$ref\": f\"#/components/schemas/{param_type.__name__}\"},\n                                    },\n                                }\n\n                        elif \"requestBody\" not in metadata:\n                            metadata[\"requestBody\"] = {\n                                \"content\": {\n                                    \"multipart/form-data\": {\n                                        \"schema\": {\"$ref\": f\"#/components/schemas/{param_type.__name__}\"},\n                                    },\n                                },\n                                \"required\": True,\n                            }\n\n                        if \"parameters\" in metadata:\n                            metadata[\"parameters\"] = [p for p in metadata[\"parameters\"] if p[\"in\"] in [\"path\", \"query\"]]\n\n            if \"responses\" in metadata and hasattr(metadata[\"responses\"], \"to_openapi_dict\"):\n                if hasattr(metadata[\"responses\"], \"responses\"):\n                    for response_item in metadata[\"responses\"].responses.values():\n                        if response_item.model:\n                            self._register_model(response_item.model)\n\n                            if hasattr(response_item.model, \"model_fields\"):\n                                for field_info in response_item.model.model_fields.values():\n                                    field_type = field_info.annotation\n\n                                    if hasattr(field_type, \"__origin__\") and field_type.__origin__ is not None:\n                                        args = getattr(field_type, \"__args__\", [])\n                                        for arg in args:\n                                            if hasattr(arg, \"__members__\"):\n                                                self._register_model(arg)\n                                    elif hasattr(field_type, \"__members__\"):\n                                        self._register_model(field_type)\n\n                metadata[\"responses\"] = metadata[\"responses\"].to_openapi_dict()\n\n            if path not in self.paths:\n                self.paths[path] = {}\n\n            self.paths[path][method.lower()] = metadata\n</code></pre>"},{"location":"api/flask/#flask_x_openapi_schema.x.flask.views.MethodViewOpenAPISchemaGenerator.process_methodview_resources","title":"<code>process_methodview_resources(blueprint)</code>","text":"<p>Process MethodView resources registered to a blueprint.</p> <p>Extracts OpenAPI metadata from MethodView classes registered to a blueprint and adds them to the OpenAPI schema.</p> <p>Parameters:</p> Name Type Description Default <code>blueprint</code> <code>Any</code> <p>The Flask blueprint with registered MethodView resources</p> required Source code in <code>src/flask_x_openapi_schema/x/flask/views.py</code> <pre><code>def process_methodview_resources(self, blueprint: Any) -&gt; None:\n    \"\"\"Process MethodView resources registered to a blueprint.\n\n    Extracts OpenAPI metadata from MethodView classes registered to a blueprint\n    and adds them to the OpenAPI schema.\n\n    Args:\n        blueprint: The Flask blueprint with registered MethodView resources\n\n    \"\"\"\n    if not hasattr(blueprint, \"_methodview_openapi_resources\"):\n        return\n\n    for view_class, url in blueprint._methodview_openapi_resources:\n        self._process_methodview(view_class, url, blueprint.url_prefix or \"\")\n</code></pre>"},{"location":"api/flask/#flask_x_openapi_schema.x.flask.views.OpenAPIMethodViewMixin","title":"<code>OpenAPIMethodViewMixin</code>","text":"<p>A mixin class for Flask.MethodView to collect OpenAPI metadata.</p> <p>This mixin class adds OpenAPI schema generation capabilities to Flask's MethodView. It provides a method to register the view to a blueprint while collecting metadata for OpenAPI schema generation.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from flask import Blueprint\n&gt;&gt;&gt; from flask.views import MethodView\n&gt;&gt;&gt; from flask_x_openapi_schema.x.flask import OpenAPIMethodViewMixin, openapi_metadata\n&gt;&gt;&gt; from pydantic import BaseModel, Field\n&gt;&gt;&gt;\n&gt;&gt;&gt; class ItemResponse(BaseModel):\n...     id: str = Field(..., description=\"Item ID\")\n...     name: str = Field(..., description=\"Item name\")\n&gt;&gt;&gt;\n&gt;&gt;&gt; class ItemView(OpenAPIMethodViewMixin, MethodView):\n...     @openapi_metadata(summary=\"Get an item\")\n...     def get(self, item_id: str):\n...         return {\"id\": item_id, \"name\": \"Example Item\"}\n&gt;&gt;&gt;\n&gt;&gt;&gt; bp = Blueprint(\"items\", __name__)\n&gt;&gt;&gt; # Register the view to the blueprint\n&gt;&gt;&gt; _ = ItemView.register_to_blueprint(bp, \"/items/&lt;item_id&gt;\")\n</code></pre> Source code in <code>src/flask_x_openapi_schema/x/flask/views.py</code> <pre><code>class OpenAPIMethodViewMixin:\n    \"\"\"A mixin class for Flask.MethodView to collect OpenAPI metadata.\n\n    This mixin class adds OpenAPI schema generation capabilities to Flask's MethodView.\n    It provides a method to register the view to a blueprint while collecting metadata\n    for OpenAPI schema generation.\n\n    Examples:\n        &gt;&gt;&gt; from flask import Blueprint\n        &gt;&gt;&gt; from flask.views import MethodView\n        &gt;&gt;&gt; from flask_x_openapi_schema.x.flask import OpenAPIMethodViewMixin, openapi_metadata\n        &gt;&gt;&gt; from pydantic import BaseModel, Field\n        &gt;&gt;&gt;\n        &gt;&gt;&gt; class ItemResponse(BaseModel):\n        ...     id: str = Field(..., description=\"Item ID\")\n        ...     name: str = Field(..., description=\"Item name\")\n        &gt;&gt;&gt;\n        &gt;&gt;&gt; class ItemView(OpenAPIMethodViewMixin, MethodView):\n        ...     @openapi_metadata(summary=\"Get an item\")\n        ...     def get(self, item_id: str):\n        ...         return {\"id\": item_id, \"name\": \"Example Item\"}\n        &gt;&gt;&gt;\n        &gt;&gt;&gt; bp = Blueprint(\"items\", __name__)\n        &gt;&gt;&gt; # Register the view to the blueprint\n        &gt;&gt;&gt; _ = ItemView.register_to_blueprint(bp, \"/items/&lt;item_id&gt;\")\n\n    \"\"\"\n\n    @classmethod\n    def register_to_blueprint(cls, blueprint: Any, url: str, endpoint: str | None = None, **kwargs: Any) -&gt; Any:\n        \"\"\"Register the MethodView to a blueprint and collect OpenAPI metadata.\n\n        This method registers the view to a blueprint and stores metadata for\n        OpenAPI schema generation.\n\n        Args:\n            blueprint: The Flask blueprint to register to\n            url: The URL rule to register\n            endpoint: The endpoint name (defaults to the class name)\n            **kwargs: Additional arguments to pass to add_url_rule\n\n        Returns:\n            Any: The view function\n\n        Examples:\n            &gt;&gt;&gt; from flask import Blueprint\n            &gt;&gt;&gt; from flask.views import MethodView\n            &gt;&gt;&gt; from flask_x_openapi_schema.x.flask import OpenAPIMethodViewMixin\n            &gt;&gt;&gt; class ItemView(OpenAPIMethodViewMixin, MethodView):\n            ...     def get(self, item_id: str):\n            ...         return {\"id\": item_id, \"name\": \"Example Item\"}\n            &gt;&gt;&gt; bp = Blueprint(\"items\", __name__)\n            &gt;&gt;&gt; # Register the view to the blueprint\n            &gt;&gt;&gt; _ = ItemView.register_to_blueprint(bp, \"/items/&lt;item_id&gt;\")\n\n        \"\"\"\n        view_func = cls.as_view(endpoint or cls.__name__.lower())\n        blueprint.add_url_rule(url, view_func=view_func, **kwargs)\n\n        if not hasattr(blueprint, \"_methodview_openapi_resources\"):\n            blueprint._methodview_openapi_resources = []\n\n        blueprint._methodview_openapi_resources.append((cls, url))\n\n        return view_func\n</code></pre>"},{"location":"api/flask/#flask_x_openapi_schema.x.flask.views.OpenAPIMethodViewMixin.register_to_blueprint","title":"<code>register_to_blueprint(blueprint, url, endpoint=None, **kwargs)</code>  <code>classmethod</code>","text":"<p>Register the MethodView to a blueprint and collect OpenAPI metadata.</p> <p>This method registers the view to a blueprint and stores metadata for OpenAPI schema generation.</p> <p>Parameters:</p> Name Type Description Default <code>blueprint</code> <code>Any</code> <p>The Flask blueprint to register to</p> required <code>url</code> <code>str</code> <p>The URL rule to register</p> required <code>endpoint</code> <code>str | None</code> <p>The endpoint name (defaults to the class name)</p> <code>None</code> <code>**kwargs</code> <code>Any</code> <p>Additional arguments to pass to add_url_rule</p> <code>{}</code> <p>Returns:</p> Name Type Description <code>Any</code> <code>Any</code> <p>The view function</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from flask import Blueprint\n&gt;&gt;&gt; from flask.views import MethodView\n&gt;&gt;&gt; from flask_x_openapi_schema.x.flask import OpenAPIMethodViewMixin\n&gt;&gt;&gt; class ItemView(OpenAPIMethodViewMixin, MethodView):\n...     def get(self, item_id: str):\n...         return {\"id\": item_id, \"name\": \"Example Item\"}\n&gt;&gt;&gt; bp = Blueprint(\"items\", __name__)\n&gt;&gt;&gt; # Register the view to the blueprint\n&gt;&gt;&gt; _ = ItemView.register_to_blueprint(bp, \"/items/&lt;item_id&gt;\")\n</code></pre> Source code in <code>src/flask_x_openapi_schema/x/flask/views.py</code> <pre><code>@classmethod\ndef register_to_blueprint(cls, blueprint: Any, url: str, endpoint: str | None = None, **kwargs: Any) -&gt; Any:\n    \"\"\"Register the MethodView to a blueprint and collect OpenAPI metadata.\n\n    This method registers the view to a blueprint and stores metadata for\n    OpenAPI schema generation.\n\n    Args:\n        blueprint: The Flask blueprint to register to\n        url: The URL rule to register\n        endpoint: The endpoint name (defaults to the class name)\n        **kwargs: Additional arguments to pass to add_url_rule\n\n    Returns:\n        Any: The view function\n\n    Examples:\n        &gt;&gt;&gt; from flask import Blueprint\n        &gt;&gt;&gt; from flask.views import MethodView\n        &gt;&gt;&gt; from flask_x_openapi_schema.x.flask import OpenAPIMethodViewMixin\n        &gt;&gt;&gt; class ItemView(OpenAPIMethodViewMixin, MethodView):\n        ...     def get(self, item_id: str):\n        ...         return {\"id\": item_id, \"name\": \"Example Item\"}\n        &gt;&gt;&gt; bp = Blueprint(\"items\", __name__)\n        &gt;&gt;&gt; # Register the view to the blueprint\n        &gt;&gt;&gt; _ = ItemView.register_to_blueprint(bp, \"/items/&lt;item_id&gt;\")\n\n    \"\"\"\n    view_func = cls.as_view(endpoint or cls.__name__.lower())\n    blueprint.add_url_rule(url, view_func=view_func, **kwargs)\n\n    if not hasattr(blueprint, \"_methodview_openapi_resources\"):\n        blueprint._methodview_openapi_resources = []\n\n    blueprint._methodview_openapi_resources.append((cls, url))\n\n    return view_func\n</code></pre>"},{"location":"api/flask/#flask_x_openapi_schema.x.flask.views.extract_openapi_parameters_from_methodview","title":"<code>extract_openapi_parameters_from_methodview(view_class, method, url)</code>","text":"<p>Extract OpenAPI parameters from a MethodView class method.</p> <p>Analyzes a MethodView class method to extract path parameters and their types for OpenAPI schema generation.</p> <p>Parameters:</p> Name Type Description Default <code>view_class</code> <code>type[MethodView]</code> <p>The MethodView class</p> required <code>method</code> <code>str</code> <p>The HTTP method (get, post, etc.)</p> required <code>url</code> <code>str</code> <p>The URL rule</p> required <p>Returns:</p> Type Description <code>list[dict[str, Any]]</code> <p>list[dict[str, Any]]: List of OpenAPI parameter objects</p> Source code in <code>src/flask_x_openapi_schema/x/flask/views.py</code> <pre><code>def extract_openapi_parameters_from_methodview(\n    view_class: type[MethodView],\n    method: str,\n    url: str,\n) -&gt; list[dict[str, Any]]:\n    \"\"\"Extract OpenAPI parameters from a MethodView class method.\n\n    Analyzes a MethodView class method to extract path parameters and their types\n    for OpenAPI schema generation.\n\n    Args:\n        view_class: The MethodView class\n        method: The HTTP method (get, post, etc.)\n        url: The URL rule\n\n    Returns:\n        list[dict[str, Any]]: List of OpenAPI parameter objects\n\n    \"\"\"\n    from flask_x_openapi_schema.core.cache import get_parameter_prefixes\n\n    parameters = []\n\n    method_func = getattr(view_class, method.lower(), None)\n    if not method_func:\n        return parameters\n\n    type_hints = get_type_hints(method_func)\n\n    _, _, path_prefix, _ = get_parameter_prefixes()\n    path_prefix_len = len(path_prefix) + 1\n\n    path_params = []\n    for segment in url.split(\"/\"):\n        if segment.startswith(\"&lt;\") and segment.endswith(\"&gt;\"):\n            if \":\" in segment[1:-1]:\n                _, name = segment[1:-1].split(\":\", 1)\n            else:\n                name = segment[1:-1]\n            path_params.append(name)\n\n    for param_name in path_params:\n        actual_param_name = param_name\n        if param_name.startswith(f\"{path_prefix}_\"):\n            actual_param_name = param_name[path_prefix_len:]\n\n        param_type = type_hints.get(param_name, str)\n        param_schema = {\"type\": \"string\"}\n\n        if param_type is int:\n            param_schema = {\"type\": \"integer\"}\n        elif param_type is float:\n            param_schema = {\"type\": \"number\"}\n        elif param_type is bool:\n            param_schema = {\"type\": \"boolean\"}\n\n        parameters.append(\n            {\n                \"name\": actual_param_name,\n                \"in\": \"path\",\n                \"required\": True,\n                \"schema\": param_schema,\n            },\n        )\n\n    for param_name, param_type in type_hints.items():\n        if param_name in path_params or param_name == \"return\":\n            continue\n\n        if isinstance(param_type, type) and issubclass(param_type, BaseModel):\n            pass\n\n    return parameters\n</code></pre>"},{"location":"api/flask/#utilities","title":"Utilities","text":"<p>Utility functions for Flask integration.</p> <p>This module provides utility functions for integrating Flask with OpenAPI schema generation. It includes functions for generating OpenAPI schemas from Flask blueprints, registering Pydantic models with schema generators, and extracting data from requests based on Pydantic models.</p>"},{"location":"api/flask/#flask_x_openapi_schema.x.flask.utils.extract_pydantic_data","title":"<code>extract_pydantic_data(model_class)</code>","text":"<p>Extract data from the request based on a Pydantic model.</p> <p>This function extracts data from the current Flask request and validates it against the provided Pydantic model. It handles JSON data, form data, and query parameters.</p> <p>Parameters:</p> Name Type Description Default <code>model_class</code> <code>type[BaseModel]</code> <p>The Pydantic model class to use for validation.</p> required <p>Returns:</p> Name Type Description <code>BaseModel</code> <code>BaseModel</code> <p>A validated instance of the provided Pydantic model.</p> <p>Raises:</p> Type Description <code>ValidationError</code> <p>If the request data doesn't match the model's schema.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from flask import Flask, request\n&gt;&gt;&gt; from pydantic import BaseModel, Field\n&gt;&gt;&gt; app = Flask(__name__)\n&gt;&gt;&gt; class UserCreate(BaseModel):\n...     username: str\n...     email: str\n...     age: int = Field(gt=0)\n&gt;&gt;&gt; @app.route(\"/users\", methods=[\"POST\"])\n... def create_user():\n...     # In a real request context:\n...     user_data = extract_pydantic_data(UserCreate)\n...     # user_data is now a validated UserCreate instance\n...     return {\"id\": 1, \"username\": user_data.username}\n</code></pre> Note <p>This function combines data from request.json, request.form, and request.args.</p> Source code in <code>src/flask_x_openapi_schema/x/flask/utils.py</code> <pre><code>def extract_pydantic_data(model_class: type[BaseModel]) -&gt; BaseModel:\n    \"\"\"Extract data from the request based on a Pydantic model.\n\n    This function extracts data from the current Flask request and validates it\n    against the provided Pydantic model. It handles JSON data, form data, and\n    query parameters.\n\n    Args:\n        model_class: The Pydantic model class to use for validation.\n\n    Returns:\n        BaseModel: A validated instance of the provided Pydantic model.\n\n    Raises:\n        ValidationError: If the request data doesn't match the model's schema.\n\n    Examples:\n        &gt;&gt;&gt; from flask import Flask, request\n        &gt;&gt;&gt; from pydantic import BaseModel, Field\n        &gt;&gt;&gt; app = Flask(__name__)\n        &gt;&gt;&gt; class UserCreate(BaseModel):\n        ...     username: str\n        ...     email: str\n        ...     age: int = Field(gt=0)\n        &gt;&gt;&gt; @app.route(\"/users\", methods=[\"POST\"])\n        ... def create_user():\n        ...     # In a real request context:\n        ...     user_data = extract_pydantic_data(UserCreate)\n        ...     # user_data is now a validated UserCreate instance\n        ...     return {\"id\": 1, \"username\": user_data.username}\n\n    Note:\n        This function combines data from request.json, request.form, and request.args.\n\n    \"\"\"\n    if request.is_json:\n        data = request.get_json(silent=True) or {}\n    elif request.form:\n        data = request.form.to_dict()\n    else:\n        data = {}\n\n    if request.args:\n        for key, value in request.args.items():\n            if key not in data:\n                data[key] = value\n\n    return model_class(**data)\n</code></pre>"},{"location":"api/flask/#flask_x_openapi_schema.x.flask.utils.generate_openapi_schema","title":"<code>generate_openapi_schema(blueprint, title, version, description='', output_format='yaml', language=None)</code>","text":"<p>Generate an OpenAPI schema from a Flask blueprint with MethodView classes.</p> <p>Parameters:</p> Name Type Description Default <code>blueprint</code> <code>Blueprint</code> <p>The Flask blueprint with registered MethodView classes.</p> required <code>title</code> <code>str | I18nStr</code> <p>The title of the API. Can be a string or I18nStr for internationalization.</p> required <code>version</code> <code>str</code> <p>The version of the API.</p> required <code>description</code> <code>str | I18nStr</code> <p>The description of the API. Can be a string or I18nStr for internationalization.</p> <code>''</code> <code>output_format</code> <code>str</code> <p>The output format. Options are \"yaml\" or \"json\". Defaults to \"yaml\".</p> <code>'yaml'</code> <code>language</code> <code>str | None</code> <p>The language to use for internationalized strings. If None, uses the current language.</p> <code>None</code> <p>Returns:</p> Type Description <code>dict[str, Any] | str</code> <p>dict or str: The OpenAPI schema as a dictionary (if output_format is \"json\") or as a YAML string (if output_format is \"yaml\").</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from flask import Blueprint\n&gt;&gt;&gt; bp = Blueprint(\"api\", __name__)\n&gt;&gt;&gt; schema = generate_openapi_schema(\n...     blueprint=bp, title=\"My API\", version=\"1.0.0\", description=\"My API Description\", output_format=\"yaml\"\n... )\n&gt;&gt;&gt; isinstance(schema, str)\nTrue\n&gt;&gt;&gt; \"title: My API\" in schema\nTrue\n</code></pre> Source code in <code>src/flask_x_openapi_schema/x/flask/utils.py</code> <pre><code>def generate_openapi_schema(\n    blueprint: Blueprint,\n    title: str | I18nStr,\n    version: str,\n    description: str | I18nStr = \"\",\n    output_format: str = \"yaml\",\n    language: str | None = None,\n) -&gt; dict[str, Any] | str:\n    \"\"\"Generate an OpenAPI schema from a Flask blueprint with MethodView classes.\n\n    Args:\n        blueprint: The Flask blueprint with registered MethodView classes.\n        title: The title of the API. Can be a string or I18nStr for internationalization.\n        version: The version of the API.\n        description: The description of the API. Can be a string or I18nStr for internationalization.\n        output_format: The output format. Options are \"yaml\" or \"json\". Defaults to \"yaml\".\n        language: The language to use for internationalized strings. If None, uses the current language.\n\n    Returns:\n        dict or str: The OpenAPI schema as a dictionary (if output_format is \"json\")\n            or as a YAML string (if output_format is \"yaml\").\n\n    Examples:\n        &gt;&gt;&gt; from flask import Blueprint\n        &gt;&gt;&gt; bp = Blueprint(\"api\", __name__)\n        &gt;&gt;&gt; schema = generate_openapi_schema(\n        ...     blueprint=bp, title=\"My API\", version=\"1.0.0\", description=\"My API Description\", output_format=\"yaml\"\n        ... )\n        &gt;&gt;&gt; isinstance(schema, str)\n        True\n        &gt;&gt;&gt; \"title: My API\" in schema\n        True\n\n    \"\"\"\n    current_lang = language or get_current_language()\n\n    generator = MethodViewOpenAPISchemaGenerator(\n        title=title,\n        version=version,\n        description=description,\n        language=current_lang,\n    )\n\n    generator.process_methodview_resources(blueprint=blueprint)\n\n    schema = generator.generate_schema()\n\n    if output_format == \"yaml\":\n        import yaml\n\n        return yaml.dump(schema, sort_keys=False, default_flow_style=False, allow_unicode=True)\n    return schema\n</code></pre>"},{"location":"api/flask/#flask_x_openapi_schema.x.flask.utils.register_model_schema","title":"<code>register_model_schema(generator, model)</code>","text":"<p>Register a Pydantic model schema with an OpenAPI schema generator.</p> <p>This function registers a Pydantic model with the OpenAPI schema generator, making it available in the components/schemas section of the generated OpenAPI schema.</p> <p>Parameters:</p> Name Type Description Default <code>generator</code> <code>OpenAPISchemaGenerator</code> <p>The OpenAPI schema generator instance.</p> required <code>model</code> <code>type[BaseModel]</code> <p>The Pydantic model class to register.</p> required <p>Examples:</p> <pre><code>&gt;&gt;&gt; from pydantic import BaseModel, Field\n&gt;&gt;&gt; from flask_x_openapi_schema.x.flask.views import MethodViewOpenAPISchemaGenerator\n&gt;&gt;&gt; class User(BaseModel):\n...     id: int = Field(..., description=\"User ID\")\n...     name: str = Field(..., description=\"User name\")\n&gt;&gt;&gt; generator = MethodViewOpenAPISchemaGenerator(title=\"My API\", version=\"1.0.0\")\n&gt;&gt;&gt; register_model_schema(generator, User)\n&gt;&gt;&gt; schema = generator.generate_schema()\n&gt;&gt;&gt; \"User\" in schema[\"components\"][\"schemas\"]\nTrue\n</code></pre> Note <p>This function uses the internal _register_model method of the generator.</p> Source code in <code>src/flask_x_openapi_schema/x/flask/utils.py</code> <pre><code>def register_model_schema(generator: OpenAPISchemaGenerator, model: type[BaseModel]) -&gt; None:\n    \"\"\"Register a Pydantic model schema with an OpenAPI schema generator.\n\n    This function registers a Pydantic model with the OpenAPI schema generator,\n    making it available in the components/schemas section of the generated OpenAPI schema.\n\n    Args:\n        generator: The OpenAPI schema generator instance.\n        model: The Pydantic model class to register.\n\n    Examples:\n        &gt;&gt;&gt; from pydantic import BaseModel, Field\n        &gt;&gt;&gt; from flask_x_openapi_schema.x.flask.views import MethodViewOpenAPISchemaGenerator\n        &gt;&gt;&gt; class User(BaseModel):\n        ...     id: int = Field(..., description=\"User ID\")\n        ...     name: str = Field(..., description=\"User name\")\n        &gt;&gt;&gt; generator = MethodViewOpenAPISchemaGenerator(title=\"My API\", version=\"1.0.0\")\n        &gt;&gt;&gt; register_model_schema(generator, User)\n        &gt;&gt;&gt; schema = generator.generate_schema()\n        &gt;&gt;&gt; \"User\" in schema[\"components\"][\"schemas\"]\n        True\n\n    Note:\n        This function uses the internal _register_model method of the generator.\n\n    \"\"\"\n    generator._register_model(model)\n</code></pre>"},{"location":"api/flask_restful/","title":"Flask-RESTful Integration","text":"<p>This section provides documentation for the Flask-RESTful specific components of Flask-X-OpenAPI-Schema.</p>"},{"location":"api/flask_restful/#flask-restful-module","title":"Flask-RESTful Module","text":"<p>Flask-RESTful specific implementations for OpenAPI schema generation.</p>"},{"location":"api/flask_restful/#flask_x_openapi_schema.x.flask_restful.OpenAPIBlueprintMixin","title":"<code>OpenAPIBlueprintMixin</code>","text":"<p>A mixin class for Flask Blueprint to collect OpenAPI metadata from MethodView classes.</p> <p>This mixin extends Flask's Blueprint class to add OpenAPI schema generation capabilities for MethodView classes. It tracks MethodView classes registered to the blueprint and provides methods to generate OpenAPI schemas.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from flask import Blueprint, Flask\n&gt;&gt;&gt; from flask.views import MethodView\n&gt;&gt;&gt; from flask_x_openapi_schema.x.flask_restful import OpenAPIBlueprintMixin\n&gt;&gt;&gt; from flask_x_openapi_schema.x.flask import openapi_metadata, OpenAPIMethodViewMixin\n&gt;&gt;&gt;\n&gt;&gt;&gt; app = Flask(__name__)\n&gt;&gt;&gt;\n&gt;&gt;&gt; class OpenAPIBlueprint(OpenAPIBlueprintMixin, Blueprint):\n...     pass\n&gt;&gt;&gt;\n&gt;&gt;&gt; bp = OpenAPIBlueprint(\"api\", __name__, url_prefix=\"/api\")\n&gt;&gt;&gt;\n&gt;&gt;&gt; class ItemView(OpenAPIMethodViewMixin, MethodView):\n...     @openapi_metadata(summary=\"Get an item\")\n...     def get(self, item_id):\n...         return {\"id\": item_id, \"name\": \"Example Item\"}\n&gt;&gt;&gt;\n&gt;&gt;&gt; # Register the view to the blueprint (returns a view function)\n&gt;&gt;&gt; view_func = ItemView.register_to_blueprint(bp, \"/items/&lt;item_id&gt;\")\n&gt;&gt;&gt;\n&gt;&gt;&gt; app.register_blueprint(bp)\n&gt;&gt;&gt;\n&gt;&gt;&gt; # Generate OpenAPI schema\n&gt;&gt;&gt; schema = bp.generate_openapi_schema(title=\"My API\", version=\"1.0.0\", description=\"API for managing items\")\n</code></pre> Source code in <code>src/flask_x_openapi_schema/x/flask_restful/resources.py</code> <pre><code>class OpenAPIBlueprintMixin:\n    \"\"\"A mixin class for Flask Blueprint to collect OpenAPI metadata from MethodView classes.\n\n    This mixin extends Flask's Blueprint class to add OpenAPI schema generation capabilities\n    for MethodView classes. It tracks MethodView classes registered to the blueprint and\n    provides methods to generate OpenAPI schemas.\n\n    Examples:\n        &gt;&gt;&gt; from flask import Blueprint, Flask\n        &gt;&gt;&gt; from flask.views import MethodView\n        &gt;&gt;&gt; from flask_x_openapi_schema.x.flask_restful import OpenAPIBlueprintMixin\n        &gt;&gt;&gt; from flask_x_openapi_schema.x.flask import openapi_metadata, OpenAPIMethodViewMixin\n        &gt;&gt;&gt;\n        &gt;&gt;&gt; app = Flask(__name__)\n        &gt;&gt;&gt;\n        &gt;&gt;&gt; class OpenAPIBlueprint(OpenAPIBlueprintMixin, Blueprint):\n        ...     pass\n        &gt;&gt;&gt;\n        &gt;&gt;&gt; bp = OpenAPIBlueprint(\"api\", __name__, url_prefix=\"/api\")\n        &gt;&gt;&gt;\n        &gt;&gt;&gt; class ItemView(OpenAPIMethodViewMixin, MethodView):\n        ...     @openapi_metadata(summary=\"Get an item\")\n        ...     def get(self, item_id):\n        ...         return {\"id\": item_id, \"name\": \"Example Item\"}\n        &gt;&gt;&gt;\n        &gt;&gt;&gt; # Register the view to the blueprint (returns a view function)\n        &gt;&gt;&gt; view_func = ItemView.register_to_blueprint(bp, \"/items/&lt;item_id&gt;\")\n        &gt;&gt;&gt;\n        &gt;&gt;&gt; app.register_blueprint(bp)\n        &gt;&gt;&gt;\n        &gt;&gt;&gt; # Generate OpenAPI schema\n        &gt;&gt;&gt; schema = bp.generate_openapi_schema(title=\"My API\", version=\"1.0.0\", description=\"API for managing items\")\n\n    \"\"\"\n\n    def configure_openapi(self, *, prefix_config: ConventionalPrefixConfig = None, **kwargs: Any) -&gt; None:\n        \"\"\"Configure OpenAPI settings for this Blueprint instance.\n\n        Args:\n            prefix_config: Configuration object with parameter prefixes\n            **kwargs: For backward compatibility - will be used to create a config object if prefix_config is None\n\n        \"\"\"\n        if prefix_config is not None:\n            configure_prefixes(prefix_config)\n        elif kwargs:\n            new_config = ConventionalPrefixConfig(\n                request_body_prefix=kwargs.get(\n                    \"request_body_prefix\",\n                    GLOBAL_CONFIG_HOLDER.get().request_body_prefix,\n                ),\n                request_query_prefix=kwargs.get(\n                    \"request_query_prefix\",\n                    GLOBAL_CONFIG_HOLDER.get().request_query_prefix,\n                ),\n                request_path_prefix=kwargs.get(\n                    \"request_path_prefix\",\n                    GLOBAL_CONFIG_HOLDER.get().request_path_prefix,\n                ),\n                request_file_prefix=kwargs.get(\n                    \"request_file_prefix\",\n                    GLOBAL_CONFIG_HOLDER.get().request_file_prefix,\n                ),\n            )\n            configure_prefixes(new_config)\n\n    def __init__(self, *args: Any, **kwargs: Any) -&gt; None:\n        \"\"\"Initialize the mixin.\n\n        Args:\n            *args: Arguments to pass to the parent class.\n            **kwargs: Keyword arguments to pass to the parent class.\n\n        \"\"\"\n        super().__init__(*args, **kwargs)\n\n        self._methodview_openapi_resources = []\n\n    def generate_openapi_schema(\n        self,\n        title: str | I18nStr,\n        version: str,\n        description: str | I18nStr = \"\",\n        output_format: Literal[\"json\", \"yaml\"] = \"yaml\",\n        language: str | None = None,\n    ) -&gt; Any:\n        \"\"\"Generate an OpenAPI schema for the API.\n\n        Args:\n            title: The title of the API (can be an I18nString).\n            version: The version of the API.\n            description: The description of the API (can be an I18nString).\n            output_format: The output format (json or yaml).\n            language: The language to use for internationalized strings (default: current language).\n\n        Returns:\n            The OpenAPI schema as a dictionary (if json) or string (if yaml).\n\n        \"\"\"\n        current_lang = language or get_current_language()\n\n        generator = MethodViewOpenAPISchemaGenerator(title, version, description, language=current_lang)\n\n        generator.process_methodview_resources(self)\n\n        schema = generator.generate_schema()\n\n        if output_format == \"yaml\":\n            return yaml.dump(schema, sort_keys=False, default_flow_style=False, allow_unicode=True)\n        return schema\n</code></pre>"},{"location":"api/flask_restful/#flask_x_openapi_schema.x.flask_restful.OpenAPIBlueprintMixin.__init__","title":"<code>__init__(*args, **kwargs)</code>","text":"<p>Initialize the mixin.</p> <p>Parameters:</p> Name Type Description Default <code>*args</code> <code>Any</code> <p>Arguments to pass to the parent class.</p> <code>()</code> <code>**kwargs</code> <code>Any</code> <p>Keyword arguments to pass to the parent class.</p> <code>{}</code> Source code in <code>src/flask_x_openapi_schema/x/flask_restful/resources.py</code> <pre><code>def __init__(self, *args: Any, **kwargs: Any) -&gt; None:\n    \"\"\"Initialize the mixin.\n\n    Args:\n        *args: Arguments to pass to the parent class.\n        **kwargs: Keyword arguments to pass to the parent class.\n\n    \"\"\"\n    super().__init__(*args, **kwargs)\n\n    self._methodview_openapi_resources = []\n</code></pre>"},{"location":"api/flask_restful/#flask_x_openapi_schema.x.flask_restful.OpenAPIBlueprintMixin.configure_openapi","title":"<code>configure_openapi(*, prefix_config=None, **kwargs)</code>","text":"<p>Configure OpenAPI settings for this Blueprint instance.</p> <p>Parameters:</p> Name Type Description Default <code>prefix_config</code> <code>ConventionalPrefixConfig</code> <p>Configuration object with parameter prefixes</p> <code>None</code> <code>**kwargs</code> <code>Any</code> <p>For backward compatibility - will be used to create a config object if prefix_config is None</p> <code>{}</code> Source code in <code>src/flask_x_openapi_schema/x/flask_restful/resources.py</code> <pre><code>def configure_openapi(self, *, prefix_config: ConventionalPrefixConfig = None, **kwargs: Any) -&gt; None:\n    \"\"\"Configure OpenAPI settings for this Blueprint instance.\n\n    Args:\n        prefix_config: Configuration object with parameter prefixes\n        **kwargs: For backward compatibility - will be used to create a config object if prefix_config is None\n\n    \"\"\"\n    if prefix_config is not None:\n        configure_prefixes(prefix_config)\n    elif kwargs:\n        new_config = ConventionalPrefixConfig(\n            request_body_prefix=kwargs.get(\n                \"request_body_prefix\",\n                GLOBAL_CONFIG_HOLDER.get().request_body_prefix,\n            ),\n            request_query_prefix=kwargs.get(\n                \"request_query_prefix\",\n                GLOBAL_CONFIG_HOLDER.get().request_query_prefix,\n            ),\n            request_path_prefix=kwargs.get(\n                \"request_path_prefix\",\n                GLOBAL_CONFIG_HOLDER.get().request_path_prefix,\n            ),\n            request_file_prefix=kwargs.get(\n                \"request_file_prefix\",\n                GLOBAL_CONFIG_HOLDER.get().request_file_prefix,\n            ),\n        )\n        configure_prefixes(new_config)\n</code></pre>"},{"location":"api/flask_restful/#flask_x_openapi_schema.x.flask_restful.OpenAPIBlueprintMixin.generate_openapi_schema","title":"<code>generate_openapi_schema(title, version, description='', output_format='yaml', language=None)</code>","text":"<p>Generate an OpenAPI schema for the API.</p> <p>Parameters:</p> Name Type Description Default <code>title</code> <code>str | I18nStr</code> <p>The title of the API (can be an I18nString).</p> required <code>version</code> <code>str</code> <p>The version of the API.</p> required <code>description</code> <code>str | I18nStr</code> <p>The description of the API (can be an I18nString).</p> <code>''</code> <code>output_format</code> <code>Literal['json', 'yaml']</code> <p>The output format (json or yaml).</p> <code>'yaml'</code> <code>language</code> <code>str | None</code> <p>The language to use for internationalized strings (default: current language).</p> <code>None</code> <p>Returns:</p> Type Description <code>Any</code> <p>The OpenAPI schema as a dictionary (if json) or string (if yaml).</p> Source code in <code>src/flask_x_openapi_schema/x/flask_restful/resources.py</code> <pre><code>def generate_openapi_schema(\n    self,\n    title: str | I18nStr,\n    version: str,\n    description: str | I18nStr = \"\",\n    output_format: Literal[\"json\", \"yaml\"] = \"yaml\",\n    language: str | None = None,\n) -&gt; Any:\n    \"\"\"Generate an OpenAPI schema for the API.\n\n    Args:\n        title: The title of the API (can be an I18nString).\n        version: The version of the API.\n        description: The description of the API (can be an I18nString).\n        output_format: The output format (json or yaml).\n        language: The language to use for internationalized strings (default: current language).\n\n    Returns:\n        The OpenAPI schema as a dictionary (if json) or string (if yaml).\n\n    \"\"\"\n    current_lang = language or get_current_language()\n\n    generator = MethodViewOpenAPISchemaGenerator(title, version, description, language=current_lang)\n\n    generator.process_methodview_resources(self)\n\n    schema = generator.generate_schema()\n\n    if output_format == \"yaml\":\n        return yaml.dump(schema, sort_keys=False, default_flow_style=False, allow_unicode=True)\n    return schema\n</code></pre>"},{"location":"api/flask_restful/#flask_x_openapi_schema.x.flask_restful.OpenAPIIntegrationMixin","title":"<code>OpenAPIIntegrationMixin</code>","text":"<p>               Bases: <code>Api</code></p> <p>A mixin class for the flask-restful Api to collect OpenAPI metadata.</p> <p>This mixin extends Flask-RESTful's Api class to add OpenAPI schema generation capabilities. It tracks resources added to the API and provides methods to generate OpenAPI schemas.</p> <p>Parameters:</p> Name Type Description Default <code>*args</code> <code>Any</code> <p>Arguments to pass to the parent class.</p> <code>()</code> <code>**kwargs</code> <code>Any</code> <p>Keyword arguments to pass to the parent class.</p> <code>{}</code> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from flask import Flask\n&gt;&gt;&gt; from flask_restful import Resource\n&gt;&gt;&gt; from flask_x_openapi_schema.x.flask_restful import OpenAPIIntegrationMixin, openapi_metadata\n&gt;&gt;&gt; from pydantic import BaseModel, Field\n&gt;&gt;&gt;\n&gt;&gt;&gt; app = Flask(__name__)\n&gt;&gt;&gt;\n&gt;&gt;&gt; class OpenAPIApi(OpenAPIIntegrationMixin):\n...     pass\n&gt;&gt;&gt;\n&gt;&gt;&gt; api = OpenAPIApi(app)\n&gt;&gt;&gt;\n&gt;&gt;&gt; class ItemResource(Resource):\n...     @openapi_metadata(summary=\"Get an item\")\n...     def get(self, item_id):\n...         return {\"id\": item_id, \"name\": \"Example Item\"}\n&gt;&gt;&gt;\n&gt;&gt;&gt; api.add_resource(ItemResource, \"/items/&lt;item_id&gt;\")\n&gt;&gt;&gt;\n&gt;&gt;&gt; # Generate OpenAPI schema\n&gt;&gt;&gt; schema = api.generate_openapi_schema(title=\"My API\", version=\"1.0.0\", description=\"API for managing items\")\n</code></pre> Source code in <code>src/flask_x_openapi_schema/x/flask_restful/resources.py</code> <pre><code>class OpenAPIIntegrationMixin(Api):\n    \"\"\"A mixin class for the flask-restful Api to collect OpenAPI metadata.\n\n    This mixin extends Flask-RESTful's Api class to add OpenAPI schema generation capabilities.\n    It tracks resources added to the API and provides methods to generate OpenAPI schemas.\n\n    Args:\n        *args: Arguments to pass to the parent class.\n        **kwargs: Keyword arguments to pass to the parent class.\n\n    Examples:\n        &gt;&gt;&gt; from flask import Flask\n        &gt;&gt;&gt; from flask_restful import Resource\n        &gt;&gt;&gt; from flask_x_openapi_schema.x.flask_restful import OpenAPIIntegrationMixin, openapi_metadata\n        &gt;&gt;&gt; from pydantic import BaseModel, Field\n        &gt;&gt;&gt;\n        &gt;&gt;&gt; app = Flask(__name__)\n        &gt;&gt;&gt;\n        &gt;&gt;&gt; class OpenAPIApi(OpenAPIIntegrationMixin):\n        ...     pass\n        &gt;&gt;&gt;\n        &gt;&gt;&gt; api = OpenAPIApi(app)\n        &gt;&gt;&gt;\n        &gt;&gt;&gt; class ItemResource(Resource):\n        ...     @openapi_metadata(summary=\"Get an item\")\n        ...     def get(self, item_id):\n        ...         return {\"id\": item_id, \"name\": \"Example Item\"}\n        &gt;&gt;&gt;\n        &gt;&gt;&gt; api.add_resource(ItemResource, \"/items/&lt;item_id&gt;\")\n        &gt;&gt;&gt;\n        &gt;&gt;&gt; # Generate OpenAPI schema\n        &gt;&gt;&gt; schema = api.generate_openapi_schema(title=\"My API\", version=\"1.0.0\", description=\"API for managing items\")\n\n    \"\"\"\n\n    def __init__(self, *args: Any, **kwargs: Any) -&gt; None:\n        \"\"\"Initialize the mixin.\n\n        Args:\n            *args: Arguments to pass to the parent class.\n            **kwargs: Keyword arguments to pass to the parent class.\n\n        \"\"\"\n        super().__init__(*args, **kwargs)\n\n        if not hasattr(self, \"resources\"):\n            self.resources = []\n\n    def add_resource(self, resource: Any, *urls: str, **kwargs: Any) -&gt; Any:\n        \"\"\"Add a resource to the API and register it for OpenAPI schema generation.\n\n        Args:\n            resource: The resource class.\n            *urls: The URLs to register the resource with.\n            **kwargs: Additional arguments to pass to the parent method.\n\n        Returns:\n            The result of the parent method.\n\n        \"\"\"\n        result = super().add_resource(resource, *urls, **kwargs)\n\n        if not hasattr(self, \"resources\"):\n            self.resources = []\n\n        for existing_resource, existing_urls, _ in self.resources:\n            if existing_resource == resource and set(existing_urls) == set(urls):\n                return result\n\n        if \"endpoint\" not in kwargs and kwargs is not None:\n            kwargs[\"endpoint\"] = resource.__name__.lower()\n        elif kwargs is None:\n            kwargs = {\"endpoint\": resource.__name__.lower()}\n\n        self.resources.append((resource, urls, kwargs))\n\n        return result\n\n    def configure_openapi(self, *, prefix_config: ConventionalPrefixConfig = None, **kwargs: Any) -&gt; None:\n        \"\"\"Configure OpenAPI settings for this API instance.\n\n        Args:\n            prefix_config: Configuration object with parameter prefixes\n            **kwargs: For backward compatibility - will be used to create a config object if prefix_config is None\n\n        \"\"\"\n        if prefix_config is not None:\n            configure_prefixes(prefix_config)\n        elif kwargs:\n            new_config = ConventionalPrefixConfig(\n                request_body_prefix=kwargs.get(\n                    \"request_body_prefix\",\n                    GLOBAL_CONFIG_HOLDER.get().request_body_prefix,\n                ),\n                request_query_prefix=kwargs.get(\n                    \"request_query_prefix\",\n                    GLOBAL_CONFIG_HOLDER.get().request_query_prefix,\n                ),\n                request_path_prefix=kwargs.get(\n                    \"request_path_prefix\",\n                    GLOBAL_CONFIG_HOLDER.get().request_path_prefix,\n                ),\n                request_file_prefix=kwargs.get(\n                    \"request_file_prefix\",\n                    GLOBAL_CONFIG_HOLDER.get().request_file_prefix,\n                ),\n            )\n            configure_prefixes(new_config)\n\n    def generate_openapi_schema(\n        self,\n        title: str | I18nStr,\n        version: str,\n        description: str | I18nStr = \"\",\n        output_format: Literal[\"json\", \"yaml\"] = \"yaml\",\n        language: str | None = None,\n    ) -&gt; Any:\n        \"\"\"Generate an OpenAPI schema for the API.\n\n        This method generates an OpenAPI schema for all resources registered with the API.\n        It supports internationalization through I18nStr objects and can output the schema\n        in either JSON or YAML format.\n\n        Args:\n            title: The title of the API (can be an I18nString).\n            version: The version of the API.\n            description: The description of the API (can be an I18nString).\n            output_format: The output format (json or yaml).\n            language: The language to use for internationalized strings (default: current language).\n\n        Returns:\n            The OpenAPI schema as a dictionary (if json) or string (if yaml).\n\n        Examples:\n            &gt;&gt;&gt; from flask import Flask\n            &gt;&gt;&gt; from flask_restful import Resource\n            &gt;&gt;&gt; from flask_x_openapi_schema.x.flask_restful import OpenAPIIntegrationMixin, openapi_metadata\n            &gt;&gt;&gt; app = Flask(__name__)\n            &gt;&gt;&gt; class OpenAPIApi(OpenAPIIntegrationMixin):\n            ...     pass\n            &gt;&gt;&gt; api = OpenAPIApi(app)\n            &gt;&gt;&gt; yaml_schema = api.generate_openapi_schema(\n            ...     title=\"My API\", version=\"1.0.0\", description=\"API for managing items\"\n            ... )\n            &gt;&gt;&gt;\n            &gt;&gt;&gt; json_schema = api.generate_openapi_schema(\n            ...     title=\"My API\", version=\"1.0.0\", description=\"API for managing items\", output_format=\"json\"\n            ... )\n            &gt;&gt;&gt;\n            &gt;&gt;&gt; from flask_x_openapi_schema import I18nStr\n            &gt;&gt;&gt; i18n_schema = api.generate_openapi_schema(\n            ...     title=I18nStr({\"en-US\": \"My API\", \"zh-Hans\": \"\u6211\u7684API\"}),\n            ...     version=\"1.0.0\",\n            ...     description=I18nStr({\"en-US\": \"API for managing items\", \"zh-Hans\": \"\u7528\u4e8e\u7ba1\u7406\u9879\u76ee\u7684API\"}),\n            ...     language=\"zh-Hans\",\n            ... )\n\n        \"\"\"\n        current_lang = language or get_current_language()\n\n        generator = OpenAPISchemaGenerator(title, version, description, language=current_lang)\n\n        url_prefix = None\n        if hasattr(self, \"blueprint\") and hasattr(self.blueprint, \"url_prefix\"):\n            url_prefix = self.blueprint.url_prefix\n\n        for resource, urls, _ in self.resources:\n            generator._process_resource(resource, urls, url_prefix)\n\n        schema = generator.generate_schema()\n\n        if output_format == \"yaml\":\n            return yaml.dump(schema, sort_keys=False, default_flow_style=False, allow_unicode=True)\n        return schema\n</code></pre>"},{"location":"api/flask_restful/#flask_x_openapi_schema.x.flask_restful.OpenAPIIntegrationMixin.__init__","title":"<code>__init__(*args, **kwargs)</code>","text":"<p>Initialize the mixin.</p> <p>Parameters:</p> Name Type Description Default <code>*args</code> <code>Any</code> <p>Arguments to pass to the parent class.</p> <code>()</code> <code>**kwargs</code> <code>Any</code> <p>Keyword arguments to pass to the parent class.</p> <code>{}</code> Source code in <code>src/flask_x_openapi_schema/x/flask_restful/resources.py</code> <pre><code>def __init__(self, *args: Any, **kwargs: Any) -&gt; None:\n    \"\"\"Initialize the mixin.\n\n    Args:\n        *args: Arguments to pass to the parent class.\n        **kwargs: Keyword arguments to pass to the parent class.\n\n    \"\"\"\n    super().__init__(*args, **kwargs)\n\n    if not hasattr(self, \"resources\"):\n        self.resources = []\n</code></pre>"},{"location":"api/flask_restful/#flask_x_openapi_schema.x.flask_restful.OpenAPIIntegrationMixin.add_resource","title":"<code>add_resource(resource, *urls, **kwargs)</code>","text":"<p>Add a resource to the API and register it for OpenAPI schema generation.</p> <p>Parameters:</p> Name Type Description Default <code>resource</code> <code>Any</code> <p>The resource class.</p> required <code>*urls</code> <code>str</code> <p>The URLs to register the resource with.</p> <code>()</code> <code>**kwargs</code> <code>Any</code> <p>Additional arguments to pass to the parent method.</p> <code>{}</code> <p>Returns:</p> Type Description <code>Any</code> <p>The result of the parent method.</p> Source code in <code>src/flask_x_openapi_schema/x/flask_restful/resources.py</code> <pre><code>def add_resource(self, resource: Any, *urls: str, **kwargs: Any) -&gt; Any:\n    \"\"\"Add a resource to the API and register it for OpenAPI schema generation.\n\n    Args:\n        resource: The resource class.\n        *urls: The URLs to register the resource with.\n        **kwargs: Additional arguments to pass to the parent method.\n\n    Returns:\n        The result of the parent method.\n\n    \"\"\"\n    result = super().add_resource(resource, *urls, **kwargs)\n\n    if not hasattr(self, \"resources\"):\n        self.resources = []\n\n    for existing_resource, existing_urls, _ in self.resources:\n        if existing_resource == resource and set(existing_urls) == set(urls):\n            return result\n\n    if \"endpoint\" not in kwargs and kwargs is not None:\n        kwargs[\"endpoint\"] = resource.__name__.lower()\n    elif kwargs is None:\n        kwargs = {\"endpoint\": resource.__name__.lower()}\n\n    self.resources.append((resource, urls, kwargs))\n\n    return result\n</code></pre>"},{"location":"api/flask_restful/#flask_x_openapi_schema.x.flask_restful.OpenAPIIntegrationMixin.configure_openapi","title":"<code>configure_openapi(*, prefix_config=None, **kwargs)</code>","text":"<p>Configure OpenAPI settings for this API instance.</p> <p>Parameters:</p> Name Type Description Default <code>prefix_config</code> <code>ConventionalPrefixConfig</code> <p>Configuration object with parameter prefixes</p> <code>None</code> <code>**kwargs</code> <code>Any</code> <p>For backward compatibility - will be used to create a config object if prefix_config is None</p> <code>{}</code> Source code in <code>src/flask_x_openapi_schema/x/flask_restful/resources.py</code> <pre><code>def configure_openapi(self, *, prefix_config: ConventionalPrefixConfig = None, **kwargs: Any) -&gt; None:\n    \"\"\"Configure OpenAPI settings for this API instance.\n\n    Args:\n        prefix_config: Configuration object with parameter prefixes\n        **kwargs: For backward compatibility - will be used to create a config object if prefix_config is None\n\n    \"\"\"\n    if prefix_config is not None:\n        configure_prefixes(prefix_config)\n    elif kwargs:\n        new_config = ConventionalPrefixConfig(\n            request_body_prefix=kwargs.get(\n                \"request_body_prefix\",\n                GLOBAL_CONFIG_HOLDER.get().request_body_prefix,\n            ),\n            request_query_prefix=kwargs.get(\n                \"request_query_prefix\",\n                GLOBAL_CONFIG_HOLDER.get().request_query_prefix,\n            ),\n            request_path_prefix=kwargs.get(\n                \"request_path_prefix\",\n                GLOBAL_CONFIG_HOLDER.get().request_path_prefix,\n            ),\n            request_file_prefix=kwargs.get(\n                \"request_file_prefix\",\n                GLOBAL_CONFIG_HOLDER.get().request_file_prefix,\n            ),\n        )\n        configure_prefixes(new_config)\n</code></pre>"},{"location":"api/flask_restful/#flask_x_openapi_schema.x.flask_restful.OpenAPIIntegrationMixin.generate_openapi_schema","title":"<code>generate_openapi_schema(title, version, description='', output_format='yaml', language=None)</code>","text":"<p>Generate an OpenAPI schema for the API.</p> <p>This method generates an OpenAPI schema for all resources registered with the API. It supports internationalization through I18nStr objects and can output the schema in either JSON or YAML format.</p> <p>Parameters:</p> Name Type Description Default <code>title</code> <code>str | I18nStr</code> <p>The title of the API (can be an I18nString).</p> required <code>version</code> <code>str</code> <p>The version of the API.</p> required <code>description</code> <code>str | I18nStr</code> <p>The description of the API (can be an I18nString).</p> <code>''</code> <code>output_format</code> <code>Literal['json', 'yaml']</code> <p>The output format (json or yaml).</p> <code>'yaml'</code> <code>language</code> <code>str | None</code> <p>The language to use for internationalized strings (default: current language).</p> <code>None</code> <p>Returns:</p> Type Description <code>Any</code> <p>The OpenAPI schema as a dictionary (if json) or string (if yaml).</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from flask import Flask\n&gt;&gt;&gt; from flask_restful import Resource\n&gt;&gt;&gt; from flask_x_openapi_schema.x.flask_restful import OpenAPIIntegrationMixin, openapi_metadata\n&gt;&gt;&gt; app = Flask(__name__)\n&gt;&gt;&gt; class OpenAPIApi(OpenAPIIntegrationMixin):\n...     pass\n&gt;&gt;&gt; api = OpenAPIApi(app)\n&gt;&gt;&gt; yaml_schema = api.generate_openapi_schema(\n...     title=\"My API\", version=\"1.0.0\", description=\"API for managing items\"\n... )\n&gt;&gt;&gt;\n&gt;&gt;&gt; json_schema = api.generate_openapi_schema(\n...     title=\"My API\", version=\"1.0.0\", description=\"API for managing items\", output_format=\"json\"\n... )\n&gt;&gt;&gt;\n&gt;&gt;&gt; from flask_x_openapi_schema import I18nStr\n&gt;&gt;&gt; i18n_schema = api.generate_openapi_schema(\n...     title=I18nStr({\"en-US\": \"My API\", \"zh-Hans\": \"\u6211\u7684API\"}),\n...     version=\"1.0.0\",\n...     description=I18nStr({\"en-US\": \"API for managing items\", \"zh-Hans\": \"\u7528\u4e8e\u7ba1\u7406\u9879\u76ee\u7684API\"}),\n...     language=\"zh-Hans\",\n... )\n</code></pre> Source code in <code>src/flask_x_openapi_schema/x/flask_restful/resources.py</code> <pre><code>def generate_openapi_schema(\n    self,\n    title: str | I18nStr,\n    version: str,\n    description: str | I18nStr = \"\",\n    output_format: Literal[\"json\", \"yaml\"] = \"yaml\",\n    language: str | None = None,\n) -&gt; Any:\n    \"\"\"Generate an OpenAPI schema for the API.\n\n    This method generates an OpenAPI schema for all resources registered with the API.\n    It supports internationalization through I18nStr objects and can output the schema\n    in either JSON or YAML format.\n\n    Args:\n        title: The title of the API (can be an I18nString).\n        version: The version of the API.\n        description: The description of the API (can be an I18nString).\n        output_format: The output format (json or yaml).\n        language: The language to use for internationalized strings (default: current language).\n\n    Returns:\n        The OpenAPI schema as a dictionary (if json) or string (if yaml).\n\n    Examples:\n        &gt;&gt;&gt; from flask import Flask\n        &gt;&gt;&gt; from flask_restful import Resource\n        &gt;&gt;&gt; from flask_x_openapi_schema.x.flask_restful import OpenAPIIntegrationMixin, openapi_metadata\n        &gt;&gt;&gt; app = Flask(__name__)\n        &gt;&gt;&gt; class OpenAPIApi(OpenAPIIntegrationMixin):\n        ...     pass\n        &gt;&gt;&gt; api = OpenAPIApi(app)\n        &gt;&gt;&gt; yaml_schema = api.generate_openapi_schema(\n        ...     title=\"My API\", version=\"1.0.0\", description=\"API for managing items\"\n        ... )\n        &gt;&gt;&gt;\n        &gt;&gt;&gt; json_schema = api.generate_openapi_schema(\n        ...     title=\"My API\", version=\"1.0.0\", description=\"API for managing items\", output_format=\"json\"\n        ... )\n        &gt;&gt;&gt;\n        &gt;&gt;&gt; from flask_x_openapi_schema import I18nStr\n        &gt;&gt;&gt; i18n_schema = api.generate_openapi_schema(\n        ...     title=I18nStr({\"en-US\": \"My API\", \"zh-Hans\": \"\u6211\u7684API\"}),\n        ...     version=\"1.0.0\",\n        ...     description=I18nStr({\"en-US\": \"API for managing items\", \"zh-Hans\": \"\u7528\u4e8e\u7ba1\u7406\u9879\u76ee\u7684API\"}),\n        ...     language=\"zh-Hans\",\n        ... )\n\n    \"\"\"\n    current_lang = language or get_current_language()\n\n    generator = OpenAPISchemaGenerator(title, version, description, language=current_lang)\n\n    url_prefix = None\n    if hasattr(self, \"blueprint\") and hasattr(self.blueprint, \"url_prefix\"):\n        url_prefix = self.blueprint.url_prefix\n\n    for resource, urls, _ in self.resources:\n        generator._process_resource(resource, urls, url_prefix)\n\n    schema = generator.generate_schema()\n\n    if output_format == \"yaml\":\n        return yaml.dump(schema, sort_keys=False, default_flow_style=False, allow_unicode=True)\n    return schema\n</code></pre>"},{"location":"api/flask_restful/#flask_x_openapi_schema.x.flask_restful.openapi_metadata","title":"<code>openapi_metadata(*, summary=None, description=None, tags=None, operation_id=None, deprecated=False, responses=None, security=None, external_docs=None, language=None, prefix_config=None, content_type=None, request_content_types=None, response_content_types=None, content_type_resolver=None)</code>","text":"<p>Decorator to add OpenAPI metadata to a Flask-RESTful Resource endpoint.</p> <p>This decorator adds OpenAPI metadata to a Flask-RESTful Resource endpoint and handles parameter binding for request data. It automatically binds request body, query parameters, path parameters, and file uploads to function parameters based on their type annotations and parameter name prefixes.</p> <p>Parameters:</p> Name Type Description Default <code>summary</code> <code>str | I18nStr | None</code> <p>A short summary of what the operation does.</p> <code>None</code> <code>description</code> <code>str | I18nStr | None</code> <p>A verbose explanation of the operation behavior.</p> <code>None</code> <code>tags</code> <code>list[str] | None</code> <p>A list of tags for API documentation control.</p> <code>None</code> <code>operation_id</code> <code>str | None</code> <p>Unique string used to identify the operation.</p> <code>None</code> <code>deprecated</code> <code>bool</code> <p>Declares this operation to be deprecated.</p> <code>False</code> <code>responses</code> <code>OpenAPIMetaResponse | None</code> <p>The responses the API can return.</p> <code>None</code> <code>security</code> <code>list[dict[str, list[str]]] | None</code> <p>A declaration of which security mechanisms can be used for this operation.</p> <code>None</code> <code>external_docs</code> <code>dict[str, str] | None</code> <p>Additional external documentation.</p> <code>None</code> <code>language</code> <code>str | None</code> <p>Language code to use for I18nString values (default: current language).</p> <code>None</code> <code>prefix_config</code> <code>ConventionalPrefixConfig | None</code> <p>Configuration object for parameter prefixes.</p> <code>None</code> <code>content_type</code> <code>str | None</code> <p>Custom content type for request body. If None, will be auto-detected.</p> <code>None</code> <code>request_content_types</code> <code>RequestContentTypes | None</code> <p>Multiple content types for request body.</p> <code>None</code> <code>response_content_types</code> <code>ResponseContentTypes | None</code> <p>Multiple content types for response body.</p> <code>None</code> <code>content_type_resolver</code> <code>Callable[[Any], str] | None</code> <p>Function to determine content type based on request.</p> <code>None</code> <p>Returns:</p> Type Description <code>Callable[[F], F] | F</code> <p>The decorated function with OpenAPI metadata attached.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from flask_restful import Resource\n&gt;&gt;&gt; from flask_x_openapi_schema.x.flask_restful import openapi_metadata\n&gt;&gt;&gt; from flask_x_openapi_schema import OpenAPIMetaResponse, OpenAPIMetaResponseItem\n&gt;&gt;&gt; from pydantic import BaseModel, Field\n&gt;&gt;&gt;\n&gt;&gt;&gt; class ItemRequest(BaseModel):\n...     name: str = Field(..., description=\"Item name\")\n...     price: float = Field(..., description=\"Item price\")\n&gt;&gt;&gt;\n&gt;&gt;&gt; class ItemResponse(BaseModel):\n...     id: str = Field(..., description=\"Item ID\")\n...     name: str = Field(..., description=\"Item name\")\n...     price: float = Field(..., description=\"Item price\")\n&gt;&gt;&gt;\n&gt;&gt;&gt; class ItemResource(Resource):\n...     @openapi_metadata(\n...         summary=\"Create a new item\",\n...         description=\"Create a new item with the provided information\",\n...         tags=[\"items\"],\n...         operation_id=\"createItem\",\n...         responses=OpenAPIMetaResponse(\n...             responses={\n...                 \"201\": OpenAPIMetaResponseItem(model=ItemResponse, description=\"Item created successfully\"),\n...                 \"400\": OpenAPIMetaResponseItem(description=\"Invalid request data\"),\n...             }\n...         ),\n...     )\n...     def post(self, _x_body: ItemRequest):\n...         item = {\"id\": \"123\", \"name\": _x_body.name, \"price\": _x_body.price}\n...         return item, 201\n</code></pre> Source code in <code>src/flask_x_openapi_schema/x/flask_restful/decorators.py</code> <pre><code>def openapi_metadata(\n    *,\n    summary: str | I18nStr | None = None,\n    description: str | I18nStr | None = None,\n    tags: list[str] | None = None,\n    operation_id: str | None = None,\n    deprecated: bool = False,\n    responses: OpenAPIMetaResponse | None = None,\n    security: list[dict[str, list[str]]] | None = None,\n    external_docs: dict[str, str] | None = None,\n    language: str | None = None,\n    prefix_config: ConventionalPrefixConfig | None = None,\n    content_type: str | None = None,\n    request_content_types: RequestContentTypes | None = None,\n    response_content_types: ResponseContentTypes | None = None,\n    content_type_resolver: Callable[[Any], str] | None = None,\n) -&gt; Callable[[F], F] | F:\n    \"\"\"Decorator to add OpenAPI metadata to a Flask-RESTful Resource endpoint.\n\n    This decorator adds OpenAPI metadata to a Flask-RESTful Resource endpoint and handles\n    parameter binding for request data. It automatically binds request body, query parameters,\n    path parameters, and file uploads to function parameters based on their type annotations\n    and parameter name prefixes.\n\n    Args:\n        summary: A short summary of what the operation does.\n        description: A verbose explanation of the operation behavior.\n        tags: A list of tags for API documentation control.\n        operation_id: Unique string used to identify the operation.\n        deprecated: Declares this operation to be deprecated.\n        responses: The responses the API can return.\n        security: A declaration of which security mechanisms can be used for this operation.\n        external_docs: Additional external documentation.\n        language: Language code to use for I18nString values (default: current language).\n        prefix_config: Configuration object for parameter prefixes.\n        content_type: Custom content type for request body. If None, will be auto-detected.\n        request_content_types: Multiple content types for request body.\n        response_content_types: Multiple content types for response body.\n        content_type_resolver: Function to determine content type based on request.\n\n\n    Returns:\n        The decorated function with OpenAPI metadata attached.\n\n    Examples:\n        &gt;&gt;&gt; from flask_restful import Resource\n        &gt;&gt;&gt; from flask_x_openapi_schema.x.flask_restful import openapi_metadata\n        &gt;&gt;&gt; from flask_x_openapi_schema import OpenAPIMetaResponse, OpenAPIMetaResponseItem\n        &gt;&gt;&gt; from pydantic import BaseModel, Field\n        &gt;&gt;&gt;\n        &gt;&gt;&gt; class ItemRequest(BaseModel):\n        ...     name: str = Field(..., description=\"Item name\")\n        ...     price: float = Field(..., description=\"Item price\")\n        &gt;&gt;&gt;\n        &gt;&gt;&gt; class ItemResponse(BaseModel):\n        ...     id: str = Field(..., description=\"Item ID\")\n        ...     name: str = Field(..., description=\"Item name\")\n        ...     price: float = Field(..., description=\"Item price\")\n        &gt;&gt;&gt;\n        &gt;&gt;&gt; class ItemResource(Resource):\n        ...     @openapi_metadata(\n        ...         summary=\"Create a new item\",\n        ...         description=\"Create a new item with the provided information\",\n        ...         tags=[\"items\"],\n        ...         operation_id=\"createItem\",\n        ...         responses=OpenAPIMetaResponse(\n        ...             responses={\n        ...                 \"201\": OpenAPIMetaResponseItem(model=ItemResponse, description=\"Item created successfully\"),\n        ...                 \"400\": OpenAPIMetaResponseItem(description=\"Invalid request data\"),\n        ...             }\n        ...         ),\n        ...     )\n        ...     def post(self, _x_body: ItemRequest):\n        ...         item = {\"id\": \"123\", \"name\": _x_body.name, \"price\": _x_body.price}\n        ...         return item, 201\n\n    \"\"\"\n    return FlaskRestfulOpenAPIDecorator(\n        summary=summary,\n        description=description,\n        tags=tags,\n        operation_id=operation_id,\n        responses=responses,\n        deprecated=deprecated,\n        security=security,\n        external_docs=external_docs,\n        language=language,\n        prefix_config=prefix_config,\n        content_type=content_type,\n        request_content_types=request_content_types,\n        response_content_types=response_content_types,\n        content_type_resolver=content_type_resolver,\n    )\n</code></pre>"},{"location":"api/flask_restful/#decorators","title":"Decorators","text":"<p>Decorators for adding OpenAPI metadata to Flask-RESTful Resource endpoints.</p> <p>This module provides decorators and utilities for adding OpenAPI metadata to Flask-RESTful Resource class methods. It enables automatic parameter binding, request validation, and OpenAPI schema generation for Flask-RESTful APIs.</p> <p>The main decorator <code>openapi_metadata</code> can be applied to Resource methods to add OpenAPI metadata and enable automatic parameter binding based on type annotations.</p> <p>Examples:</p> <p>Basic usage with Flask-RESTful Resource:</p> <pre><code>&gt;&gt;&gt; from flask_restful import Resource\n&gt;&gt;&gt; from flask_x_openapi_schema.x.flask_restful import openapi_metadata\n&gt;&gt;&gt; from pydantic import BaseModel, Field\n&gt;&gt;&gt;\n&gt;&gt;&gt; class UserModel(BaseModel):\n...     name: str = Field(..., description=\"User name\")\n...     age: int = Field(..., description=\"User age\")\n&gt;&gt;&gt;\n&gt;&gt;&gt; class UserResource(Resource):\n...     @openapi_metadata(summary=\"Create user\", tags=[\"users\"])\n...     def post(self, _x_body: UserModel):\n...         return {\"name\": _x_body.name, \"age\": _x_body.age}, 201\n</code></pre>"},{"location":"api/flask_restful/#flask_x_openapi_schema.x.flask_restful.decorators.FlaskRestfulOpenAPIDecorator","title":"<code>FlaskRestfulOpenAPIDecorator</code>","text":"<p>               Bases: <code>DecoratorBase</code></p> <p>OpenAPI metadata decorator for Flask-RESTful Resource.</p> <p>This class implements the decorator functionality for adding OpenAPI metadata to Flask-RESTful Resource methods. It handles parameter binding, request processing, and OpenAPI schema generation.</p> <p>Attributes:</p> Name Type Description <code>summary</code> <code>str | I18nStr | None</code> <p>A short summary of what the operation does.</p> <code>description</code> <code>str | I18nStr | None</code> <p>A verbose explanation of the operation behavior.</p> <code>tags</code> <code>list[str] | None</code> <p>A list of tags for API documentation control.</p> <code>operation_id</code> <code>str | None</code> <p>Unique string used to identify the operation.</p> <code>responses</code> <code>OpenAPIMetaResponse | None</code> <p>The responses the API can return.</p> <code>deprecated</code> <code>bool</code> <p>Declares this operation to be deprecated.</p> <code>security</code> <code>list[dict[str, list[str]]] | None</code> <p>Security mechanisms for this operation.</p> <code>external_docs</code> <code>dict[str, str] | None</code> <p>Additional external documentation.</p> <code>language</code> <code>str | None</code> <p>Language code to use for I18nString values.</p> <code>prefix_config</code> <code>ConventionalPrefixConfig | None</code> <p>Configuration for parameter prefixes.</p> <code>framework</code> <code>str</code> <p>The framework being used ('flask_restful').</p> <code>base_decorator</code> <code>OpenAPIDecoratorBase | None</code> <p>The base decorator instance.</p> <code>parsed_args</code> <code>Any | None</code> <p>Parsed arguments from request parser.</p> Source code in <code>src/flask_x_openapi_schema/x/flask_restful/decorators.py</code> <pre><code>class FlaskRestfulOpenAPIDecorator(DecoratorBase):\n    \"\"\"OpenAPI metadata decorator for Flask-RESTful Resource.\n\n    This class implements the decorator functionality for adding OpenAPI metadata\n    to Flask-RESTful Resource methods. It handles parameter binding, request processing,\n    and OpenAPI schema generation.\n\n    Attributes:\n        summary (str | I18nStr | None): A short summary of what the operation does.\n        description (str | I18nStr | None): A verbose explanation of the operation behavior.\n        tags (list[str] | None): A list of tags for API documentation control.\n        operation_id (str | None): Unique string used to identify the operation.\n        responses (OpenAPIMetaResponse | None): The responses the API can return.\n        deprecated (bool): Declares this operation to be deprecated.\n        security (list[dict[str, list[str]]] | None): Security mechanisms for this operation.\n        external_docs (dict[str, str] | None): Additional external documentation.\n        language (str | None): Language code to use for I18nString values.\n        prefix_config (ConventionalPrefixConfig | None): Configuration for parameter prefixes.\n        framework (str): The framework being used ('flask_restful').\n        base_decorator (OpenAPIDecoratorBase | None): The base decorator instance.\n        parsed_args (Any | None): Parsed arguments from request parser.\n\n    \"\"\"\n\n    def __init__(\n        self,\n        summary: str | I18nStr | None = None,\n        description: str | I18nStr | None = None,\n        tags: list[str] | None = None,\n        operation_id: str | None = None,\n        responses: OpenAPIMetaResponse | None = None,\n        deprecated: bool = False,\n        security: list[dict[str, list[str]]] | None = None,\n        external_docs: dict[str, str] | None = None,\n        language: str | None = None,\n        prefix_config: ConventionalPrefixConfig | None = None,\n        content_type: str | None = None,\n        request_content_types: RequestContentTypes | None = None,\n        response_content_types: ResponseContentTypes | None = None,\n        content_type_resolver: Callable[[Any], str] | None = None,\n    ) -&gt; None:\n        \"\"\"Initialize the decorator with OpenAPI metadata parameters.\n\n        Args:\n            summary: A short summary of what the operation does.\n            description: A verbose explanation of the operation behavior.\n            tags: A list of tags for API documentation control.\n            operation_id: Unique string used to identify the operation.\n            responses: The responses the API can return.\n            deprecated: Declares this operation to be deprecated.\n            security: A declaration of which security mechanisms can be used for this operation.\n            external_docs: Additional external documentation.\n            language: Language code to use for I18nString values.\n            prefix_config: Configuration object for parameter prefixes.\n            content_type: Custom content type for request body. If None, will be auto-detected.\n            request_content_types: Multiple content types for request body.\n            response_content_types: Multiple content types for response body.\n            content_type_resolver: Function to determine content type based on request.\n\n        \"\"\"\n        super().__init__(\n            summary=summary,\n            description=description,\n            tags=tags,\n            operation_id=operation_id,\n            responses=responses,\n            deprecated=deprecated,\n            security=security,\n            external_docs=external_docs,\n            language=language,\n            prefix_config=prefix_config,\n            content_type=content_type,\n            request_content_types=request_content_types,\n            response_content_types=response_content_types,\n            content_type_resolver=content_type_resolver,\n        )\n        self.framework = \"flask_restful\"\n        self.base_decorator = None\n        self.parsed_args = None\n\n    def __call__(self, func: Callable[..., Any]) -&gt; Callable[..., Any]:\n        \"\"\"Apply the decorator to the function.\n\n        Args:\n            func: The function to decorate.\n\n        Returns:\n            The decorated function.\n\n        \"\"\"\n        if self.base_decorator is None:\n            self.base_decorator = OpenAPIDecoratorBase(\n                summary=self.summary,\n                description=self.description,\n                tags=self.tags,\n                operation_id=self.operation_id,\n                responses=self.responses,\n                deprecated=self.deprecated,\n                security=self.security,\n                external_docs=self.external_docs,\n                language=self.language,\n                prefix_config=self.prefix_config,\n                framework=self.framework,\n                content_type=self.content_type,\n                request_content_types=self.request_content_types,\n                response_content_types=self.response_content_types,\n                content_type_resolver=self.content_type_resolver,\n            )\n        return self.base_decorator(func)\n\n    def extract_parameters_from_models(\n        self,\n        query_model: type[BaseModel] | None,\n        path_params: list[str] | None,\n    ) -&gt; list[dict[str, Any]]:\n        \"\"\"Extract OpenAPI parameters from models.\n\n        Converts Pydantic models and path parameters into OpenAPI parameter objects.\n\n        Args:\n            query_model: Pydantic model for query parameters.\n            path_params: List of path parameter names.\n\n        Returns:\n            List of OpenAPI parameter objects.\n\n        \"\"\"\n        parameters = []\n\n        if path_params:\n            parameters.extend(\n                [\n                    {\n                        \"name\": param,\n                        \"in\": \"path\",\n                        \"required\": True,\n                        \"schema\": {\"type\": \"string\"},\n                    }\n                    for param in path_params\n                ],\n            )\n\n        if query_model:\n            schema = query_model.model_json_schema()\n            properties = schema.get(\"properties\", {})\n            required = schema.get(\"required\", [])\n\n            for field_name, field_schema in properties.items():\n                param = {\n                    \"name\": field_name,\n                    \"in\": \"query\",\n                    \"required\": field_name in required,\n                    \"schema\": field_schema,\n                }\n\n                if \"description\" in field_schema:\n                    param[\"description\"] = field_schema[\"description\"]\n\n                parameters.append(param)\n\n        return parameters\n\n    def process_request_body(self, param_name: str, model: type[BaseModel], kwargs: dict[str, Any]) -&gt; dict[str, Any]:\n        \"\"\"Process request body parameters for Flask-RESTful.\n\n        Args:\n            param_name: The parameter name to bind the model instance to\n            model: The Pydantic model class to use for validation\n            kwargs: The keyword arguments to update\n\n        Returns:\n            Updated kwargs dictionary with the model instance\n\n        \"\"\"\n        logger = get_logger(__name__)\n        logger.debug(f\"Processing request body for {param_name} with model {model.__name__}\")\n\n        is_multipart = False\n        if hasattr(model, \"model_config\"):\n            config = getattr(model, \"model_config\", {})\n            if isinstance(config, dict) and config.get(\"json_schema_extra\", {}).get(\"multipart/form-data\", False):\n                is_multipart = True\n        elif hasattr(model, \"Config\") and hasattr(model.Config, \"json_schema_extra\"):\n            config_extra = getattr(model.Config, \"json_schema_extra\", {})\n            is_multipart = config_extra.get(\"multipart/form-data\", False)\n\n        has_file_fields = self._check_for_file_fields(model)\n\n        if (has_file_fields or is_multipart) and (request.files or request.form):\n            result = self._process_file_upload_model(model)\n\n            if isinstance(result, BaseErrorResponse):\n                response_dict, status_code = result.to_response(400)\n                return make_response(response_dict, status_code)\n\n            if result is not None:\n                kwargs[param_name] = result\n                return kwargs\n\n        processed_kwargs = super().process_request_body(param_name, model, kwargs.copy())\n        if param_name in processed_kwargs:\n            return processed_kwargs\n\n        json_model_instance = request_processor.process_request_data(request, model, param_name)\n        if json_model_instance:\n            logger.debug(f\"Successfully created model instance from request data for {param_name}\")\n            kwargs[param_name] = json_model_instance\n            return kwargs\n\n        effective_content_type = self.content_type or request.content_type or \"\"\n        if \"form\" in effective_content_type or \"multipart\" in effective_content_type:\n            parser_location = \"form\"\n        elif \"json\" in effective_content_type:\n            parser_location = \"json\"\n        elif any(\n            binary_type in effective_content_type\n            for binary_type in [\"image/\", \"audio/\", \"video/\", \"application/octet-stream\"]\n        ):\n            parser_location = \"binary\"\n        elif \"text/event-stream\" in effective_content_type:\n            parser_location = \"json\"\n        else:\n            parser_location = \"form\" if is_multipart else \"json\"\n\n        logger.debug(f\"Using parser location: {parser_location}\")\n\n        parser = self._get_or_create_parser(model, location=parser_location)\n        self.parsed_args = parser.parse_args()\n\n        if self.parsed_args:\n            try:\n                processed_data = preprocess_request_data(self.parsed_args, model)\n                model_instance = safe_operation(\n                    lambda: ModelFactory.create_from_data(model, processed_data), fallback=None\n                )\n                if model_instance:\n                    logger.debug(f\"Successfully created model instance from reqparse for {param_name}\")\n                    kwargs[param_name] = model_instance\n                    return kwargs\n            except Exception:\n                logger.exception(\"Error processing reqparse data\")\n\n        logger.warning(f\"No valid request data found for {param_name}, creating default instance\")\n        try:\n            model_instance = safe_operation(lambda: model(), fallback=None)\n            if model_instance:\n                logger.debug(f\"Created empty model instance for {param_name}\")\n                kwargs[param_name] = model_instance\n        except Exception:\n            logger.exception(\"Failed to create default model instance\")\n\n        return kwargs\n\n    def _check_for_file_fields(self, model: type[BaseModel]) -&gt; bool:\n        \"\"\"Check if a model contains file upload fields.\n\n        Args:\n            model: The model to check\n\n        Returns:\n            True if the model has file fields, False otherwise\n\n        \"\"\"\n        if not hasattr(model, \"model_fields\"):\n            return False\n\n        for field_info in model.model_fields.values():\n            field_type = field_info.annotation\n\n            if inspect.isclass(field_type) and issubclass(field_type, FileField):\n                return True\n\n            origin = getattr(field_type, \"__origin__\", None)\n            if origin is list or origin is list:\n                args = getattr(field_type, \"__args__\", [])\n                if args and isinstance(args[0], type) and issubclass(args[0], FileField):\n                    return True\n\n        return False\n\n    def _process_file_upload_model(self, model: type[BaseModel]) -&gt; BaseModel:\n        \"\"\"Process a file upload model with form data and files.\n\n        Args:\n            model: The model class to instantiate\n\n        Returns:\n            An instance of the model with file data\n\n        \"\"\"\n        logger = get_logger(__name__)\n        logger.debug(f\"Processing file upload model for {model.__name__}\")\n\n        model_data = dict(request.form.items())\n        logger.debug(f\"Form data: {model_data}\")\n\n        has_file_fields = False\n        file_field_names = []\n\n        for field_name, field_info in model.model_fields.items():\n            field_type = field_info.annotation\n\n            if inspect.isclass(field_type) and issubclass(field_type, FileField):\n                has_file_fields = True\n                file_field_names.append(field_name)\n                continue\n\n            origin = getattr(field_type, \"__origin__\", None)\n            if origin is list or origin is list:\n                args = getattr(field_type, \"__args__\", [])\n                if args and isinstance(args[0], type) and issubclass(args[0], FileField):\n                    has_file_fields = True\n                    file_field_names.append(field_name)\n\n        files_found = False\n\n        for field_name, field_info in model.model_fields.items():\n            field_type = field_info.annotation\n\n            if inspect.isclass(field_type) and issubclass(field_type, FileField):\n                if field_name in request.files:\n                    model_data[field_name] = request.files[field_name]\n                    files_found = True\n                    logger.debug(f\"Found file for field {field_name}: {request.files[field_name].filename}\")\n                elif \"file\" in request.files and field_name == \"file\":\n                    model_data[field_name] = request.files[\"file\"]\n                    files_found = True\n                    logger.debug(f\"Using default file for field {field_name}: {request.files['file'].filename}\")\n                elif \"avatar\" in request.files and field_name == \"avatar\":\n                    model_data[field_name] = request.files[\"avatar\"]\n                    files_found = True\n                    logger.debug(f\"Using avatar file for field {field_name}: {request.files['avatar'].filename}\")\n                elif len(request.files) == 1:\n                    file_key = next(iter(request.files))\n                    model_data[field_name] = request.files[file_key]\n                    files_found = True\n                    logger.debug(f\"Using single file for field {field_name}: {request.files[file_key].filename}\")\n\n            else:\n                origin = getattr(field_type, \"__origin__\", None)\n                if origin is list or origin is list:\n                    args = getattr(field_type, \"__args__\", [])\n                    if args and isinstance(args[0], type) and issubclass(args[0], FileField):\n                        if field_name in request.files:\n                            if hasattr(request.files, \"getlist\"):\n                                files_list = request.files.getlist(field_name)\n                                if files_list:\n                                    model_data[field_name] = files_list\n                                    files_found = True\n                                    logger.debug(\n                                        f\"Found multiple files for field {field_name}: {len(files_list)} files\"\n                                    )\n                        else:\n                            all_files = []\n                            for file_key in request.files:\n                                if hasattr(request.files, \"getlist\"):\n                                    all_files.extend(request.files.getlist(file_key))\n                                else:\n                                    all_files.append(request.files[file_key])\n\n                            if all_files:\n                                model_data[field_name] = all_files\n                                files_found = True\n                                logger.debug(f\"Collected all files for field {field_name}: {len(all_files)} files\")\n\n        if has_file_fields and not files_found:\n            logger.warning(f\"No files found for file fields: {file_field_names}\")\n            error_message = f\"No files found for required fields: {', '.join(file_field_names)}\"\n            return self.default_error_response(error=\"FILE_REQUIRED\", message=error_message)\n\n        processed_data = preprocess_request_data(model_data, model)\n        logger.debug(f\"Processed data: {processed_data}\")\n\n        try:\n            return ModelFactory.create_from_data(model, processed_data)\n        except Exception:\n            logger.exception(\"Error creating model instance\")\n\n            return model(**model_data)\n\n    def _get_or_create_parser(self, model: type[BaseModel], location: str = \"json\") -&gt; Any:\n        \"\"\"Create a parser for the model.\n\n        Args:\n            model: The model to create a parser for\n            location: The location to look for arguments (json, form, binary, args, etc.)\n\n        Returns:\n            A RequestParser instance for the model\n\n        \"\"\"\n        if location == \"binary\":\n            logger = get_logger(__name__)\n            logger.debug(\"Using binary parser, will handle raw data separately\")\n\n            return reqparse.RequestParser(bundle_errors=True)\n\n        return create_reqparse_from_pydantic(model=model, location=location)\n\n    def _create_model_from_args(self, model: type[BaseModel], args: dict[str, Any]) -&gt; BaseModel:\n        \"\"\"Create a model instance from parsed arguments.\n\n        Args:\n            model: The model class to instantiate\n            args: The parsed arguments\n\n        Returns:\n            An instance of the model\n\n        \"\"\"\n        logger = get_logger(__name__)\n        logger.debug(f\"Creating model instance for {model.__name__} from args\")\n\n        processed_data = preprocess_request_data(args, model)\n        logger.debug(\"Processed data\", extra={\"processed_data\": processed_data})\n\n        model_instance = safe_operation(lambda: ModelFactory.create_from_data(model, processed_data), fallback=None)\n\n        if model_instance:\n            logger.debug(\"Successfully created model instance\")\n            return model_instance\n\n        logger.warning(\"Failed to create model instance from args, creating empty instance\")\n\n        try:\n            model_instance = model()\n            logger.debug(\"Created empty model instance\")\n        except Exception as empty_err:\n            logger.exception(\"Failed to create empty model instance\")\n\n            if hasattr(model, \"model_json_schema\"):\n                schema = model.model_json_schema()\n                required_fields = schema.get(\"required\", [])\n                default_data = {}\n\n                for field in required_fields:\n                    if field in model.model_fields:\n                        field_info = model.model_fields[field]\n                        if field_info.annotation is str:\n                            default_data[field] = \"\"\n                        elif field_info.annotation is int:\n                            default_data[field] = 0\n                        elif field_info.annotation is float:\n                            default_data[field] = 0.0\n                        elif field_info.annotation is bool:\n                            default_data[field] = False\n                        else:\n                            default_data[field] = None\n\n                try:\n                    model_instance = model.model_validate(default_data)\n                    logger.debug(\"Created model instance with default values\")\n                except Exception:\n                    logger.exception(\"Failed to create model instance with default values\")\n                else:\n                    return model_instance\n\n            error_msg = f\"Failed to create instance of {model.__name__}\"\n            raise ValueError(error_msg) from empty_err\n        else:\n            return model_instance\n\n    def process_query_params(self, param_name: str, model: type[BaseModel], kwargs: dict[str, Any]) -&gt; dict[str, Any]:\n        \"\"\"Process query parameters for Flask-RESTful.\n\n        Args:\n            param_name: The parameter name to bind the model instance to.\n            model: The Pydantic model class to use for validation.\n            kwargs: The keyword arguments to update.\n\n        Returns:\n            Updated kwargs dictionary with the model instance.\n\n        \"\"\"\n        logger = get_logger(__name__)\n\n        if self.parsed_args:\n            model_instance = self._create_model_from_args(model, self.parsed_args)\n            kwargs[param_name] = model_instance\n            return kwargs\n\n        parser = self._get_or_create_query_parser(model)\n\n        self.parsed_args = parser.parse_args()\n\n        try:\n            model_instance = self._create_model_from_args(model, self.parsed_args)\n            kwargs[param_name] = model_instance\n        except Exception:\n            logger.exception(f\"Failed to create model instance for {param_name}\")\n\n            try:\n                model_instance = model()\n                logger.debug(f\"Created empty model instance for {param_name}\")\n                kwargs[param_name] = model_instance\n            except Exception:\n                logger.exception(f\"Failed to create empty model instance for {param_name}\")\n\n        return kwargs\n\n    def _get_or_create_query_parser(self, model: type[BaseModel]) -&gt; Any:\n        \"\"\"Create a query parser for the model.\n\n        Args:\n            model: The model to create a parser for\n\n        Returns:\n            A RequestParser instance for the model\n\n        \"\"\"\n        return create_reqparse_from_pydantic(model=model, location=\"args\")\n\n    def process_additional_params(self, kwargs: dict[str, Any], param_names: list[str]) -&gt; dict[str, Any]:\n        \"\"\"Process additional framework-specific parameters.\n\n        Args:\n            kwargs: The keyword arguments to update.\n            param_names: List of parameter names that have been processed.\n\n        Returns:\n            Updated kwargs dictionary.\n\n        \"\"\"\n        if self.parsed_args:\n            for arg_name, arg_value in self.parsed_args.items():\n                if arg_name not in kwargs and arg_name not in param_names:\n                    kwargs[arg_name] = arg_value\n        return kwargs\n</code></pre>"},{"location":"api/flask_restful/#flask_x_openapi_schema.x.flask_restful.decorators.FlaskRestfulOpenAPIDecorator.__call__","title":"<code>__call__(func)</code>","text":"<p>Apply the decorator to the function.</p> <p>Parameters:</p> Name Type Description Default <code>func</code> <code>Callable[..., Any]</code> <p>The function to decorate.</p> required <p>Returns:</p> Type Description <code>Callable[..., Any]</code> <p>The decorated function.</p> Source code in <code>src/flask_x_openapi_schema/x/flask_restful/decorators.py</code> <pre><code>def __call__(self, func: Callable[..., Any]) -&gt; Callable[..., Any]:\n    \"\"\"Apply the decorator to the function.\n\n    Args:\n        func: The function to decorate.\n\n    Returns:\n        The decorated function.\n\n    \"\"\"\n    if self.base_decorator is None:\n        self.base_decorator = OpenAPIDecoratorBase(\n            summary=self.summary,\n            description=self.description,\n            tags=self.tags,\n            operation_id=self.operation_id,\n            responses=self.responses,\n            deprecated=self.deprecated,\n            security=self.security,\n            external_docs=self.external_docs,\n            language=self.language,\n            prefix_config=self.prefix_config,\n            framework=self.framework,\n            content_type=self.content_type,\n            request_content_types=self.request_content_types,\n            response_content_types=self.response_content_types,\n            content_type_resolver=self.content_type_resolver,\n        )\n    return self.base_decorator(func)\n</code></pre>"},{"location":"api/flask_restful/#flask_x_openapi_schema.x.flask_restful.decorators.FlaskRestfulOpenAPIDecorator.__init__","title":"<code>__init__(summary=None, description=None, tags=None, operation_id=None, responses=None, deprecated=False, security=None, external_docs=None, language=None, prefix_config=None, content_type=None, request_content_types=None, response_content_types=None, content_type_resolver=None)</code>","text":"<p>Initialize the decorator with OpenAPI metadata parameters.</p> <p>Parameters:</p> Name Type Description Default <code>summary</code> <code>str | I18nStr | None</code> <p>A short summary of what the operation does.</p> <code>None</code> <code>description</code> <code>str | I18nStr | None</code> <p>A verbose explanation of the operation behavior.</p> <code>None</code> <code>tags</code> <code>list[str] | None</code> <p>A list of tags for API documentation control.</p> <code>None</code> <code>operation_id</code> <code>str | None</code> <p>Unique string used to identify the operation.</p> <code>None</code> <code>responses</code> <code>OpenAPIMetaResponse | None</code> <p>The responses the API can return.</p> <code>None</code> <code>deprecated</code> <code>bool</code> <p>Declares this operation to be deprecated.</p> <code>False</code> <code>security</code> <code>list[dict[str, list[str]]] | None</code> <p>A declaration of which security mechanisms can be used for this operation.</p> <code>None</code> <code>external_docs</code> <code>dict[str, str] | None</code> <p>Additional external documentation.</p> <code>None</code> <code>language</code> <code>str | None</code> <p>Language code to use for I18nString values.</p> <code>None</code> <code>prefix_config</code> <code>ConventionalPrefixConfig | None</code> <p>Configuration object for parameter prefixes.</p> <code>None</code> <code>content_type</code> <code>str | None</code> <p>Custom content type for request body. If None, will be auto-detected.</p> <code>None</code> <code>request_content_types</code> <code>RequestContentTypes | None</code> <p>Multiple content types for request body.</p> <code>None</code> <code>response_content_types</code> <code>ResponseContentTypes | None</code> <p>Multiple content types for response body.</p> <code>None</code> <code>content_type_resolver</code> <code>Callable[[Any], str] | None</code> <p>Function to determine content type based on request.</p> <code>None</code> Source code in <code>src/flask_x_openapi_schema/x/flask_restful/decorators.py</code> <pre><code>def __init__(\n    self,\n    summary: str | I18nStr | None = None,\n    description: str | I18nStr | None = None,\n    tags: list[str] | None = None,\n    operation_id: str | None = None,\n    responses: OpenAPIMetaResponse | None = None,\n    deprecated: bool = False,\n    security: list[dict[str, list[str]]] | None = None,\n    external_docs: dict[str, str] | None = None,\n    language: str | None = None,\n    prefix_config: ConventionalPrefixConfig | None = None,\n    content_type: str | None = None,\n    request_content_types: RequestContentTypes | None = None,\n    response_content_types: ResponseContentTypes | None = None,\n    content_type_resolver: Callable[[Any], str] | None = None,\n) -&gt; None:\n    \"\"\"Initialize the decorator with OpenAPI metadata parameters.\n\n    Args:\n        summary: A short summary of what the operation does.\n        description: A verbose explanation of the operation behavior.\n        tags: A list of tags for API documentation control.\n        operation_id: Unique string used to identify the operation.\n        responses: The responses the API can return.\n        deprecated: Declares this operation to be deprecated.\n        security: A declaration of which security mechanisms can be used for this operation.\n        external_docs: Additional external documentation.\n        language: Language code to use for I18nString values.\n        prefix_config: Configuration object for parameter prefixes.\n        content_type: Custom content type for request body. If None, will be auto-detected.\n        request_content_types: Multiple content types for request body.\n        response_content_types: Multiple content types for response body.\n        content_type_resolver: Function to determine content type based on request.\n\n    \"\"\"\n    super().__init__(\n        summary=summary,\n        description=description,\n        tags=tags,\n        operation_id=operation_id,\n        responses=responses,\n        deprecated=deprecated,\n        security=security,\n        external_docs=external_docs,\n        language=language,\n        prefix_config=prefix_config,\n        content_type=content_type,\n        request_content_types=request_content_types,\n        response_content_types=response_content_types,\n        content_type_resolver=content_type_resolver,\n    )\n    self.framework = \"flask_restful\"\n    self.base_decorator = None\n    self.parsed_args = None\n</code></pre>"},{"location":"api/flask_restful/#flask_x_openapi_schema.x.flask_restful.decorators.FlaskRestfulOpenAPIDecorator.extract_parameters_from_models","title":"<code>extract_parameters_from_models(query_model, path_params)</code>","text":"<p>Extract OpenAPI parameters from models.</p> <p>Converts Pydantic models and path parameters into OpenAPI parameter objects.</p> <p>Parameters:</p> Name Type Description Default <code>query_model</code> <code>type[BaseModel] | None</code> <p>Pydantic model for query parameters.</p> required <code>path_params</code> <code>list[str] | None</code> <p>List of path parameter names.</p> required <p>Returns:</p> Type Description <code>list[dict[str, Any]]</code> <p>List of OpenAPI parameter objects.</p> Source code in <code>src/flask_x_openapi_schema/x/flask_restful/decorators.py</code> <pre><code>def extract_parameters_from_models(\n    self,\n    query_model: type[BaseModel] | None,\n    path_params: list[str] | None,\n) -&gt; list[dict[str, Any]]:\n    \"\"\"Extract OpenAPI parameters from models.\n\n    Converts Pydantic models and path parameters into OpenAPI parameter objects.\n\n    Args:\n        query_model: Pydantic model for query parameters.\n        path_params: List of path parameter names.\n\n    Returns:\n        List of OpenAPI parameter objects.\n\n    \"\"\"\n    parameters = []\n\n    if path_params:\n        parameters.extend(\n            [\n                {\n                    \"name\": param,\n                    \"in\": \"path\",\n                    \"required\": True,\n                    \"schema\": {\"type\": \"string\"},\n                }\n                for param in path_params\n            ],\n        )\n\n    if query_model:\n        schema = query_model.model_json_schema()\n        properties = schema.get(\"properties\", {})\n        required = schema.get(\"required\", [])\n\n        for field_name, field_schema in properties.items():\n            param = {\n                \"name\": field_name,\n                \"in\": \"query\",\n                \"required\": field_name in required,\n                \"schema\": field_schema,\n            }\n\n            if \"description\" in field_schema:\n                param[\"description\"] = field_schema[\"description\"]\n\n            parameters.append(param)\n\n    return parameters\n</code></pre>"},{"location":"api/flask_restful/#flask_x_openapi_schema.x.flask_restful.decorators.FlaskRestfulOpenAPIDecorator.process_additional_params","title":"<code>process_additional_params(kwargs, param_names)</code>","text":"<p>Process additional framework-specific parameters.</p> <p>Parameters:</p> Name Type Description Default <code>kwargs</code> <code>dict[str, Any]</code> <p>The keyword arguments to update.</p> required <code>param_names</code> <code>list[str]</code> <p>List of parameter names that have been processed.</p> required <p>Returns:</p> Type Description <code>dict[str, Any]</code> <p>Updated kwargs dictionary.</p> Source code in <code>src/flask_x_openapi_schema/x/flask_restful/decorators.py</code> <pre><code>def process_additional_params(self, kwargs: dict[str, Any], param_names: list[str]) -&gt; dict[str, Any]:\n    \"\"\"Process additional framework-specific parameters.\n\n    Args:\n        kwargs: The keyword arguments to update.\n        param_names: List of parameter names that have been processed.\n\n    Returns:\n        Updated kwargs dictionary.\n\n    \"\"\"\n    if self.parsed_args:\n        for arg_name, arg_value in self.parsed_args.items():\n            if arg_name not in kwargs and arg_name not in param_names:\n                kwargs[arg_name] = arg_value\n    return kwargs\n</code></pre>"},{"location":"api/flask_restful/#flask_x_openapi_schema.x.flask_restful.decorators.FlaskRestfulOpenAPIDecorator.process_query_params","title":"<code>process_query_params(param_name, model, kwargs)</code>","text":"<p>Process query parameters for Flask-RESTful.</p> <p>Parameters:</p> Name Type Description Default <code>param_name</code> <code>str</code> <p>The parameter name to bind the model instance to.</p> required <code>model</code> <code>type[BaseModel]</code> <p>The Pydantic model class to use for validation.</p> required <code>kwargs</code> <code>dict[str, Any]</code> <p>The keyword arguments to update.</p> required <p>Returns:</p> Type Description <code>dict[str, Any]</code> <p>Updated kwargs dictionary with the model instance.</p> Source code in <code>src/flask_x_openapi_schema/x/flask_restful/decorators.py</code> <pre><code>def process_query_params(self, param_name: str, model: type[BaseModel], kwargs: dict[str, Any]) -&gt; dict[str, Any]:\n    \"\"\"Process query parameters for Flask-RESTful.\n\n    Args:\n        param_name: The parameter name to bind the model instance to.\n        model: The Pydantic model class to use for validation.\n        kwargs: The keyword arguments to update.\n\n    Returns:\n        Updated kwargs dictionary with the model instance.\n\n    \"\"\"\n    logger = get_logger(__name__)\n\n    if self.parsed_args:\n        model_instance = self._create_model_from_args(model, self.parsed_args)\n        kwargs[param_name] = model_instance\n        return kwargs\n\n    parser = self._get_or_create_query_parser(model)\n\n    self.parsed_args = parser.parse_args()\n\n    try:\n        model_instance = self._create_model_from_args(model, self.parsed_args)\n        kwargs[param_name] = model_instance\n    except Exception:\n        logger.exception(f\"Failed to create model instance for {param_name}\")\n\n        try:\n            model_instance = model()\n            logger.debug(f\"Created empty model instance for {param_name}\")\n            kwargs[param_name] = model_instance\n        except Exception:\n            logger.exception(f\"Failed to create empty model instance for {param_name}\")\n\n    return kwargs\n</code></pre>"},{"location":"api/flask_restful/#flask_x_openapi_schema.x.flask_restful.decorators.FlaskRestfulOpenAPIDecorator.process_request_body","title":"<code>process_request_body(param_name, model, kwargs)</code>","text":"<p>Process request body parameters for Flask-RESTful.</p> <p>Parameters:</p> Name Type Description Default <code>param_name</code> <code>str</code> <p>The parameter name to bind the model instance to</p> required <code>model</code> <code>type[BaseModel]</code> <p>The Pydantic model class to use for validation</p> required <code>kwargs</code> <code>dict[str, Any]</code> <p>The keyword arguments to update</p> required <p>Returns:</p> Type Description <code>dict[str, Any]</code> <p>Updated kwargs dictionary with the model instance</p> Source code in <code>src/flask_x_openapi_schema/x/flask_restful/decorators.py</code> <pre><code>def process_request_body(self, param_name: str, model: type[BaseModel], kwargs: dict[str, Any]) -&gt; dict[str, Any]:\n    \"\"\"Process request body parameters for Flask-RESTful.\n\n    Args:\n        param_name: The parameter name to bind the model instance to\n        model: The Pydantic model class to use for validation\n        kwargs: The keyword arguments to update\n\n    Returns:\n        Updated kwargs dictionary with the model instance\n\n    \"\"\"\n    logger = get_logger(__name__)\n    logger.debug(f\"Processing request body for {param_name} with model {model.__name__}\")\n\n    is_multipart = False\n    if hasattr(model, \"model_config\"):\n        config = getattr(model, \"model_config\", {})\n        if isinstance(config, dict) and config.get(\"json_schema_extra\", {}).get(\"multipart/form-data\", False):\n            is_multipart = True\n    elif hasattr(model, \"Config\") and hasattr(model.Config, \"json_schema_extra\"):\n        config_extra = getattr(model.Config, \"json_schema_extra\", {})\n        is_multipart = config_extra.get(\"multipart/form-data\", False)\n\n    has_file_fields = self._check_for_file_fields(model)\n\n    if (has_file_fields or is_multipart) and (request.files or request.form):\n        result = self._process_file_upload_model(model)\n\n        if isinstance(result, BaseErrorResponse):\n            response_dict, status_code = result.to_response(400)\n            return make_response(response_dict, status_code)\n\n        if result is not None:\n            kwargs[param_name] = result\n            return kwargs\n\n    processed_kwargs = super().process_request_body(param_name, model, kwargs.copy())\n    if param_name in processed_kwargs:\n        return processed_kwargs\n\n    json_model_instance = request_processor.process_request_data(request, model, param_name)\n    if json_model_instance:\n        logger.debug(f\"Successfully created model instance from request data for {param_name}\")\n        kwargs[param_name] = json_model_instance\n        return kwargs\n\n    effective_content_type = self.content_type or request.content_type or \"\"\n    if \"form\" in effective_content_type or \"multipart\" in effective_content_type:\n        parser_location = \"form\"\n    elif \"json\" in effective_content_type:\n        parser_location = \"json\"\n    elif any(\n        binary_type in effective_content_type\n        for binary_type in [\"image/\", \"audio/\", \"video/\", \"application/octet-stream\"]\n    ):\n        parser_location = \"binary\"\n    elif \"text/event-stream\" in effective_content_type:\n        parser_location = \"json\"\n    else:\n        parser_location = \"form\" if is_multipart else \"json\"\n\n    logger.debug(f\"Using parser location: {parser_location}\")\n\n    parser = self._get_or_create_parser(model, location=parser_location)\n    self.parsed_args = parser.parse_args()\n\n    if self.parsed_args:\n        try:\n            processed_data = preprocess_request_data(self.parsed_args, model)\n            model_instance = safe_operation(\n                lambda: ModelFactory.create_from_data(model, processed_data), fallback=None\n            )\n            if model_instance:\n                logger.debug(f\"Successfully created model instance from reqparse for {param_name}\")\n                kwargs[param_name] = model_instance\n                return kwargs\n        except Exception:\n            logger.exception(\"Error processing reqparse data\")\n\n    logger.warning(f\"No valid request data found for {param_name}, creating default instance\")\n    try:\n        model_instance = safe_operation(lambda: model(), fallback=None)\n        if model_instance:\n            logger.debug(f\"Created empty model instance for {param_name}\")\n            kwargs[param_name] = model_instance\n    except Exception:\n        logger.exception(\"Failed to create default model instance\")\n\n    return kwargs\n</code></pre>"},{"location":"api/flask_restful/#flask_x_openapi_schema.x.flask_restful.decorators.openapi_metadata","title":"<code>openapi_metadata(*, summary=None, description=None, tags=None, operation_id=None, deprecated=False, responses=None, security=None, external_docs=None, language=None, prefix_config=None, content_type=None, request_content_types=None, response_content_types=None, content_type_resolver=None)</code>","text":"<p>Decorator to add OpenAPI metadata to a Flask-RESTful Resource endpoint.</p> <p>This decorator adds OpenAPI metadata to a Flask-RESTful Resource endpoint and handles parameter binding for request data. It automatically binds request body, query parameters, path parameters, and file uploads to function parameters based on their type annotations and parameter name prefixes.</p> <p>Parameters:</p> Name Type Description Default <code>summary</code> <code>str | I18nStr | None</code> <p>A short summary of what the operation does.</p> <code>None</code> <code>description</code> <code>str | I18nStr | None</code> <p>A verbose explanation of the operation behavior.</p> <code>None</code> <code>tags</code> <code>list[str] | None</code> <p>A list of tags for API documentation control.</p> <code>None</code> <code>operation_id</code> <code>str | None</code> <p>Unique string used to identify the operation.</p> <code>None</code> <code>deprecated</code> <code>bool</code> <p>Declares this operation to be deprecated.</p> <code>False</code> <code>responses</code> <code>OpenAPIMetaResponse | None</code> <p>The responses the API can return.</p> <code>None</code> <code>security</code> <code>list[dict[str, list[str]]] | None</code> <p>A declaration of which security mechanisms can be used for this operation.</p> <code>None</code> <code>external_docs</code> <code>dict[str, str] | None</code> <p>Additional external documentation.</p> <code>None</code> <code>language</code> <code>str | None</code> <p>Language code to use for I18nString values (default: current language).</p> <code>None</code> <code>prefix_config</code> <code>ConventionalPrefixConfig | None</code> <p>Configuration object for parameter prefixes.</p> <code>None</code> <code>content_type</code> <code>str | None</code> <p>Custom content type for request body. If None, will be auto-detected.</p> <code>None</code> <code>request_content_types</code> <code>RequestContentTypes | None</code> <p>Multiple content types for request body.</p> <code>None</code> <code>response_content_types</code> <code>ResponseContentTypes | None</code> <p>Multiple content types for response body.</p> <code>None</code> <code>content_type_resolver</code> <code>Callable[[Any], str] | None</code> <p>Function to determine content type based on request.</p> <code>None</code> <p>Returns:</p> Type Description <code>Callable[[F], F] | F</code> <p>The decorated function with OpenAPI metadata attached.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from flask_restful import Resource\n&gt;&gt;&gt; from flask_x_openapi_schema.x.flask_restful import openapi_metadata\n&gt;&gt;&gt; from flask_x_openapi_schema import OpenAPIMetaResponse, OpenAPIMetaResponseItem\n&gt;&gt;&gt; from pydantic import BaseModel, Field\n&gt;&gt;&gt;\n&gt;&gt;&gt; class ItemRequest(BaseModel):\n...     name: str = Field(..., description=\"Item name\")\n...     price: float = Field(..., description=\"Item price\")\n&gt;&gt;&gt;\n&gt;&gt;&gt; class ItemResponse(BaseModel):\n...     id: str = Field(..., description=\"Item ID\")\n...     name: str = Field(..., description=\"Item name\")\n...     price: float = Field(..., description=\"Item price\")\n&gt;&gt;&gt;\n&gt;&gt;&gt; class ItemResource(Resource):\n...     @openapi_metadata(\n...         summary=\"Create a new item\",\n...         description=\"Create a new item with the provided information\",\n...         tags=[\"items\"],\n...         operation_id=\"createItem\",\n...         responses=OpenAPIMetaResponse(\n...             responses={\n...                 \"201\": OpenAPIMetaResponseItem(model=ItemResponse, description=\"Item created successfully\"),\n...                 \"400\": OpenAPIMetaResponseItem(description=\"Invalid request data\"),\n...             }\n...         ),\n...     )\n...     def post(self, _x_body: ItemRequest):\n...         item = {\"id\": \"123\", \"name\": _x_body.name, \"price\": _x_body.price}\n...         return item, 201\n</code></pre> Source code in <code>src/flask_x_openapi_schema/x/flask_restful/decorators.py</code> <pre><code>def openapi_metadata(\n    *,\n    summary: str | I18nStr | None = None,\n    description: str | I18nStr | None = None,\n    tags: list[str] | None = None,\n    operation_id: str | None = None,\n    deprecated: bool = False,\n    responses: OpenAPIMetaResponse | None = None,\n    security: list[dict[str, list[str]]] | None = None,\n    external_docs: dict[str, str] | None = None,\n    language: str | None = None,\n    prefix_config: ConventionalPrefixConfig | None = None,\n    content_type: str | None = None,\n    request_content_types: RequestContentTypes | None = None,\n    response_content_types: ResponseContentTypes | None = None,\n    content_type_resolver: Callable[[Any], str] | None = None,\n) -&gt; Callable[[F], F] | F:\n    \"\"\"Decorator to add OpenAPI metadata to a Flask-RESTful Resource endpoint.\n\n    This decorator adds OpenAPI metadata to a Flask-RESTful Resource endpoint and handles\n    parameter binding for request data. It automatically binds request body, query parameters,\n    path parameters, and file uploads to function parameters based on their type annotations\n    and parameter name prefixes.\n\n    Args:\n        summary: A short summary of what the operation does.\n        description: A verbose explanation of the operation behavior.\n        tags: A list of tags for API documentation control.\n        operation_id: Unique string used to identify the operation.\n        deprecated: Declares this operation to be deprecated.\n        responses: The responses the API can return.\n        security: A declaration of which security mechanisms can be used for this operation.\n        external_docs: Additional external documentation.\n        language: Language code to use for I18nString values (default: current language).\n        prefix_config: Configuration object for parameter prefixes.\n        content_type: Custom content type for request body. If None, will be auto-detected.\n        request_content_types: Multiple content types for request body.\n        response_content_types: Multiple content types for response body.\n        content_type_resolver: Function to determine content type based on request.\n\n\n    Returns:\n        The decorated function with OpenAPI metadata attached.\n\n    Examples:\n        &gt;&gt;&gt; from flask_restful import Resource\n        &gt;&gt;&gt; from flask_x_openapi_schema.x.flask_restful import openapi_metadata\n        &gt;&gt;&gt; from flask_x_openapi_schema import OpenAPIMetaResponse, OpenAPIMetaResponseItem\n        &gt;&gt;&gt; from pydantic import BaseModel, Field\n        &gt;&gt;&gt;\n        &gt;&gt;&gt; class ItemRequest(BaseModel):\n        ...     name: str = Field(..., description=\"Item name\")\n        ...     price: float = Field(..., description=\"Item price\")\n        &gt;&gt;&gt;\n        &gt;&gt;&gt; class ItemResponse(BaseModel):\n        ...     id: str = Field(..., description=\"Item ID\")\n        ...     name: str = Field(..., description=\"Item name\")\n        ...     price: float = Field(..., description=\"Item price\")\n        &gt;&gt;&gt;\n        &gt;&gt;&gt; class ItemResource(Resource):\n        ...     @openapi_metadata(\n        ...         summary=\"Create a new item\",\n        ...         description=\"Create a new item with the provided information\",\n        ...         tags=[\"items\"],\n        ...         operation_id=\"createItem\",\n        ...         responses=OpenAPIMetaResponse(\n        ...             responses={\n        ...                 \"201\": OpenAPIMetaResponseItem(model=ItemResponse, description=\"Item created successfully\"),\n        ...                 \"400\": OpenAPIMetaResponseItem(description=\"Invalid request data\"),\n        ...             }\n        ...         ),\n        ...     )\n        ...     def post(self, _x_body: ItemRequest):\n        ...         item = {\"id\": \"123\", \"name\": _x_body.name, \"price\": _x_body.price}\n        ...         return item, 201\n\n    \"\"\"\n    return FlaskRestfulOpenAPIDecorator(\n        summary=summary,\n        description=description,\n        tags=tags,\n        operation_id=operation_id,\n        responses=responses,\n        deprecated=deprecated,\n        security=security,\n        external_docs=external_docs,\n        language=language,\n        prefix_config=prefix_config,\n        content_type=content_type,\n        request_content_types=request_content_types,\n        response_content_types=response_content_types,\n        content_type_resolver=content_type_resolver,\n    )\n</code></pre>"},{"location":"api/flask_restful/#resources","title":"Resources","text":"<p>Extension for the Flask-RESTful Api class to collect OpenAPI metadata.</p> <p>This module provides mixins and utilities to integrate Flask-RESTful with OpenAPI schema generation. It extends Flask-RESTful's Api class to add OpenAPI schema generation capabilities, tracking resources added to the API and providing methods to generate OpenAPI schemas.</p> <p>Examples:</p> <p>Basic usage with Flask-RESTful:</p> <pre><code>&gt;&gt;&gt; from flask import Flask\n&gt;&gt;&gt; from flask_restful import Resource\n&gt;&gt;&gt; from flask_x_openapi_schema.x.flask_restful import OpenAPIIntegrationMixin, openapi_metadata\n&gt;&gt;&gt; from pydantic import BaseModel, Field\n&gt;&gt;&gt;\n&gt;&gt;&gt; app = Flask(__name__)\n&gt;&gt;&gt;\n&gt;&gt;&gt; class OpenAPIApi(OpenAPIIntegrationMixin):\n...     pass\n&gt;&gt;&gt;\n&gt;&gt;&gt; api = OpenAPIApi(app)\n&gt;&gt;&gt;\n&gt;&gt;&gt; class ItemResource(Resource):\n...     @openapi_metadata(summary=\"Get an item\")\n...     def get(self, item_id):\n...         return {\"id\": item_id, \"name\": \"Example Item\"}\n&gt;&gt;&gt;\n&gt;&gt;&gt; api.add_resource(ItemResource, \"/items/&lt;item_id&gt;\")\n&gt;&gt;&gt;\n&gt;&gt;&gt; # Route to serve the OpenAPI schema\n&gt;&gt;&gt; schema = api.generate_openapi_schema(title=\"My API\", version=\"1.0.0\", description=\"API for managing items\")\n</code></pre>"},{"location":"api/flask_restful/#flask_x_openapi_schema.x.flask_restful.resources.OpenAPIBlueprintMixin","title":"<code>OpenAPIBlueprintMixin</code>","text":"<p>A mixin class for Flask Blueprint to collect OpenAPI metadata from MethodView classes.</p> <p>This mixin extends Flask's Blueprint class to add OpenAPI schema generation capabilities for MethodView classes. It tracks MethodView classes registered to the blueprint and provides methods to generate OpenAPI schemas.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from flask import Blueprint, Flask\n&gt;&gt;&gt; from flask.views import MethodView\n&gt;&gt;&gt; from flask_x_openapi_schema.x.flask_restful import OpenAPIBlueprintMixin\n&gt;&gt;&gt; from flask_x_openapi_schema.x.flask import openapi_metadata, OpenAPIMethodViewMixin\n&gt;&gt;&gt;\n&gt;&gt;&gt; app = Flask(__name__)\n&gt;&gt;&gt;\n&gt;&gt;&gt; class OpenAPIBlueprint(OpenAPIBlueprintMixin, Blueprint):\n...     pass\n&gt;&gt;&gt;\n&gt;&gt;&gt; bp = OpenAPIBlueprint(\"api\", __name__, url_prefix=\"/api\")\n&gt;&gt;&gt;\n&gt;&gt;&gt; class ItemView(OpenAPIMethodViewMixin, MethodView):\n...     @openapi_metadata(summary=\"Get an item\")\n...     def get(self, item_id):\n...         return {\"id\": item_id, \"name\": \"Example Item\"}\n&gt;&gt;&gt;\n&gt;&gt;&gt; # Register the view to the blueprint (returns a view function)\n&gt;&gt;&gt; view_func = ItemView.register_to_blueprint(bp, \"/items/&lt;item_id&gt;\")\n&gt;&gt;&gt;\n&gt;&gt;&gt; app.register_blueprint(bp)\n&gt;&gt;&gt;\n&gt;&gt;&gt; # Generate OpenAPI schema\n&gt;&gt;&gt; schema = bp.generate_openapi_schema(title=\"My API\", version=\"1.0.0\", description=\"API for managing items\")\n</code></pre> Source code in <code>src/flask_x_openapi_schema/x/flask_restful/resources.py</code> <pre><code>class OpenAPIBlueprintMixin:\n    \"\"\"A mixin class for Flask Blueprint to collect OpenAPI metadata from MethodView classes.\n\n    This mixin extends Flask's Blueprint class to add OpenAPI schema generation capabilities\n    for MethodView classes. It tracks MethodView classes registered to the blueprint and\n    provides methods to generate OpenAPI schemas.\n\n    Examples:\n        &gt;&gt;&gt; from flask import Blueprint, Flask\n        &gt;&gt;&gt; from flask.views import MethodView\n        &gt;&gt;&gt; from flask_x_openapi_schema.x.flask_restful import OpenAPIBlueprintMixin\n        &gt;&gt;&gt; from flask_x_openapi_schema.x.flask import openapi_metadata, OpenAPIMethodViewMixin\n        &gt;&gt;&gt;\n        &gt;&gt;&gt; app = Flask(__name__)\n        &gt;&gt;&gt;\n        &gt;&gt;&gt; class OpenAPIBlueprint(OpenAPIBlueprintMixin, Blueprint):\n        ...     pass\n        &gt;&gt;&gt;\n        &gt;&gt;&gt; bp = OpenAPIBlueprint(\"api\", __name__, url_prefix=\"/api\")\n        &gt;&gt;&gt;\n        &gt;&gt;&gt; class ItemView(OpenAPIMethodViewMixin, MethodView):\n        ...     @openapi_metadata(summary=\"Get an item\")\n        ...     def get(self, item_id):\n        ...         return {\"id\": item_id, \"name\": \"Example Item\"}\n        &gt;&gt;&gt;\n        &gt;&gt;&gt; # Register the view to the blueprint (returns a view function)\n        &gt;&gt;&gt; view_func = ItemView.register_to_blueprint(bp, \"/items/&lt;item_id&gt;\")\n        &gt;&gt;&gt;\n        &gt;&gt;&gt; app.register_blueprint(bp)\n        &gt;&gt;&gt;\n        &gt;&gt;&gt; # Generate OpenAPI schema\n        &gt;&gt;&gt; schema = bp.generate_openapi_schema(title=\"My API\", version=\"1.0.0\", description=\"API for managing items\")\n\n    \"\"\"\n\n    def configure_openapi(self, *, prefix_config: ConventionalPrefixConfig = None, **kwargs: Any) -&gt; None:\n        \"\"\"Configure OpenAPI settings for this Blueprint instance.\n\n        Args:\n            prefix_config: Configuration object with parameter prefixes\n            **kwargs: For backward compatibility - will be used to create a config object if prefix_config is None\n\n        \"\"\"\n        if prefix_config is not None:\n            configure_prefixes(prefix_config)\n        elif kwargs:\n            new_config = ConventionalPrefixConfig(\n                request_body_prefix=kwargs.get(\n                    \"request_body_prefix\",\n                    GLOBAL_CONFIG_HOLDER.get().request_body_prefix,\n                ),\n                request_query_prefix=kwargs.get(\n                    \"request_query_prefix\",\n                    GLOBAL_CONFIG_HOLDER.get().request_query_prefix,\n                ),\n                request_path_prefix=kwargs.get(\n                    \"request_path_prefix\",\n                    GLOBAL_CONFIG_HOLDER.get().request_path_prefix,\n                ),\n                request_file_prefix=kwargs.get(\n                    \"request_file_prefix\",\n                    GLOBAL_CONFIG_HOLDER.get().request_file_prefix,\n                ),\n            )\n            configure_prefixes(new_config)\n\n    def __init__(self, *args: Any, **kwargs: Any) -&gt; None:\n        \"\"\"Initialize the mixin.\n\n        Args:\n            *args: Arguments to pass to the parent class.\n            **kwargs: Keyword arguments to pass to the parent class.\n\n        \"\"\"\n        super().__init__(*args, **kwargs)\n\n        self._methodview_openapi_resources = []\n\n    def generate_openapi_schema(\n        self,\n        title: str | I18nStr,\n        version: str,\n        description: str | I18nStr = \"\",\n        output_format: Literal[\"json\", \"yaml\"] = \"yaml\",\n        language: str | None = None,\n    ) -&gt; Any:\n        \"\"\"Generate an OpenAPI schema for the API.\n\n        Args:\n            title: The title of the API (can be an I18nString).\n            version: The version of the API.\n            description: The description of the API (can be an I18nString).\n            output_format: The output format (json or yaml).\n            language: The language to use for internationalized strings (default: current language).\n\n        Returns:\n            The OpenAPI schema as a dictionary (if json) or string (if yaml).\n\n        \"\"\"\n        current_lang = language or get_current_language()\n\n        generator = MethodViewOpenAPISchemaGenerator(title, version, description, language=current_lang)\n\n        generator.process_methodview_resources(self)\n\n        schema = generator.generate_schema()\n\n        if output_format == \"yaml\":\n            return yaml.dump(schema, sort_keys=False, default_flow_style=False, allow_unicode=True)\n        return schema\n</code></pre>"},{"location":"api/flask_restful/#flask_x_openapi_schema.x.flask_restful.resources.OpenAPIBlueprintMixin.__init__","title":"<code>__init__(*args, **kwargs)</code>","text":"<p>Initialize the mixin.</p> <p>Parameters:</p> Name Type Description Default <code>*args</code> <code>Any</code> <p>Arguments to pass to the parent class.</p> <code>()</code> <code>**kwargs</code> <code>Any</code> <p>Keyword arguments to pass to the parent class.</p> <code>{}</code> Source code in <code>src/flask_x_openapi_schema/x/flask_restful/resources.py</code> <pre><code>def __init__(self, *args: Any, **kwargs: Any) -&gt; None:\n    \"\"\"Initialize the mixin.\n\n    Args:\n        *args: Arguments to pass to the parent class.\n        **kwargs: Keyword arguments to pass to the parent class.\n\n    \"\"\"\n    super().__init__(*args, **kwargs)\n\n    self._methodview_openapi_resources = []\n</code></pre>"},{"location":"api/flask_restful/#flask_x_openapi_schema.x.flask_restful.resources.OpenAPIBlueprintMixin.configure_openapi","title":"<code>configure_openapi(*, prefix_config=None, **kwargs)</code>","text":"<p>Configure OpenAPI settings for this Blueprint instance.</p> <p>Parameters:</p> Name Type Description Default <code>prefix_config</code> <code>ConventionalPrefixConfig</code> <p>Configuration object with parameter prefixes</p> <code>None</code> <code>**kwargs</code> <code>Any</code> <p>For backward compatibility - will be used to create a config object if prefix_config is None</p> <code>{}</code> Source code in <code>src/flask_x_openapi_schema/x/flask_restful/resources.py</code> <pre><code>def configure_openapi(self, *, prefix_config: ConventionalPrefixConfig = None, **kwargs: Any) -&gt; None:\n    \"\"\"Configure OpenAPI settings for this Blueprint instance.\n\n    Args:\n        prefix_config: Configuration object with parameter prefixes\n        **kwargs: For backward compatibility - will be used to create a config object if prefix_config is None\n\n    \"\"\"\n    if prefix_config is not None:\n        configure_prefixes(prefix_config)\n    elif kwargs:\n        new_config = ConventionalPrefixConfig(\n            request_body_prefix=kwargs.get(\n                \"request_body_prefix\",\n                GLOBAL_CONFIG_HOLDER.get().request_body_prefix,\n            ),\n            request_query_prefix=kwargs.get(\n                \"request_query_prefix\",\n                GLOBAL_CONFIG_HOLDER.get().request_query_prefix,\n            ),\n            request_path_prefix=kwargs.get(\n                \"request_path_prefix\",\n                GLOBAL_CONFIG_HOLDER.get().request_path_prefix,\n            ),\n            request_file_prefix=kwargs.get(\n                \"request_file_prefix\",\n                GLOBAL_CONFIG_HOLDER.get().request_file_prefix,\n            ),\n        )\n        configure_prefixes(new_config)\n</code></pre>"},{"location":"api/flask_restful/#flask_x_openapi_schema.x.flask_restful.resources.OpenAPIBlueprintMixin.generate_openapi_schema","title":"<code>generate_openapi_schema(title, version, description='', output_format='yaml', language=None)</code>","text":"<p>Generate an OpenAPI schema for the API.</p> <p>Parameters:</p> Name Type Description Default <code>title</code> <code>str | I18nStr</code> <p>The title of the API (can be an I18nString).</p> required <code>version</code> <code>str</code> <p>The version of the API.</p> required <code>description</code> <code>str | I18nStr</code> <p>The description of the API (can be an I18nString).</p> <code>''</code> <code>output_format</code> <code>Literal['json', 'yaml']</code> <p>The output format (json or yaml).</p> <code>'yaml'</code> <code>language</code> <code>str | None</code> <p>The language to use for internationalized strings (default: current language).</p> <code>None</code> <p>Returns:</p> Type Description <code>Any</code> <p>The OpenAPI schema as a dictionary (if json) or string (if yaml).</p> Source code in <code>src/flask_x_openapi_schema/x/flask_restful/resources.py</code> <pre><code>def generate_openapi_schema(\n    self,\n    title: str | I18nStr,\n    version: str,\n    description: str | I18nStr = \"\",\n    output_format: Literal[\"json\", \"yaml\"] = \"yaml\",\n    language: str | None = None,\n) -&gt; Any:\n    \"\"\"Generate an OpenAPI schema for the API.\n\n    Args:\n        title: The title of the API (can be an I18nString).\n        version: The version of the API.\n        description: The description of the API (can be an I18nString).\n        output_format: The output format (json or yaml).\n        language: The language to use for internationalized strings (default: current language).\n\n    Returns:\n        The OpenAPI schema as a dictionary (if json) or string (if yaml).\n\n    \"\"\"\n    current_lang = language or get_current_language()\n\n    generator = MethodViewOpenAPISchemaGenerator(title, version, description, language=current_lang)\n\n    generator.process_methodview_resources(self)\n\n    schema = generator.generate_schema()\n\n    if output_format == \"yaml\":\n        return yaml.dump(schema, sort_keys=False, default_flow_style=False, allow_unicode=True)\n    return schema\n</code></pre>"},{"location":"api/flask_restful/#flask_x_openapi_schema.x.flask_restful.resources.OpenAPIIntegrationMixin","title":"<code>OpenAPIIntegrationMixin</code>","text":"<p>               Bases: <code>Api</code></p> <p>A mixin class for the flask-restful Api to collect OpenAPI metadata.</p> <p>This mixin extends Flask-RESTful's Api class to add OpenAPI schema generation capabilities. It tracks resources added to the API and provides methods to generate OpenAPI schemas.</p> <p>Parameters:</p> Name Type Description Default <code>*args</code> <code>Any</code> <p>Arguments to pass to the parent class.</p> <code>()</code> <code>**kwargs</code> <code>Any</code> <p>Keyword arguments to pass to the parent class.</p> <code>{}</code> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from flask import Flask\n&gt;&gt;&gt; from flask_restful import Resource\n&gt;&gt;&gt; from flask_x_openapi_schema.x.flask_restful import OpenAPIIntegrationMixin, openapi_metadata\n&gt;&gt;&gt; from pydantic import BaseModel, Field\n&gt;&gt;&gt;\n&gt;&gt;&gt; app = Flask(__name__)\n&gt;&gt;&gt;\n&gt;&gt;&gt; class OpenAPIApi(OpenAPIIntegrationMixin):\n...     pass\n&gt;&gt;&gt;\n&gt;&gt;&gt; api = OpenAPIApi(app)\n&gt;&gt;&gt;\n&gt;&gt;&gt; class ItemResource(Resource):\n...     @openapi_metadata(summary=\"Get an item\")\n...     def get(self, item_id):\n...         return {\"id\": item_id, \"name\": \"Example Item\"}\n&gt;&gt;&gt;\n&gt;&gt;&gt; api.add_resource(ItemResource, \"/items/&lt;item_id&gt;\")\n&gt;&gt;&gt;\n&gt;&gt;&gt; # Generate OpenAPI schema\n&gt;&gt;&gt; schema = api.generate_openapi_schema(title=\"My API\", version=\"1.0.0\", description=\"API for managing items\")\n</code></pre> Source code in <code>src/flask_x_openapi_schema/x/flask_restful/resources.py</code> <pre><code>class OpenAPIIntegrationMixin(Api):\n    \"\"\"A mixin class for the flask-restful Api to collect OpenAPI metadata.\n\n    This mixin extends Flask-RESTful's Api class to add OpenAPI schema generation capabilities.\n    It tracks resources added to the API and provides methods to generate OpenAPI schemas.\n\n    Args:\n        *args: Arguments to pass to the parent class.\n        **kwargs: Keyword arguments to pass to the parent class.\n\n    Examples:\n        &gt;&gt;&gt; from flask import Flask\n        &gt;&gt;&gt; from flask_restful import Resource\n        &gt;&gt;&gt; from flask_x_openapi_schema.x.flask_restful import OpenAPIIntegrationMixin, openapi_metadata\n        &gt;&gt;&gt; from pydantic import BaseModel, Field\n        &gt;&gt;&gt;\n        &gt;&gt;&gt; app = Flask(__name__)\n        &gt;&gt;&gt;\n        &gt;&gt;&gt; class OpenAPIApi(OpenAPIIntegrationMixin):\n        ...     pass\n        &gt;&gt;&gt;\n        &gt;&gt;&gt; api = OpenAPIApi(app)\n        &gt;&gt;&gt;\n        &gt;&gt;&gt; class ItemResource(Resource):\n        ...     @openapi_metadata(summary=\"Get an item\")\n        ...     def get(self, item_id):\n        ...         return {\"id\": item_id, \"name\": \"Example Item\"}\n        &gt;&gt;&gt;\n        &gt;&gt;&gt; api.add_resource(ItemResource, \"/items/&lt;item_id&gt;\")\n        &gt;&gt;&gt;\n        &gt;&gt;&gt; # Generate OpenAPI schema\n        &gt;&gt;&gt; schema = api.generate_openapi_schema(title=\"My API\", version=\"1.0.0\", description=\"API for managing items\")\n\n    \"\"\"\n\n    def __init__(self, *args: Any, **kwargs: Any) -&gt; None:\n        \"\"\"Initialize the mixin.\n\n        Args:\n            *args: Arguments to pass to the parent class.\n            **kwargs: Keyword arguments to pass to the parent class.\n\n        \"\"\"\n        super().__init__(*args, **kwargs)\n\n        if not hasattr(self, \"resources\"):\n            self.resources = []\n\n    def add_resource(self, resource: Any, *urls: str, **kwargs: Any) -&gt; Any:\n        \"\"\"Add a resource to the API and register it for OpenAPI schema generation.\n\n        Args:\n            resource: The resource class.\n            *urls: The URLs to register the resource with.\n            **kwargs: Additional arguments to pass to the parent method.\n\n        Returns:\n            The result of the parent method.\n\n        \"\"\"\n        result = super().add_resource(resource, *urls, **kwargs)\n\n        if not hasattr(self, \"resources\"):\n            self.resources = []\n\n        for existing_resource, existing_urls, _ in self.resources:\n            if existing_resource == resource and set(existing_urls) == set(urls):\n                return result\n\n        if \"endpoint\" not in kwargs and kwargs is not None:\n            kwargs[\"endpoint\"] = resource.__name__.lower()\n        elif kwargs is None:\n            kwargs = {\"endpoint\": resource.__name__.lower()}\n\n        self.resources.append((resource, urls, kwargs))\n\n        return result\n\n    def configure_openapi(self, *, prefix_config: ConventionalPrefixConfig = None, **kwargs: Any) -&gt; None:\n        \"\"\"Configure OpenAPI settings for this API instance.\n\n        Args:\n            prefix_config: Configuration object with parameter prefixes\n            **kwargs: For backward compatibility - will be used to create a config object if prefix_config is None\n\n        \"\"\"\n        if prefix_config is not None:\n            configure_prefixes(prefix_config)\n        elif kwargs:\n            new_config = ConventionalPrefixConfig(\n                request_body_prefix=kwargs.get(\n                    \"request_body_prefix\",\n                    GLOBAL_CONFIG_HOLDER.get().request_body_prefix,\n                ),\n                request_query_prefix=kwargs.get(\n                    \"request_query_prefix\",\n                    GLOBAL_CONFIG_HOLDER.get().request_query_prefix,\n                ),\n                request_path_prefix=kwargs.get(\n                    \"request_path_prefix\",\n                    GLOBAL_CONFIG_HOLDER.get().request_path_prefix,\n                ),\n                request_file_prefix=kwargs.get(\n                    \"request_file_prefix\",\n                    GLOBAL_CONFIG_HOLDER.get().request_file_prefix,\n                ),\n            )\n            configure_prefixes(new_config)\n\n    def generate_openapi_schema(\n        self,\n        title: str | I18nStr,\n        version: str,\n        description: str | I18nStr = \"\",\n        output_format: Literal[\"json\", \"yaml\"] = \"yaml\",\n        language: str | None = None,\n    ) -&gt; Any:\n        \"\"\"Generate an OpenAPI schema for the API.\n\n        This method generates an OpenAPI schema for all resources registered with the API.\n        It supports internationalization through I18nStr objects and can output the schema\n        in either JSON or YAML format.\n\n        Args:\n            title: The title of the API (can be an I18nString).\n            version: The version of the API.\n            description: The description of the API (can be an I18nString).\n            output_format: The output format (json or yaml).\n            language: The language to use for internationalized strings (default: current language).\n\n        Returns:\n            The OpenAPI schema as a dictionary (if json) or string (if yaml).\n\n        Examples:\n            &gt;&gt;&gt; from flask import Flask\n            &gt;&gt;&gt; from flask_restful import Resource\n            &gt;&gt;&gt; from flask_x_openapi_schema.x.flask_restful import OpenAPIIntegrationMixin, openapi_metadata\n            &gt;&gt;&gt; app = Flask(__name__)\n            &gt;&gt;&gt; class OpenAPIApi(OpenAPIIntegrationMixin):\n            ...     pass\n            &gt;&gt;&gt; api = OpenAPIApi(app)\n            &gt;&gt;&gt; yaml_schema = api.generate_openapi_schema(\n            ...     title=\"My API\", version=\"1.0.0\", description=\"API for managing items\"\n            ... )\n            &gt;&gt;&gt;\n            &gt;&gt;&gt; json_schema = api.generate_openapi_schema(\n            ...     title=\"My API\", version=\"1.0.0\", description=\"API for managing items\", output_format=\"json\"\n            ... )\n            &gt;&gt;&gt;\n            &gt;&gt;&gt; from flask_x_openapi_schema import I18nStr\n            &gt;&gt;&gt; i18n_schema = api.generate_openapi_schema(\n            ...     title=I18nStr({\"en-US\": \"My API\", \"zh-Hans\": \"\u6211\u7684API\"}),\n            ...     version=\"1.0.0\",\n            ...     description=I18nStr({\"en-US\": \"API for managing items\", \"zh-Hans\": \"\u7528\u4e8e\u7ba1\u7406\u9879\u76ee\u7684API\"}),\n            ...     language=\"zh-Hans\",\n            ... )\n\n        \"\"\"\n        current_lang = language or get_current_language()\n\n        generator = OpenAPISchemaGenerator(title, version, description, language=current_lang)\n\n        url_prefix = None\n        if hasattr(self, \"blueprint\") and hasattr(self.blueprint, \"url_prefix\"):\n            url_prefix = self.blueprint.url_prefix\n\n        for resource, urls, _ in self.resources:\n            generator._process_resource(resource, urls, url_prefix)\n\n        schema = generator.generate_schema()\n\n        if output_format == \"yaml\":\n            return yaml.dump(schema, sort_keys=False, default_flow_style=False, allow_unicode=True)\n        return schema\n</code></pre>"},{"location":"api/flask_restful/#flask_x_openapi_schema.x.flask_restful.resources.OpenAPIIntegrationMixin.__init__","title":"<code>__init__(*args, **kwargs)</code>","text":"<p>Initialize the mixin.</p> <p>Parameters:</p> Name Type Description Default <code>*args</code> <code>Any</code> <p>Arguments to pass to the parent class.</p> <code>()</code> <code>**kwargs</code> <code>Any</code> <p>Keyword arguments to pass to the parent class.</p> <code>{}</code> Source code in <code>src/flask_x_openapi_schema/x/flask_restful/resources.py</code> <pre><code>def __init__(self, *args: Any, **kwargs: Any) -&gt; None:\n    \"\"\"Initialize the mixin.\n\n    Args:\n        *args: Arguments to pass to the parent class.\n        **kwargs: Keyword arguments to pass to the parent class.\n\n    \"\"\"\n    super().__init__(*args, **kwargs)\n\n    if not hasattr(self, \"resources\"):\n        self.resources = []\n</code></pre>"},{"location":"api/flask_restful/#flask_x_openapi_schema.x.flask_restful.resources.OpenAPIIntegrationMixin.add_resource","title":"<code>add_resource(resource, *urls, **kwargs)</code>","text":"<p>Add a resource to the API and register it for OpenAPI schema generation.</p> <p>Parameters:</p> Name Type Description Default <code>resource</code> <code>Any</code> <p>The resource class.</p> required <code>*urls</code> <code>str</code> <p>The URLs to register the resource with.</p> <code>()</code> <code>**kwargs</code> <code>Any</code> <p>Additional arguments to pass to the parent method.</p> <code>{}</code> <p>Returns:</p> Type Description <code>Any</code> <p>The result of the parent method.</p> Source code in <code>src/flask_x_openapi_schema/x/flask_restful/resources.py</code> <pre><code>def add_resource(self, resource: Any, *urls: str, **kwargs: Any) -&gt; Any:\n    \"\"\"Add a resource to the API and register it for OpenAPI schema generation.\n\n    Args:\n        resource: The resource class.\n        *urls: The URLs to register the resource with.\n        **kwargs: Additional arguments to pass to the parent method.\n\n    Returns:\n        The result of the parent method.\n\n    \"\"\"\n    result = super().add_resource(resource, *urls, **kwargs)\n\n    if not hasattr(self, \"resources\"):\n        self.resources = []\n\n    for existing_resource, existing_urls, _ in self.resources:\n        if existing_resource == resource and set(existing_urls) == set(urls):\n            return result\n\n    if \"endpoint\" not in kwargs and kwargs is not None:\n        kwargs[\"endpoint\"] = resource.__name__.lower()\n    elif kwargs is None:\n        kwargs = {\"endpoint\": resource.__name__.lower()}\n\n    self.resources.append((resource, urls, kwargs))\n\n    return result\n</code></pre>"},{"location":"api/flask_restful/#flask_x_openapi_schema.x.flask_restful.resources.OpenAPIIntegrationMixin.configure_openapi","title":"<code>configure_openapi(*, prefix_config=None, **kwargs)</code>","text":"<p>Configure OpenAPI settings for this API instance.</p> <p>Parameters:</p> Name Type Description Default <code>prefix_config</code> <code>ConventionalPrefixConfig</code> <p>Configuration object with parameter prefixes</p> <code>None</code> <code>**kwargs</code> <code>Any</code> <p>For backward compatibility - will be used to create a config object if prefix_config is None</p> <code>{}</code> Source code in <code>src/flask_x_openapi_schema/x/flask_restful/resources.py</code> <pre><code>def configure_openapi(self, *, prefix_config: ConventionalPrefixConfig = None, **kwargs: Any) -&gt; None:\n    \"\"\"Configure OpenAPI settings for this API instance.\n\n    Args:\n        prefix_config: Configuration object with parameter prefixes\n        **kwargs: For backward compatibility - will be used to create a config object if prefix_config is None\n\n    \"\"\"\n    if prefix_config is not None:\n        configure_prefixes(prefix_config)\n    elif kwargs:\n        new_config = ConventionalPrefixConfig(\n            request_body_prefix=kwargs.get(\n                \"request_body_prefix\",\n                GLOBAL_CONFIG_HOLDER.get().request_body_prefix,\n            ),\n            request_query_prefix=kwargs.get(\n                \"request_query_prefix\",\n                GLOBAL_CONFIG_HOLDER.get().request_query_prefix,\n            ),\n            request_path_prefix=kwargs.get(\n                \"request_path_prefix\",\n                GLOBAL_CONFIG_HOLDER.get().request_path_prefix,\n            ),\n            request_file_prefix=kwargs.get(\n                \"request_file_prefix\",\n                GLOBAL_CONFIG_HOLDER.get().request_file_prefix,\n            ),\n        )\n        configure_prefixes(new_config)\n</code></pre>"},{"location":"api/flask_restful/#flask_x_openapi_schema.x.flask_restful.resources.OpenAPIIntegrationMixin.generate_openapi_schema","title":"<code>generate_openapi_schema(title, version, description='', output_format='yaml', language=None)</code>","text":"<p>Generate an OpenAPI schema for the API.</p> <p>This method generates an OpenAPI schema for all resources registered with the API. It supports internationalization through I18nStr objects and can output the schema in either JSON or YAML format.</p> <p>Parameters:</p> Name Type Description Default <code>title</code> <code>str | I18nStr</code> <p>The title of the API (can be an I18nString).</p> required <code>version</code> <code>str</code> <p>The version of the API.</p> required <code>description</code> <code>str | I18nStr</code> <p>The description of the API (can be an I18nString).</p> <code>''</code> <code>output_format</code> <code>Literal['json', 'yaml']</code> <p>The output format (json or yaml).</p> <code>'yaml'</code> <code>language</code> <code>str | None</code> <p>The language to use for internationalized strings (default: current language).</p> <code>None</code> <p>Returns:</p> Type Description <code>Any</code> <p>The OpenAPI schema as a dictionary (if json) or string (if yaml).</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from flask import Flask\n&gt;&gt;&gt; from flask_restful import Resource\n&gt;&gt;&gt; from flask_x_openapi_schema.x.flask_restful import OpenAPIIntegrationMixin, openapi_metadata\n&gt;&gt;&gt; app = Flask(__name__)\n&gt;&gt;&gt; class OpenAPIApi(OpenAPIIntegrationMixin):\n...     pass\n&gt;&gt;&gt; api = OpenAPIApi(app)\n&gt;&gt;&gt; yaml_schema = api.generate_openapi_schema(\n...     title=\"My API\", version=\"1.0.0\", description=\"API for managing items\"\n... )\n&gt;&gt;&gt;\n&gt;&gt;&gt; json_schema = api.generate_openapi_schema(\n...     title=\"My API\", version=\"1.0.0\", description=\"API for managing items\", output_format=\"json\"\n... )\n&gt;&gt;&gt;\n&gt;&gt;&gt; from flask_x_openapi_schema import I18nStr\n&gt;&gt;&gt; i18n_schema = api.generate_openapi_schema(\n...     title=I18nStr({\"en-US\": \"My API\", \"zh-Hans\": \"\u6211\u7684API\"}),\n...     version=\"1.0.0\",\n...     description=I18nStr({\"en-US\": \"API for managing items\", \"zh-Hans\": \"\u7528\u4e8e\u7ba1\u7406\u9879\u76ee\u7684API\"}),\n...     language=\"zh-Hans\",\n... )\n</code></pre> Source code in <code>src/flask_x_openapi_schema/x/flask_restful/resources.py</code> <pre><code>def generate_openapi_schema(\n    self,\n    title: str | I18nStr,\n    version: str,\n    description: str | I18nStr = \"\",\n    output_format: Literal[\"json\", \"yaml\"] = \"yaml\",\n    language: str | None = None,\n) -&gt; Any:\n    \"\"\"Generate an OpenAPI schema for the API.\n\n    This method generates an OpenAPI schema for all resources registered with the API.\n    It supports internationalization through I18nStr objects and can output the schema\n    in either JSON or YAML format.\n\n    Args:\n        title: The title of the API (can be an I18nString).\n        version: The version of the API.\n        description: The description of the API (can be an I18nString).\n        output_format: The output format (json or yaml).\n        language: The language to use for internationalized strings (default: current language).\n\n    Returns:\n        The OpenAPI schema as a dictionary (if json) or string (if yaml).\n\n    Examples:\n        &gt;&gt;&gt; from flask import Flask\n        &gt;&gt;&gt; from flask_restful import Resource\n        &gt;&gt;&gt; from flask_x_openapi_schema.x.flask_restful import OpenAPIIntegrationMixin, openapi_metadata\n        &gt;&gt;&gt; app = Flask(__name__)\n        &gt;&gt;&gt; class OpenAPIApi(OpenAPIIntegrationMixin):\n        ...     pass\n        &gt;&gt;&gt; api = OpenAPIApi(app)\n        &gt;&gt;&gt; yaml_schema = api.generate_openapi_schema(\n        ...     title=\"My API\", version=\"1.0.0\", description=\"API for managing items\"\n        ... )\n        &gt;&gt;&gt;\n        &gt;&gt;&gt; json_schema = api.generate_openapi_schema(\n        ...     title=\"My API\", version=\"1.0.0\", description=\"API for managing items\", output_format=\"json\"\n        ... )\n        &gt;&gt;&gt;\n        &gt;&gt;&gt; from flask_x_openapi_schema import I18nStr\n        &gt;&gt;&gt; i18n_schema = api.generate_openapi_schema(\n        ...     title=I18nStr({\"en-US\": \"My API\", \"zh-Hans\": \"\u6211\u7684API\"}),\n        ...     version=\"1.0.0\",\n        ...     description=I18nStr({\"en-US\": \"API for managing items\", \"zh-Hans\": \"\u7528\u4e8e\u7ba1\u7406\u9879\u76ee\u7684API\"}),\n        ...     language=\"zh-Hans\",\n        ... )\n\n    \"\"\"\n    current_lang = language or get_current_language()\n\n    generator = OpenAPISchemaGenerator(title, version, description, language=current_lang)\n\n    url_prefix = None\n    if hasattr(self, \"blueprint\") and hasattr(self.blueprint, \"url_prefix\"):\n        url_prefix = self.blueprint.url_prefix\n\n    for resource, urls, _ in self.resources:\n        generator._process_resource(resource, urls, url_prefix)\n\n    schema = generator.generate_schema()\n\n    if output_format == \"yaml\":\n        return yaml.dump(schema, sort_keys=False, default_flow_style=False, allow_unicode=True)\n    return schema\n</code></pre>"},{"location":"api/flask_restful/#utilities","title":"Utilities","text":"<p>Utilities for Flask-RESTful integration.</p> <p>This module provides utilities for integrating Pydantic models with Flask-RESTful, enabling automatic conversion of Pydantic models to Flask-RESTful RequestParser objects.</p> <p>The main functionality allows for seamless integration between Pydantic's validation capabilities and Flask-RESTful's request parsing system.</p>"},{"location":"api/flask_restful/#flask_x_openapi_schema.x.flask_restful.utils.create_reqparse_from_pydantic","title":"<code>create_reqparse_from_pydantic(model, location='json', bundle_errors=True)</code>","text":"<p>Create a Flask-RESTful RequestParser from a Pydantic model.</p> <p>Converts a Pydantic model into a Flask-RESTful RequestParser, mapping Pydantic field types to appropriate Python types for request parsing. Handles basic types as well as lists (arrays) and preserves field descriptions and required status.</p> <p>Parameters:</p> Name Type Description Default <code>model</code> <code>type[BaseModel]</code> <p>The Pydantic model class to convert to a RequestParser.</p> required <code>location</code> <code>str</code> <p>The location to look for arguments. Options include 'json', 'form', 'args', 'headers', etc. Defaults to 'json'.</p> <code>'json'</code> <code>bundle_errors</code> <code>bool</code> <p>Whether to bundle all errors in a single response. When False, the first error is returned. Defaults to True.</p> <code>True</code> <p>Returns:</p> Type Description <code>RequestParser</code> <p>reqparse.RequestParser: A configured Flask-RESTful RequestParser instance that can be used to parse and validate incoming requests.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from pydantic import BaseModel, Field\n&gt;&gt;&gt; from flask_restful import reqparse\n&gt;&gt;&gt; class UserModel(BaseModel):\n...     name: str = Field(..., description=\"User's full name\")\n...     age: int = Field(..., description=\"User's age in years\")\n...     tags: list[str] = Field([], description=\"User tags\")\n&gt;&gt;&gt; parser = create_reqparse_from_pydantic(UserModel)\n&gt;&gt;&gt; isinstance(parser, reqparse.RequestParser)\nTrue\n</code></pre> Source code in <code>src/flask_x_openapi_schema/x/flask_restful/utils.py</code> <pre><code>def create_reqparse_from_pydantic(\n    model: type[BaseModel], location: str = \"json\", bundle_errors: bool = True\n) -&gt; reqparse.RequestParser:\n    \"\"\"Create a Flask-RESTful RequestParser from a Pydantic model.\n\n    Converts a Pydantic model into a Flask-RESTful RequestParser, mapping Pydantic\n    field types to appropriate Python types for request parsing. Handles basic types\n    as well as lists (arrays) and preserves field descriptions and required status.\n\n    Args:\n        model: The Pydantic model class to convert to a RequestParser.\n        location: The location to look for arguments. Options include 'json',\n            'form', 'args', 'headers', etc. Defaults to 'json'.\n        bundle_errors: Whether to bundle all errors in a single response.\n            When False, the first error is returned. Defaults to True.\n\n    Returns:\n        reqparse.RequestParser: A configured Flask-RESTful RequestParser instance\n            that can be used to parse and validate incoming requests.\n\n    Examples:\n        &gt;&gt;&gt; from pydantic import BaseModel, Field\n        &gt;&gt;&gt; from flask_restful import reqparse\n        &gt;&gt;&gt; class UserModel(BaseModel):\n        ...     name: str = Field(..., description=\"User's full name\")\n        ...     age: int = Field(..., description=\"User's age in years\")\n        ...     tags: list[str] = Field([], description=\"User tags\")\n        &gt;&gt;&gt; parser = create_reqparse_from_pydantic(UserModel)\n        &gt;&gt;&gt; isinstance(parser, reqparse.RequestParser)\n        True\n\n    \"\"\"\n    parser = reqparse.RequestParser(bundle_errors=bundle_errors)\n\n    schema = model.model_json_schema()\n    properties = schema.get(\"properties\", {})\n    required = schema.get(\"required\", [])\n\n    for field_name, field_schema in properties.items():\n        field_type = field_schema.get(\"type\")\n        field_description = field_schema.get(\"description\", \"\")\n        field_required = field_name in required\n\n        type_mapping = {\n            \"string\": str,\n            \"integer\": int,\n            \"number\": float,\n            \"boolean\": bool,\n            \"array\": list,\n            \"object\": dict,\n        }\n\n        python_type = type_mapping.get(field_type, str)\n\n        if field_type == \"array\":\n            items = field_schema.get(\"items\", {})\n            item_type = items.get(\"type\", \"string\")\n            python_item_type = type_mapping.get(item_type, str)\n\n            parser.add_argument(\n                field_name,\n                type=python_item_type,\n                action=\"append\",\n                required=field_required,\n                help=field_description,\n                location=location,\n            )\n        else:\n            parser.add_argument(\n                field_name,\n                type=python_type,\n                required=field_required,\n                help=field_description,\n                location=location,\n            )\n\n    return parser\n</code></pre>"},{"location":"api/i18n/","title":"Internationalization Support","text":"<p>This section provides documentation for the internationalization (i18n) features of Flask-X-OpenAPI-Schema.</p> <p>Internationalization support for OpenAPI metadata.</p>"},{"location":"api/i18n/#flask_x_openapi_schema.i18n.I18nStr","title":"<code>I18nStr</code>","text":"<p>A string class that supports internationalization.</p> <p>This class allows you to define strings in multiple languages and automatically returns the appropriate string based on the current language setting.</p> <p>Parameters:</p> Name Type Description Default <code>strings</code> <code>dict[str, str] | str</code> <p>Either a dictionary mapping language codes to strings, or a single string</p> required <code>default_language</code> <code>str</code> <p>The default language to use if the requested language is not available</p> <code>'en-US'</code> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from flask_x_openapi_schema import I18nStr\n&gt;&gt;&gt; greeting = I18nStr({\"en-US\": \"Hello\", \"zh-Hans\": \"\u4f60\u597d\", \"ja-JP\": \"\u3053\u3093\u306b\u3061\u306f\"})\n&gt;&gt;&gt; str(greeting)\n'Hello'\n&gt;&gt;&gt; greeting.get(\"zh-Hans\")\n'\u4f60\u597d'\n&gt;&gt;&gt; # @openapi_metadata(\n&gt;&gt;&gt; #     summary=I18nStr({\n&gt;&gt;&gt; #         \"en-US\": \"Get an item\",\n&gt;&gt;&gt; #         \"zh-Hans\": \"\u83b7\u53d6\u4e00\u4e2a\u9879\u76ee\"\n&gt;&gt;&gt; #     })\n&gt;&gt;&gt; # )\n&gt;&gt;&gt; # def get(self, item_id):\n&gt;&gt;&gt; #     pass\n</code></pre> Source code in <code>src/flask_x_openapi_schema/i18n/i18n_string.py</code> <pre><code>class I18nStr:\n    \"\"\"A string class that supports internationalization.\n\n    This class allows you to define strings in multiple languages and automatically\n    returns the appropriate string based on the current language setting.\n\n    Args:\n        strings: Either a dictionary mapping language codes to strings, or a single string\n        default_language: The default language to use if the requested language is not available\n\n    Examples:\n        &gt;&gt;&gt; from flask_x_openapi_schema import I18nStr\n        &gt;&gt;&gt; greeting = I18nStr({\"en-US\": \"Hello\", \"zh-Hans\": \"\u4f60\u597d\", \"ja-JP\": \"\u3053\u3093\u306b\u3061\u306f\"})\n        &gt;&gt;&gt; str(greeting)\n        'Hello'\n        &gt;&gt;&gt; greeting.get(\"zh-Hans\")\n        '\u4f60\u597d'\n        &gt;&gt;&gt; # @openapi_metadata(\n        &gt;&gt;&gt; #     summary=I18nStr({\n        &gt;&gt;&gt; #         \"en-US\": \"Get an item\",\n        &gt;&gt;&gt; #         \"zh-Hans\": \"\u83b7\u53d6\u4e00\u4e2a\u9879\u76ee\"\n        &gt;&gt;&gt; #     })\n        &gt;&gt;&gt; # )\n        &gt;&gt;&gt; # def get(self, item_id):\n        &gt;&gt;&gt; #     pass\n\n    \"\"\"\n\n    __slots__ = (\"default_language\", \"strings\")\n\n    @classmethod\n    def __get_pydantic_core_schema__(cls, _source_type: Any, _handler: Any) -&gt; CoreSchema:\n        \"\"\"Generate a pydantic core schema for I18nString.\n\n        Args:\n            _source_type: Source type (unused)\n            _handler: Handler (unused)\n\n        Returns:\n            CoreSchema: A pydantic core schema for I18nString\n\n        \"\"\"\n        return core_schema.is_instance_schema(cls)\n\n    SUPPORTED_LANGUAGES: ClassVar[list[str]] = [\n        \"en-US\",\n        \"zh-Hans\",\n        \"zh-Hant\",\n        \"pt-BR\",\n        \"es-ES\",\n        \"fr-FR\",\n        \"de-DE\",\n        \"ja-JP\",\n        \"ko-KR\",\n        \"ru-RU\",\n        \"it-IT\",\n        \"uk-UA\",\n        \"vi-VN\",\n        \"ro-RO\",\n        \"pl-PL\",\n        \"hi-IN\",\n        \"tr-TR\",\n        \"fa-IR\",\n        \"sl-SI\",\n        \"th-TH\",\n    ]\n\n    def __init__(\n        self,\n        strings: dict[str, str] | str,\n        default_language: str = \"en-US\",\n    ) -&gt; None:\n        \"\"\"Initialize an I18nString.\n\n        Args:\n            strings: Either a dictionary mapping language codes to strings,\n                    or a single string (which will be used for all languages)\n            default_language: The default language to use if the requested language is not available\n\n        \"\"\"\n        self.default_language = default_language\n\n        if isinstance(strings, str):\n            self.strings = dict.fromkeys(self.SUPPORTED_LANGUAGES, strings)\n\n            self.strings[self.default_language] = strings\n        else:\n            self.strings = strings\n\n            if self.default_language not in self.strings:\n                if self.strings:\n                    self.strings[self.default_language] = next(iter(self.strings.values()))\n                else:\n                    self.strings[self.default_language] = \"\"\n\n    def get(self, language: str | None = None) -&gt; str:\n        \"\"\"Get the string in the specified language.\n\n        Args:\n            language: The language code to get the string for.\n                     If None, uses the current language.\n\n        Returns:\n            str: The string in the requested language, or the default language if not available\n\n        \"\"\"\n        if language is None:\n            language = get_current_language()\n\n        if language in self.strings:\n            return self.strings[language]\n\n        return self.strings[self.default_language]\n\n    def __str__(self) -&gt; str:\n        \"\"\"Get the string in the current language.\n\n        Returns:\n            str: The string in the current language\n\n        \"\"\"\n        return self.get()\n\n    def __repr__(self) -&gt; str:\n        \"\"\"Get a string representation of the I18nString.\n\n        Returns:\n            str: A string representation of the I18nString\n\n        \"\"\"\n        return f\"I18nString({self.strings})\"\n\n    def __eq__(self, other: object) -&gt; bool:\n        \"\"\"Compare this I18nString with another object.\n\n        Args:\n            other: The object to compare with\n\n        Returns:\n            bool: True if the objects are equal, False otherwise\n\n        \"\"\"\n        if isinstance(other, I18nStr):\n            return self.strings == other.strings\n        if isinstance(other, str):\n            return str(self) == other\n        return False\n\n    def __hash__(self) -&gt; int:\n        \"\"\"Get a hash value for the I18nString.\n\n        This is needed for using I18nString as a dictionary key or in sets.\n\n        Returns:\n            int: A hash value for the I18nString\n\n        \"\"\"\n        return hash((frozenset(self.strings.items()), self.default_language))\n\n    @classmethod\n    def create(cls, **kwargs: Any) -&gt; \"I18nStr\":\n        \"\"\"Create an I18nString from keyword arguments.\n\n        This is a convenience method for creating an I18nString with named language parameters.\n\n        Args:\n            **kwargs: Keyword arguments where the keys are language codes (with underscores\n                     instead of hyphens) and the values are the strings in those languages\n\n        Returns:\n            I18nStr: An I18nString instance\n\n        Examples:\n            &gt;&gt;&gt; from flask_x_openapi_schema.i18n.i18n_string import I18nStr\n            &gt;&gt;&gt; greeting = I18nStr.create(en_US=\"Hello\", zh_Hans=\"\u4f60\u597d\", ja_JP=\"\u3053\u3093\u306b\u3061\u306f\")\n            &gt;&gt;&gt; str(greeting)\n            'Hello'\n\n        \"\"\"\n        strings = {k.replace(\"_\", \"-\"): v for k, v in kwargs.items()}\n        return cls(strings)\n</code></pre>"},{"location":"api/i18n/#flask_x_openapi_schema.i18n.I18nStr.__eq__","title":"<code>__eq__(other)</code>","text":"<p>Compare this I18nString with another object.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>object</code> <p>The object to compare with</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if the objects are equal, False otherwise</p> Source code in <code>src/flask_x_openapi_schema/i18n/i18n_string.py</code> <pre><code>def __eq__(self, other: object) -&gt; bool:\n    \"\"\"Compare this I18nString with another object.\n\n    Args:\n        other: The object to compare with\n\n    Returns:\n        bool: True if the objects are equal, False otherwise\n\n    \"\"\"\n    if isinstance(other, I18nStr):\n        return self.strings == other.strings\n    if isinstance(other, str):\n        return str(self) == other\n    return False\n</code></pre>"},{"location":"api/i18n/#flask_x_openapi_schema.i18n.I18nStr.__get_pydantic_core_schema__","title":"<code>__get_pydantic_core_schema__(_source_type, _handler)</code>  <code>classmethod</code>","text":"<p>Generate a pydantic core schema for I18nString.</p> <p>Parameters:</p> Name Type Description Default <code>_source_type</code> <code>Any</code> <p>Source type (unused)</p> required <code>_handler</code> <code>Any</code> <p>Handler (unused)</p> required <p>Returns:</p> Name Type Description <code>CoreSchema</code> <code>CoreSchema</code> <p>A pydantic core schema for I18nString</p> Source code in <code>src/flask_x_openapi_schema/i18n/i18n_string.py</code> <pre><code>@classmethod\ndef __get_pydantic_core_schema__(cls, _source_type: Any, _handler: Any) -&gt; CoreSchema:\n    \"\"\"Generate a pydantic core schema for I18nString.\n\n    Args:\n        _source_type: Source type (unused)\n        _handler: Handler (unused)\n\n    Returns:\n        CoreSchema: A pydantic core schema for I18nString\n\n    \"\"\"\n    return core_schema.is_instance_schema(cls)\n</code></pre>"},{"location":"api/i18n/#flask_x_openapi_schema.i18n.I18nStr.__hash__","title":"<code>__hash__()</code>","text":"<p>Get a hash value for the I18nString.</p> <p>This is needed for using I18nString as a dictionary key or in sets.</p> <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>A hash value for the I18nString</p> Source code in <code>src/flask_x_openapi_schema/i18n/i18n_string.py</code> <pre><code>def __hash__(self) -&gt; int:\n    \"\"\"Get a hash value for the I18nString.\n\n    This is needed for using I18nString as a dictionary key or in sets.\n\n    Returns:\n        int: A hash value for the I18nString\n\n    \"\"\"\n    return hash((frozenset(self.strings.items()), self.default_language))\n</code></pre>"},{"location":"api/i18n/#flask_x_openapi_schema.i18n.I18nStr.__init__","title":"<code>__init__(strings, default_language='en-US')</code>","text":"<p>Initialize an I18nString.</p> <p>Parameters:</p> Name Type Description Default <code>strings</code> <code>dict[str, str] | str</code> <p>Either a dictionary mapping language codes to strings,     or a single string (which will be used for all languages)</p> required <code>default_language</code> <code>str</code> <p>The default language to use if the requested language is not available</p> <code>'en-US'</code> Source code in <code>src/flask_x_openapi_schema/i18n/i18n_string.py</code> <pre><code>def __init__(\n    self,\n    strings: dict[str, str] | str,\n    default_language: str = \"en-US\",\n) -&gt; None:\n    \"\"\"Initialize an I18nString.\n\n    Args:\n        strings: Either a dictionary mapping language codes to strings,\n                or a single string (which will be used for all languages)\n        default_language: The default language to use if the requested language is not available\n\n    \"\"\"\n    self.default_language = default_language\n\n    if isinstance(strings, str):\n        self.strings = dict.fromkeys(self.SUPPORTED_LANGUAGES, strings)\n\n        self.strings[self.default_language] = strings\n    else:\n        self.strings = strings\n\n        if self.default_language not in self.strings:\n            if self.strings:\n                self.strings[self.default_language] = next(iter(self.strings.values()))\n            else:\n                self.strings[self.default_language] = \"\"\n</code></pre>"},{"location":"api/i18n/#flask_x_openapi_schema.i18n.I18nStr.__repr__","title":"<code>__repr__()</code>","text":"<p>Get a string representation of the I18nString.</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>A string representation of the I18nString</p> Source code in <code>src/flask_x_openapi_schema/i18n/i18n_string.py</code> <pre><code>def __repr__(self) -&gt; str:\n    \"\"\"Get a string representation of the I18nString.\n\n    Returns:\n        str: A string representation of the I18nString\n\n    \"\"\"\n    return f\"I18nString({self.strings})\"\n</code></pre>"},{"location":"api/i18n/#flask_x_openapi_schema.i18n.I18nStr.__str__","title":"<code>__str__()</code>","text":"<p>Get the string in the current language.</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>The string in the current language</p> Source code in <code>src/flask_x_openapi_schema/i18n/i18n_string.py</code> <pre><code>def __str__(self) -&gt; str:\n    \"\"\"Get the string in the current language.\n\n    Returns:\n        str: The string in the current language\n\n    \"\"\"\n    return self.get()\n</code></pre>"},{"location":"api/i18n/#flask_x_openapi_schema.i18n.I18nStr.create","title":"<code>create(**kwargs)</code>  <code>classmethod</code>","text":"<p>Create an I18nString from keyword arguments.</p> <p>This is a convenience method for creating an I18nString with named language parameters.</p> <p>Parameters:</p> Name Type Description Default <code>**kwargs</code> <code>Any</code> <p>Keyword arguments where the keys are language codes (with underscores      instead of hyphens) and the values are the strings in those languages</p> <code>{}</code> <p>Returns:</p> Name Type Description <code>I18nStr</code> <code>I18nStr</code> <p>An I18nString instance</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from flask_x_openapi_schema.i18n.i18n_string import I18nStr\n&gt;&gt;&gt; greeting = I18nStr.create(en_US=\"Hello\", zh_Hans=\"\u4f60\u597d\", ja_JP=\"\u3053\u3093\u306b\u3061\u306f\")\n&gt;&gt;&gt; str(greeting)\n'Hello'\n</code></pre> Source code in <code>src/flask_x_openapi_schema/i18n/i18n_string.py</code> <pre><code>@classmethod\ndef create(cls, **kwargs: Any) -&gt; \"I18nStr\":\n    \"\"\"Create an I18nString from keyword arguments.\n\n    This is a convenience method for creating an I18nString with named language parameters.\n\n    Args:\n        **kwargs: Keyword arguments where the keys are language codes (with underscores\n                 instead of hyphens) and the values are the strings in those languages\n\n    Returns:\n        I18nStr: An I18nString instance\n\n    Examples:\n        &gt;&gt;&gt; from flask_x_openapi_schema.i18n.i18n_string import I18nStr\n        &gt;&gt;&gt; greeting = I18nStr.create(en_US=\"Hello\", zh_Hans=\"\u4f60\u597d\", ja_JP=\"\u3053\u3093\u306b\u3061\u306f\")\n        &gt;&gt;&gt; str(greeting)\n        'Hello'\n\n    \"\"\"\n    strings = {k.replace(\"_\", \"-\"): v for k, v in kwargs.items()}\n    return cls(strings)\n</code></pre>"},{"location":"api/i18n/#flask_x_openapi_schema.i18n.I18nStr.get","title":"<code>get(language=None)</code>","text":"<p>Get the string in the specified language.</p> <p>Parameters:</p> Name Type Description Default <code>language</code> <code>str | None</code> <p>The language code to get the string for.      If None, uses the current language.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>The string in the requested language, or the default language if not available</p> Source code in <code>src/flask_x_openapi_schema/i18n/i18n_string.py</code> <pre><code>def get(self, language: str | None = None) -&gt; str:\n    \"\"\"Get the string in the specified language.\n\n    Args:\n        language: The language code to get the string for.\n                 If None, uses the current language.\n\n    Returns:\n        str: The string in the requested language, or the default language if not available\n\n    \"\"\"\n    if language is None:\n        language = get_current_language()\n\n    if language in self.strings:\n        return self.strings[language]\n\n    return self.strings[self.default_language]\n</code></pre>"},{"location":"api/i18n/#flask_x_openapi_schema.i18n.get_current_language","title":"<code>get_current_language()</code>","text":"<p>Get the current language for the current thread.</p> <p>This function returns the language code that is currently set for the current thread. The language code is used for internationalization of strings in the OpenAPI schema.</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>The current language code (e.g., \"en-US\", \"zh-Hans\")</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from flask_x_openapi_schema import get_current_language\n&gt;&gt;&gt; get_current_language()\n'en-US'\n</code></pre> Source code in <code>src/flask_x_openapi_schema/i18n/i18n_string.py</code> <pre><code>def get_current_language() -&gt; str:\n    \"\"\"Get the current language for the current thread.\n\n    This function returns the language code that is currently set for the current thread.\n    The language code is used for internationalization of strings in the OpenAPI schema.\n\n    Returns:\n        str: The current language code (e.g., \"en-US\", \"zh-Hans\")\n\n    Examples:\n        &gt;&gt;&gt; from flask_x_openapi_schema import get_current_language\n        &gt;&gt;&gt; get_current_language()\n        'en-US'\n\n    \"\"\"\n    return _current_language.get()\n</code></pre>"},{"location":"api/i18n/#flask_x_openapi_schema.i18n.set_current_language","title":"<code>set_current_language(language)</code>","text":"<p>Set the current language for the current thread.</p> <p>This function sets the language code for the current thread. This affects how internationalized strings are displayed in the OpenAPI schema and in responses.</p> <p>Parameters:</p> Name Type Description Default <code>language</code> <code>str</code> <p>The language code to set (e.g., \"en-US\", \"zh-Hans\")</p> required <p>Examples:</p> <pre><code>&gt;&gt;&gt; from flask_x_openapi_schema import set_current_language\n&gt;&gt;&gt; set_current_language(\"zh-Hans\")\n</code></pre> Source code in <code>src/flask_x_openapi_schema/i18n/i18n_string.py</code> <pre><code>def set_current_language(language: str) -&gt; None:\n    \"\"\"Set the current language for the current thread.\n\n    This function sets the language code for the current thread. This affects how\n    internationalized strings are displayed in the OpenAPI schema and in responses.\n\n    Args:\n        language: The language code to set (e.g., \"en-US\", \"zh-Hans\")\n\n    Examples:\n        &gt;&gt;&gt; from flask_x_openapi_schema import set_current_language\n        &gt;&gt;&gt; set_current_language(\"zh-Hans\")\n\n    \"\"\"\n    _current_language.set(language)\n</code></pre>"},{"location":"api/models/","title":"Models","text":"<p>This section provides documentation for the model classes in Flask-X-OpenAPI-Schema.</p>"},{"location":"api/models/#base-models","title":"Base Models","text":"<p>Base models for OpenAPI schema generation.</p> <p>This module provides base models for generating OpenAPI schemas and handling API responses. It includes the BaseRespModel class which extends Pydantic's BaseModel to provide standardized methods for converting models to Flask-compatible responses.</p>"},{"location":"api/models/#flask_x_openapi_schema.models.base.BaseErrorResponse","title":"<code>BaseErrorResponse</code>","text":"<p>               Bases: <code>BaseRespModel</code></p> <p>Base model for API error responses.</p> <p>This class extends BaseRespModel to provide a standard way to represent error responses. It includes fields for error code, message, and details.</p> <p>All error responses in the application should inherit from this class to ensure consistent error handling.</p> <p>Attributes:</p> Name Type Description <code>error</code> <code>str</code> <p>Error identifier or code.</p> <code>message</code> <code>str</code> <p>Human-readable error message.</p> <code>details</code> <code>dict[str, Any] | None</code> <p>Optional additional error details.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from flask_x_openapi_schema import BaseErrorResponse\n&gt;&gt;&gt; error = BaseErrorResponse(error=\"VALIDATION_ERROR\", message=\"Invalid input data\")\n&gt;&gt;&gt; response = error.to_response(400)\n&gt;&gt;&gt; response[1]\n400\n&gt;&gt;&gt; response[0][\"error\"]\n'VALIDATION_ERROR'\n</code></pre> Source code in <code>src/flask_x_openapi_schema/models/base.py</code> <pre><code>class BaseErrorResponse(BaseRespModel):\n    \"\"\"Base model for API error responses.\n\n    This class extends BaseRespModel to provide a standard way to represent\n    error responses. It includes fields for error code, message, and details.\n\n    All error responses in the application should inherit from this class\n    to ensure consistent error handling.\n\n    Attributes:\n        error: Error identifier or code.\n        message: Human-readable error message.\n        details: Optional additional error details.\n\n    Examples:\n        &gt;&gt;&gt; from flask_x_openapi_schema import BaseErrorResponse\n        &gt;&gt;&gt; error = BaseErrorResponse(error=\"VALIDATION_ERROR\", message=\"Invalid input data\")\n        &gt;&gt;&gt; response = error.to_response(400)\n        &gt;&gt;&gt; response[1]\n        400\n        &gt;&gt;&gt; response[0][\"error\"]\n        'VALIDATION_ERROR'\n\n    \"\"\"\n\n    error: str = Field(..., description=\"Error identifier or code\")\n    message: str = Field(..., description=\"Human-readable error message\")\n    details: dict[str, Any] | None = Field(None, description=\"Additional error details\")\n</code></pre>"},{"location":"api/models/#flask_x_openapi_schema.models.base.BaseRespModel","title":"<code>BaseRespModel</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Base model for API responses.</p> <p>This class extends Pydantic's BaseModel to provide a standard way to convert response models to Flask-compatible responses. It includes methods for converting the model to dictionaries and Flask response objects.</p> <p>Attributes:</p> Name Type Description <code>model_config</code> <p>Configuration for the Pydantic model.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from flask_x_openapi_schema import BaseRespModel\n&gt;&gt;&gt; from pydantic import Field\n&gt;&gt;&gt;\n&gt;&gt;&gt; class UserResponse(BaseRespModel):\n...     id: str = Field(..., description=\"User ID\")\n...     name: str = Field(..., description=\"User name\")\n...     email: str = Field(..., description=\"User email\")\n&gt;&gt;&gt; def get(self):\n...     return UserResponse(id=\"123\", name=\"John Doe\", email=\"john@example.com\")\n&gt;&gt;&gt; def post(self):\n...     return UserResponse(id=\"123\", name=\"John Doe\", email=\"john@example.com\"), 201\n&gt;&gt;&gt; def put(self):\n...     user = UserResponse(id=\"123\", name=\"John Doe\", email=\"john@example.com\")\n...     return user.to_response(status_code=200)\n</code></pre> Source code in <code>src/flask_x_openapi_schema/models/base.py</code> <pre><code>class BaseRespModel(BaseModel):\n    \"\"\"Base model for API responses.\n\n    This class extends Pydantic's BaseModel to provide a standard way to convert\n    response models to Flask-compatible responses. It includes methods for converting\n    the model to dictionaries and Flask response objects.\n\n    Attributes:\n        model_config: Configuration for the Pydantic model.\n\n    Examples:\n        &gt;&gt;&gt; from flask_x_openapi_schema import BaseRespModel\n        &gt;&gt;&gt; from pydantic import Field\n        &gt;&gt;&gt;\n        &gt;&gt;&gt; class UserResponse(BaseRespModel):\n        ...     id: str = Field(..., description=\"User ID\")\n        ...     name: str = Field(..., description=\"User name\")\n        ...     email: str = Field(..., description=\"User email\")\n        &gt;&gt;&gt; def get(self):\n        ...     return UserResponse(id=\"123\", name=\"John Doe\", email=\"john@example.com\")\n        &gt;&gt;&gt; def post(self):\n        ...     return UserResponse(id=\"123\", name=\"John Doe\", email=\"john@example.com\"), 201\n        &gt;&gt;&gt; def put(self):\n        ...     user = UserResponse(id=\"123\", name=\"John Doe\", email=\"john@example.com\")\n        ...     return user.to_response(status_code=200)\n\n    \"\"\"\n\n    model_config = ConfigDict(\n        populate_by_name=True,\n        validate_assignment=True,\n        extra=\"ignore\",\n        arbitrary_types_allowed=True,\n    )\n\n    @classmethod\n    def from_dict(cls, data: dict[str, Any]) -&gt; Self:\n        \"\"\"Create a model instance from a dictionary.\n\n        Args:\n            data: Dictionary containing model data.\n\n        Returns:\n            An instance of the model.\n\n        Examples:\n            &gt;&gt;&gt; from flask_x_openapi_schema import BaseRespModel\n            &gt;&gt;&gt; from pydantic import Field\n            &gt;&gt;&gt; class UserResponse(BaseRespModel):\n            ...     id: str = Field(..., description=\"User ID\")\n            ...     name: str = Field(..., description=\"User name\")\n            ...     email: str = Field(..., description=\"User email\")\n            &gt;&gt;&gt; data = {\"id\": \"123\", \"name\": \"John Doe\", \"email\": \"john@example.com\"}\n            &gt;&gt;&gt; user = UserResponse.from_dict(data)\n            &gt;&gt;&gt; user.id\n            '123'\n\n        \"\"\"\n        return cls(**data)\n\n    def to_dict(self) -&gt; dict[str, Any]:\n        \"\"\"Convert the model to a dictionary.\n\n        Returns:\n            A dictionary representation of the model.\n\n        Examples:\n            &gt;&gt;&gt; from flask_x_openapi_schema import BaseRespModel\n            &gt;&gt;&gt; from pydantic import Field\n            &gt;&gt;&gt; class UserResponse(BaseRespModel):\n            ...     id: str = Field(..., description=\"User ID\")\n            ...     name: str = Field(..., description=\"User name\")\n            ...     email: str = Field(..., description=\"User email\")\n            &gt;&gt;&gt; user = UserResponse(id=\"123\", name=\"John Doe\", email=\"john@example.com\")\n            &gt;&gt;&gt; user_dict = user.to_dict()\n            &gt;&gt;&gt; user_dict\n            {'id': '123', 'name': 'John Doe', 'email': 'john@example.com'}\n\n        \"\"\"\n        return self.model_dump(exclude_none=True, mode=\"json\")\n\n    def to_response(self, status_code: int | None = None) -&gt; dict[str, Any] | tuple[dict[str, Any], int]:\n        \"\"\"Convert the model to a Flask-compatible response.\n\n        Args:\n            status_code: Optional HTTP status code.\n\n        Returns:\n            A Flask-compatible response (dict or tuple with dict and status code).\n\n        Examples:\n            &gt;&gt;&gt; from flask_x_openapi_schema import BaseRespModel\n            &gt;&gt;&gt; from pydantic import Field\n            &gt;&gt;&gt; class UserResponse(BaseRespModel):\n            ...     id: str = Field(..., description=\"User ID\")\n            ...     name: str = Field(..., description=\"User name\")\n            ...     email: str = Field(..., description=\"User email\")\n            &gt;&gt;&gt; user = UserResponse(id=\"123\", name=\"John Doe\", email=\"john@example.com\")\n            &gt;&gt;&gt; response = user.to_response()\n            &gt;&gt;&gt; isinstance(response, dict)\n            True\n            &gt;&gt;&gt; response = user.to_response(status_code=201)\n            &gt;&gt;&gt; isinstance(response, tuple) and response[1] == 201\n            True\n\n        \"\"\"\n        response_dict = self.to_dict()\n\n        if status_code is not None:\n            return response_dict, status_code\n\n        return response_dict\n</code></pre>"},{"location":"api/models/#flask_x_openapi_schema.models.base.BaseRespModel.from_dict","title":"<code>from_dict(data)</code>  <code>classmethod</code>","text":"<p>Create a model instance from a dictionary.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>dict[str, Any]</code> <p>Dictionary containing model data.</p> required <p>Returns:</p> Type Description <code>Self</code> <p>An instance of the model.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from flask_x_openapi_schema import BaseRespModel\n&gt;&gt;&gt; from pydantic import Field\n&gt;&gt;&gt; class UserResponse(BaseRespModel):\n...     id: str = Field(..., description=\"User ID\")\n...     name: str = Field(..., description=\"User name\")\n...     email: str = Field(..., description=\"User email\")\n&gt;&gt;&gt; data = {\"id\": \"123\", \"name\": \"John Doe\", \"email\": \"john@example.com\"}\n&gt;&gt;&gt; user = UserResponse.from_dict(data)\n&gt;&gt;&gt; user.id\n'123'\n</code></pre> Source code in <code>src/flask_x_openapi_schema/models/base.py</code> <pre><code>@classmethod\ndef from_dict(cls, data: dict[str, Any]) -&gt; Self:\n    \"\"\"Create a model instance from a dictionary.\n\n    Args:\n        data: Dictionary containing model data.\n\n    Returns:\n        An instance of the model.\n\n    Examples:\n        &gt;&gt;&gt; from flask_x_openapi_schema import BaseRespModel\n        &gt;&gt;&gt; from pydantic import Field\n        &gt;&gt;&gt; class UserResponse(BaseRespModel):\n        ...     id: str = Field(..., description=\"User ID\")\n        ...     name: str = Field(..., description=\"User name\")\n        ...     email: str = Field(..., description=\"User email\")\n        &gt;&gt;&gt; data = {\"id\": \"123\", \"name\": \"John Doe\", \"email\": \"john@example.com\"}\n        &gt;&gt;&gt; user = UserResponse.from_dict(data)\n        &gt;&gt;&gt; user.id\n        '123'\n\n    \"\"\"\n    return cls(**data)\n</code></pre>"},{"location":"api/models/#flask_x_openapi_schema.models.base.BaseRespModel.to_dict","title":"<code>to_dict()</code>","text":"<p>Convert the model to a dictionary.</p> <p>Returns:</p> Type Description <code>dict[str, Any]</code> <p>A dictionary representation of the model.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from flask_x_openapi_schema import BaseRespModel\n&gt;&gt;&gt; from pydantic import Field\n&gt;&gt;&gt; class UserResponse(BaseRespModel):\n...     id: str = Field(..., description=\"User ID\")\n...     name: str = Field(..., description=\"User name\")\n...     email: str = Field(..., description=\"User email\")\n&gt;&gt;&gt; user = UserResponse(id=\"123\", name=\"John Doe\", email=\"john@example.com\")\n&gt;&gt;&gt; user_dict = user.to_dict()\n&gt;&gt;&gt; user_dict\n{'id': '123', 'name': 'John Doe', 'email': 'john@example.com'}\n</code></pre> Source code in <code>src/flask_x_openapi_schema/models/base.py</code> <pre><code>def to_dict(self) -&gt; dict[str, Any]:\n    \"\"\"Convert the model to a dictionary.\n\n    Returns:\n        A dictionary representation of the model.\n\n    Examples:\n        &gt;&gt;&gt; from flask_x_openapi_schema import BaseRespModel\n        &gt;&gt;&gt; from pydantic import Field\n        &gt;&gt;&gt; class UserResponse(BaseRespModel):\n        ...     id: str = Field(..., description=\"User ID\")\n        ...     name: str = Field(..., description=\"User name\")\n        ...     email: str = Field(..., description=\"User email\")\n        &gt;&gt;&gt; user = UserResponse(id=\"123\", name=\"John Doe\", email=\"john@example.com\")\n        &gt;&gt;&gt; user_dict = user.to_dict()\n        &gt;&gt;&gt; user_dict\n        {'id': '123', 'name': 'John Doe', 'email': 'john@example.com'}\n\n    \"\"\"\n    return self.model_dump(exclude_none=True, mode=\"json\")\n</code></pre>"},{"location":"api/models/#flask_x_openapi_schema.models.base.BaseRespModel.to_response","title":"<code>to_response(status_code=None)</code>","text":"<p>Convert the model to a Flask-compatible response.</p> <p>Parameters:</p> Name Type Description Default <code>status_code</code> <code>int | None</code> <p>Optional HTTP status code.</p> <code>None</code> <p>Returns:</p> Type Description <code>dict[str, Any] | tuple[dict[str, Any], int]</code> <p>A Flask-compatible response (dict or tuple with dict and status code).</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from flask_x_openapi_schema import BaseRespModel\n&gt;&gt;&gt; from pydantic import Field\n&gt;&gt;&gt; class UserResponse(BaseRespModel):\n...     id: str = Field(..., description=\"User ID\")\n...     name: str = Field(..., description=\"User name\")\n...     email: str = Field(..., description=\"User email\")\n&gt;&gt;&gt; user = UserResponse(id=\"123\", name=\"John Doe\", email=\"john@example.com\")\n&gt;&gt;&gt; response = user.to_response()\n&gt;&gt;&gt; isinstance(response, dict)\nTrue\n&gt;&gt;&gt; response = user.to_response(status_code=201)\n&gt;&gt;&gt; isinstance(response, tuple) and response[1] == 201\nTrue\n</code></pre> Source code in <code>src/flask_x_openapi_schema/models/base.py</code> <pre><code>def to_response(self, status_code: int | None = None) -&gt; dict[str, Any] | tuple[dict[str, Any], int]:\n    \"\"\"Convert the model to a Flask-compatible response.\n\n    Args:\n        status_code: Optional HTTP status code.\n\n    Returns:\n        A Flask-compatible response (dict or tuple with dict and status code).\n\n    Examples:\n        &gt;&gt;&gt; from flask_x_openapi_schema import BaseRespModel\n        &gt;&gt;&gt; from pydantic import Field\n        &gt;&gt;&gt; class UserResponse(BaseRespModel):\n        ...     id: str = Field(..., description=\"User ID\")\n        ...     name: str = Field(..., description=\"User name\")\n        ...     email: str = Field(..., description=\"User email\")\n        &gt;&gt;&gt; user = UserResponse(id=\"123\", name=\"John Doe\", email=\"john@example.com\")\n        &gt;&gt;&gt; response = user.to_response()\n        &gt;&gt;&gt; isinstance(response, dict)\n        True\n        &gt;&gt;&gt; response = user.to_response(status_code=201)\n        &gt;&gt;&gt; isinstance(response, tuple) and response[1] == 201\n        True\n\n    \"\"\"\n    response_dict = self.to_dict()\n\n    if status_code is not None:\n        return response_dict, status_code\n\n    return response_dict\n</code></pre>"},{"location":"api/models/#file-upload-models","title":"File Upload Models","text":"<p>Pydantic models for file uploads in OpenAPI.</p> <p>This module provides a structured way to handle file uploads with validation and type hints. The models are designed to work with OpenAPI 3.0.x specification and provide proper validation for different file types.</p>"},{"location":"api/models/#flask_x_openapi_schema.models.file_models.AudioField","title":"<code>AudioField</code>","text":"<p>               Bases: <code>FileField</code></p> <p>Field for audio file uploads in OpenAPI schema.</p> Source code in <code>src/flask_x_openapi_schema/models/file_models.py</code> <pre><code>class AudioField(FileField):\n    \"\"\"Field for audio file uploads in OpenAPI schema.\"\"\"\n</code></pre>"},{"location":"api/models/#flask_x_openapi_schema.models.file_models.DocumentUploadModel","title":"<code>DocumentUploadModel</code>","text":"<p>               Bases: <code>FileUploadModel</code></p> <p>Model for document file uploads with validation.</p> <p>This model extends FileUploadModel to provide specific validation for document files. It validates file extensions and optionally checks file size.</p> <p>Attributes:</p> Name Type Description <code>file</code> <code>FileStorage</code> <p>The uploaded document file.</p> <code>allowed_extensions</code> <code>list[str]</code> <p>List of allowed file extensions.</p> <code>max_size</code> <code>int | None</code> <p>Maximum file size in bytes.</p> Source code in <code>src/flask_x_openapi_schema/models/file_models.py</code> <pre><code>class DocumentUploadModel(FileUploadModel):\n    \"\"\"Model for document file uploads with validation.\n\n    This model extends FileUploadModel to provide specific validation for document files.\n    It validates file extensions and optionally checks file size.\n\n    Attributes:\n        file: The uploaded document file.\n        allowed_extensions: List of allowed file extensions.\n        max_size: Maximum file size in bytes.\n\n    \"\"\"\n\n    file: FileStorage = Field(..., description=\"The uploaded document file\")\n    allowed_extensions: list[str] = Field(\n        default=[\"pdf\", \"doc\", \"docx\", \"txt\", \"rtf\", \"md\"],\n        description=\"Allowed file extensions\",\n    )\n    max_size: int | None = Field(default=None, description=\"Maximum file size in bytes\")\n\n    @field_validator(\"file\")\n    @classmethod\n    def validate_document_file(cls, v: FileStorage, info: pydantic.ValidationInfo) -&gt; FileStorage:\n        \"\"\"Validate that the file is a document with allowed extension and size.\n\n        Args:\n            v: The file to validate.\n            info: Validation context information.\n\n        Returns:\n            FileStorage: The validated file.\n\n        Raises:\n            ValueError: If the file is invalid, has a disallowed extension, or exceeds the maximum size.\n\n        \"\"\"\n        values = info.data\n\n        if not v or not v.filename:\n            msg = \"No file provided\"\n            raise ValueError(msg)\n\n        allowed_extensions = values.get(\"allowed_extensions\", [\"pdf\", \"doc\", \"docx\", \"txt\", \"rtf\", \"md\"])\n        if \".\" in v.filename:\n            ext = v.filename.rsplit(\".\", 1)[1].lower()\n            if ext not in allowed_extensions:\n                msg = f\"File extension '{ext}' not allowed. Allowed extensions: {', '.join(allowed_extensions)}\"\n                raise ValueError(\n                    msg,\n                )\n\n        max_size = values.get(\"max_size\")\n        if max_size is not None:\n            v.seek(0, 2)\n            size = v.tell()\n            v.seek(0)\n\n            if size &gt; max_size:\n                msg = f\"File size ({size} bytes) exceeds maximum allowed size ({max_size} bytes)\"\n                raise ValueError(msg)\n\n        return v\n</code></pre>"},{"location":"api/models/#flask_x_openapi_schema.models.file_models.DocumentUploadModel.validate_document_file","title":"<code>validate_document_file(v, info)</code>  <code>classmethod</code>","text":"<p>Validate that the file is a document with allowed extension and size.</p> <p>Parameters:</p> Name Type Description Default <code>v</code> <code>FileStorage</code> <p>The file to validate.</p> required <code>info</code> <code>ValidationInfo</code> <p>Validation context information.</p> required <p>Returns:</p> Name Type Description <code>FileStorage</code> <code>FileStorage</code> <p>The validated file.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the file is invalid, has a disallowed extension, or exceeds the maximum size.</p> Source code in <code>src/flask_x_openapi_schema/models/file_models.py</code> <pre><code>@field_validator(\"file\")\n@classmethod\ndef validate_document_file(cls, v: FileStorage, info: pydantic.ValidationInfo) -&gt; FileStorage:\n    \"\"\"Validate that the file is a document with allowed extension and size.\n\n    Args:\n        v: The file to validate.\n        info: Validation context information.\n\n    Returns:\n        FileStorage: The validated file.\n\n    Raises:\n        ValueError: If the file is invalid, has a disallowed extension, or exceeds the maximum size.\n\n    \"\"\"\n    values = info.data\n\n    if not v or not v.filename:\n        msg = \"No file provided\"\n        raise ValueError(msg)\n\n    allowed_extensions = values.get(\"allowed_extensions\", [\"pdf\", \"doc\", \"docx\", \"txt\", \"rtf\", \"md\"])\n    if \".\" in v.filename:\n        ext = v.filename.rsplit(\".\", 1)[1].lower()\n        if ext not in allowed_extensions:\n            msg = f\"File extension '{ext}' not allowed. Allowed extensions: {', '.join(allowed_extensions)}\"\n            raise ValueError(\n                msg,\n            )\n\n    max_size = values.get(\"max_size\")\n    if max_size is not None:\n        v.seek(0, 2)\n        size = v.tell()\n        v.seek(0)\n\n        if size &gt; max_size:\n            msg = f\"File size ({size} bytes) exceeds maximum allowed size ({max_size} bytes)\"\n            raise ValueError(msg)\n\n    return v\n</code></pre>"},{"location":"api/models/#flask_x_openapi_schema.models.file_models.FileField","title":"<code>FileField</code>","text":"<p>               Bases: <code>str</code></p> <p>Field for file uploads in OpenAPI schema.</p> <p>This class is used as a type annotation for file upload fields in Pydantic models. It is a subclass of str, but with additional metadata for OpenAPI schema generation.</p> Source code in <code>src/flask_x_openapi_schema/models/file_models.py</code> <pre><code>class FileField(str):\n    \"\"\"Field for file uploads in OpenAPI schema.\n\n    This class is used as a type annotation for file upload fields in Pydantic models.\n    It is a subclass of str, but with additional metadata for OpenAPI schema generation.\n    \"\"\"\n\n    __slots__ = ()\n\n    @classmethod\n    def __get_pydantic_core_schema__(cls, _source_type: Any, _handler: Any) -&gt; core_schema.PlainValidatorFunctionSchema:\n        \"\"\"Define the Pydantic core schema for this type.\n\n        This is the recommended way to define custom types in Pydantic v2.\n\n        Args:\n            _source_type: Source type information from Pydantic.\n            _handler: Handler function from Pydantic.\n\n        Returns:\n            A Pydantic core schema for this type.\n\n        \"\"\"\n        return core_schema.with_info_plain_validator_function(\n            cls._validate,\n            serialization=core_schema.str_schema(),\n        )\n\n    @classmethod\n    def _validate(cls, v: _T, info: pydantic.ValidationInfo) -&gt; _T:  # noqa: ARG003\n        \"\"\"Validate the value according to Pydantic v2 requirements.\n\n        Args:\n            v: The value to validate.\n            info: Validation context information from Pydantic.\n\n        Returns:\n            The validated value.\n\n        Raises:\n            ValueError: If the value is None.\n\n        \"\"\"\n        if v is None:\n            msg = \"File is required\"\n            raise ValueError(msg)\n        return v\n\n    @classmethod\n    def __get_pydantic_json_schema__(cls, _schema_generator: Any, _field_schema: Any) -&gt; dict[str, str]:\n        \"\"\"Define the JSON schema for OpenAPI.\n\n        Args:\n            _schema_generator: Schema generator from Pydantic.\n            _field_schema: Field schema from Pydantic.\n\n        Returns:\n            dict: A dictionary representing the JSON schema for this field.\n\n        \"\"\"\n        return {\"type\": \"string\", \"format\": \"binary\"}\n\n    def __new__(cls, *args: Any, **kwargs: Any) -&gt; Any:  # noqa: ARG004\n        \"\"\"Create a new instance of the class.\n\n        If a file object is provided, return it directly.\n\n        Args:\n            *args: Variable length argument list.\n            **kwargs: Arbitrary keyword arguments.\n\n        Returns:\n            The file object if provided, otherwise a new instance of the class.\n\n        \"\"\"\n        file_obj = kwargs.get(\"file\")\n        if file_obj is not None:\n            return file_obj\n        return str.__new__(cls, \"\")\n</code></pre>"},{"location":"api/models/#flask_x_openapi_schema.models.file_models.FileField.__get_pydantic_core_schema__","title":"<code>__get_pydantic_core_schema__(_source_type, _handler)</code>  <code>classmethod</code>","text":"<p>Define the Pydantic core schema for this type.</p> <p>This is the recommended way to define custom types in Pydantic v2.</p> <p>Parameters:</p> Name Type Description Default <code>_source_type</code> <code>Any</code> <p>Source type information from Pydantic.</p> required <code>_handler</code> <code>Any</code> <p>Handler function from Pydantic.</p> required <p>Returns:</p> Type Description <code>PlainValidatorFunctionSchema</code> <p>A Pydantic core schema for this type.</p> Source code in <code>src/flask_x_openapi_schema/models/file_models.py</code> <pre><code>@classmethod\ndef __get_pydantic_core_schema__(cls, _source_type: Any, _handler: Any) -&gt; core_schema.PlainValidatorFunctionSchema:\n    \"\"\"Define the Pydantic core schema for this type.\n\n    This is the recommended way to define custom types in Pydantic v2.\n\n    Args:\n        _source_type: Source type information from Pydantic.\n        _handler: Handler function from Pydantic.\n\n    Returns:\n        A Pydantic core schema for this type.\n\n    \"\"\"\n    return core_schema.with_info_plain_validator_function(\n        cls._validate,\n        serialization=core_schema.str_schema(),\n    )\n</code></pre>"},{"location":"api/models/#flask_x_openapi_schema.models.file_models.FileField.__get_pydantic_json_schema__","title":"<code>__get_pydantic_json_schema__(_schema_generator, _field_schema)</code>  <code>classmethod</code>","text":"<p>Define the JSON schema for OpenAPI.</p> <p>Parameters:</p> Name Type Description Default <code>_schema_generator</code> <code>Any</code> <p>Schema generator from Pydantic.</p> required <code>_field_schema</code> <code>Any</code> <p>Field schema from Pydantic.</p> required <p>Returns:</p> Name Type Description <code>dict</code> <code>dict[str, str]</code> <p>A dictionary representing the JSON schema for this field.</p> Source code in <code>src/flask_x_openapi_schema/models/file_models.py</code> <pre><code>@classmethod\ndef __get_pydantic_json_schema__(cls, _schema_generator: Any, _field_schema: Any) -&gt; dict[str, str]:\n    \"\"\"Define the JSON schema for OpenAPI.\n\n    Args:\n        _schema_generator: Schema generator from Pydantic.\n        _field_schema: Field schema from Pydantic.\n\n    Returns:\n        dict: A dictionary representing the JSON schema for this field.\n\n    \"\"\"\n    return {\"type\": \"string\", \"format\": \"binary\"}\n</code></pre>"},{"location":"api/models/#flask_x_openapi_schema.models.file_models.FileField.__new__","title":"<code>__new__(*args, **kwargs)</code>","text":"<p>Create a new instance of the class.</p> <p>If a file object is provided, return it directly.</p> <p>Parameters:</p> Name Type Description Default <code>*args</code> <code>Any</code> <p>Variable length argument list.</p> <code>()</code> <code>**kwargs</code> <code>Any</code> <p>Arbitrary keyword arguments.</p> <code>{}</code> <p>Returns:</p> Type Description <code>Any</code> <p>The file object if provided, otherwise a new instance of the class.</p> Source code in <code>src/flask_x_openapi_schema/models/file_models.py</code> <pre><code>def __new__(cls, *args: Any, **kwargs: Any) -&gt; Any:  # noqa: ARG004\n    \"\"\"Create a new instance of the class.\n\n    If a file object is provided, return it directly.\n\n    Args:\n        *args: Variable length argument list.\n        **kwargs: Arbitrary keyword arguments.\n\n    Returns:\n        The file object if provided, otherwise a new instance of the class.\n\n    \"\"\"\n    file_obj = kwargs.get(\"file\")\n    if file_obj is not None:\n        return file_obj\n    return str.__new__(cls, \"\")\n</code></pre>"},{"location":"api/models/#flask_x_openapi_schema.models.file_models.FileType","title":"<code>FileType</code>","text":"<p>               Bases: <code>str</code>, <code>Enum</code></p> <p>Enumeration of file types for OpenAPI schema.</p> Source code in <code>src/flask_x_openapi_schema/models/file_models.py</code> <pre><code>class FileType(str, Enum):\n    \"\"\"Enumeration of file types for OpenAPI schema.\"\"\"\n\n    BINARY = \"binary\"\n    IMAGE = \"image\"\n    AUDIO = \"audio\"\n    VIDEO = \"video\"\n    PDF = \"pdf\"\n    TEXT = \"text\"\n</code></pre>"},{"location":"api/models/#flask_x_openapi_schema.models.file_models.FileUploadModel","title":"<code>FileUploadModel</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Base model for file uploads.</p> <p>This model provides a structured way to handle file uploads with validation. It automatically validates that the uploaded file is a valid FileStorage instance.</p> <p>Attributes:</p> Name Type Description <code>file</code> <code>FileStorage</code> <p>The uploaded file.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from flask_x_openapi_schema.models.file_models import FileUploadModel\n&gt;&gt;&gt; # Example usage in a Flask route\n&gt;&gt;&gt; # @openapi_metadata(summary=\"Upload a file\")\n&gt;&gt;&gt; # def post(self, _x_file: FileUploadModel):\n&gt;&gt;&gt; #     return {\"filename\": _x_file.file.filename}\n</code></pre> Source code in <code>src/flask_x_openapi_schema/models/file_models.py</code> <pre><code>class FileUploadModel(BaseModel):\n    \"\"\"Base model for file uploads.\n\n    This model provides a structured way to handle file uploads with validation.\n    It automatically validates that the uploaded file is a valid FileStorage instance.\n\n    Attributes:\n        file: The uploaded file.\n\n    Examples:\n        &gt;&gt;&gt; from flask_x_openapi_schema.models.file_models import FileUploadModel\n        &gt;&gt;&gt; # Example usage in a Flask route\n        &gt;&gt;&gt; # @openapi_metadata(summary=\"Upload a file\")\n        &gt;&gt;&gt; # def post(self, _x_file: FileUploadModel):\n        &gt;&gt;&gt; #     return {\"filename\": _x_file.file.filename}\n\n    \"\"\"\n\n    file: FileStorage = Field(..., description=\"The uploaded file\")\n\n    model_config = ConfigDict(arbitrary_types_allowed=True, json_schema_extra={\"multipart/form-data\": True})\n\n    @field_validator(\"file\")\n    @classmethod\n    def validate_file(cls, v: Any) -&gt; FileStorage:\n        \"\"\"Validate that the file is a FileStorage instance.\n\n        Args:\n            v: The value to validate.\n\n        Returns:\n            FileStorage: The validated FileStorage instance.\n\n        Raises:\n            ValueError: If the value is not a FileStorage instance.\n\n        \"\"\"\n        if not isinstance(v, FileStorage):\n            msg = \"Not a valid file upload\"\n            raise ValueError(msg)\n        return v\n</code></pre>"},{"location":"api/models/#flask_x_openapi_schema.models.file_models.FileUploadModel.validate_file","title":"<code>validate_file(v)</code>  <code>classmethod</code>","text":"<p>Validate that the file is a FileStorage instance.</p> <p>Parameters:</p> Name Type Description Default <code>v</code> <code>Any</code> <p>The value to validate.</p> required <p>Returns:</p> Name Type Description <code>FileStorage</code> <code>FileStorage</code> <p>The validated FileStorage instance.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the value is not a FileStorage instance.</p> Source code in <code>src/flask_x_openapi_schema/models/file_models.py</code> <pre><code>@field_validator(\"file\")\n@classmethod\ndef validate_file(cls, v: Any) -&gt; FileStorage:\n    \"\"\"Validate that the file is a FileStorage instance.\n\n    Args:\n        v: The value to validate.\n\n    Returns:\n        FileStorage: The validated FileStorage instance.\n\n    Raises:\n        ValueError: If the value is not a FileStorage instance.\n\n    \"\"\"\n    if not isinstance(v, FileStorage):\n        msg = \"Not a valid file upload\"\n        raise ValueError(msg)\n    return v\n</code></pre>"},{"location":"api/models/#flask_x_openapi_schema.models.file_models.ImageField","title":"<code>ImageField</code>","text":"<p>               Bases: <code>FileField</code></p> <p>Field for image file uploads in OpenAPI schema.</p> Source code in <code>src/flask_x_openapi_schema/models/file_models.py</code> <pre><code>class ImageField(FileField):\n    \"\"\"Field for image file uploads in OpenAPI schema.\"\"\"\n</code></pre>"},{"location":"api/models/#flask_x_openapi_schema.models.file_models.ImageUploadModel","title":"<code>ImageUploadModel</code>","text":"<p>               Bases: <code>FileUploadModel</code></p> <p>Model for image file uploads with validation.</p> <p>This model extends FileUploadModel to provide specific validation for image files. It validates file extensions and optionally checks file size.</p> <p>Attributes:</p> Name Type Description <code>file</code> <code>FileStorage</code> <p>The uploaded image file.</p> <code>allowed_extensions</code> <code>list[str]</code> <p>List of allowed file extensions.</p> <code>max_size</code> <code>int | None</code> <p>Maximum file size in bytes.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from flask_x_openapi_schema.models.file_models import ImageUploadModel\n&gt;&gt;&gt; # Example usage in a Flask route\n&gt;&gt;&gt; # @openapi_metadata(summary=\"Upload an image\")\n&gt;&gt;&gt; # def post(self, _x_file: ImageUploadModel):\n&gt;&gt;&gt; #     return {\"filename\": _x_file.file.filename}\n</code></pre> Source code in <code>src/flask_x_openapi_schema/models/file_models.py</code> <pre><code>class ImageUploadModel(FileUploadModel):\n    \"\"\"Model for image file uploads with validation.\n\n    This model extends FileUploadModel to provide specific validation for image files.\n    It validates file extensions and optionally checks file size.\n\n    Attributes:\n        file: The uploaded image file.\n        allowed_extensions: List of allowed file extensions.\n        max_size: Maximum file size in bytes.\n\n    Examples:\n        &gt;&gt;&gt; from flask_x_openapi_schema.models.file_models import ImageUploadModel\n        &gt;&gt;&gt; # Example usage in a Flask route\n        &gt;&gt;&gt; # @openapi_metadata(summary=\"Upload an image\")\n        &gt;&gt;&gt; # def post(self, _x_file: ImageUploadModel):\n        &gt;&gt;&gt; #     return {\"filename\": _x_file.file.filename}\n\n    \"\"\"\n\n    file: FileStorage = Field(..., description=\"The uploaded image file\")\n    allowed_extensions: list[str] = Field(\n        default=[\"jpg\", \"jpeg\", \"png\", \"gif\", \"webp\", \"svg\"],\n        description=\"Allowed file extensions\",\n    )\n    max_size: int | None = Field(default=None, description=\"Maximum file size in bytes\")\n\n    @field_validator(\"file\")\n    @classmethod\n    def validate_image_file(cls, v: FileStorage, info: pydantic.ValidationInfo) -&gt; FileStorage:\n        \"\"\"Validate that the file is an image with allowed extension and size.\n\n        Args:\n            v: The file to validate.\n            info: Validation context information.\n\n        Returns:\n            FileStorage: The validated file.\n\n        Raises:\n            ValueError: If the file is invalid, has a disallowed extension, or exceeds the maximum size.\n\n        \"\"\"\n        values = info.data\n\n        if not v or not v.filename:\n            msg = \"No file provided\"\n            raise ValueError(msg)\n\n        allowed_extensions = values.get(\"allowed_extensions\", [\"jpg\", \"jpeg\", \"png\", \"gif\", \"webp\", \"svg\"])\n        if \".\" in v.filename:\n            ext = v.filename.rsplit(\".\", 1)[1].lower()\n            if ext not in allowed_extensions:\n                msg = f\"File extension '{ext}' not allowed. Allowed extensions: {', '.join(allowed_extensions)}\"\n                raise ValueError(\n                    msg,\n                )\n\n        max_size = values.get(\"max_size\")\n        if max_size is not None:\n            v.seek(0, 2)\n            size = v.tell()\n            v.seek(0)\n\n            if size &gt; max_size:\n                msg = f\"File size ({size} bytes) exceeds maximum allowed size ({max_size} bytes)\"\n                raise ValueError(msg)\n\n        return v\n</code></pre>"},{"location":"api/models/#flask_x_openapi_schema.models.file_models.ImageUploadModel.validate_image_file","title":"<code>validate_image_file(v, info)</code>  <code>classmethod</code>","text":"<p>Validate that the file is an image with allowed extension and size.</p> <p>Parameters:</p> Name Type Description Default <code>v</code> <code>FileStorage</code> <p>The file to validate.</p> required <code>info</code> <code>ValidationInfo</code> <p>Validation context information.</p> required <p>Returns:</p> Name Type Description <code>FileStorage</code> <code>FileStorage</code> <p>The validated file.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the file is invalid, has a disallowed extension, or exceeds the maximum size.</p> Source code in <code>src/flask_x_openapi_schema/models/file_models.py</code> <pre><code>@field_validator(\"file\")\n@classmethod\ndef validate_image_file(cls, v: FileStorage, info: pydantic.ValidationInfo) -&gt; FileStorage:\n    \"\"\"Validate that the file is an image with allowed extension and size.\n\n    Args:\n        v: The file to validate.\n        info: Validation context information.\n\n    Returns:\n        FileStorage: The validated file.\n\n    Raises:\n        ValueError: If the file is invalid, has a disallowed extension, or exceeds the maximum size.\n\n    \"\"\"\n    values = info.data\n\n    if not v or not v.filename:\n        msg = \"No file provided\"\n        raise ValueError(msg)\n\n    allowed_extensions = values.get(\"allowed_extensions\", [\"jpg\", \"jpeg\", \"png\", \"gif\", \"webp\", \"svg\"])\n    if \".\" in v.filename:\n        ext = v.filename.rsplit(\".\", 1)[1].lower()\n        if ext not in allowed_extensions:\n            msg = f\"File extension '{ext}' not allowed. Allowed extensions: {', '.join(allowed_extensions)}\"\n            raise ValueError(\n                msg,\n            )\n\n    max_size = values.get(\"max_size\")\n    if max_size is not None:\n        v.seek(0, 2)\n        size = v.tell()\n        v.seek(0)\n\n        if size &gt; max_size:\n            msg = f\"File size ({size} bytes) exceeds maximum allowed size ({max_size} bytes)\"\n            raise ValueError(msg)\n\n    return v\n</code></pre>"},{"location":"api/models/#flask_x_openapi_schema.models.file_models.MultipleFileUploadModel","title":"<code>MultipleFileUploadModel</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Model for multiple file uploads.</p> <p>This model allows uploading multiple files at once and validates that all files are valid FileStorage instances.</p> <p>Attributes:</p> Name Type Description <code>files</code> <code>list[FileStorage]</code> <p>List of uploaded files.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from flask_x_openapi_schema.models.file_models import MultipleFileUploadModel\n&gt;&gt;&gt; # Example usage in a Flask route\n&gt;&gt;&gt; # @openapi_metadata(summary=\"Upload multiple files\")\n&gt;&gt;&gt; # def post(self, _x_file: MultipleFileUploadModel):\n&gt;&gt;&gt; #     return {\"filenames\": [f.filename for f in _x_file.files]}\n</code></pre> Source code in <code>src/flask_x_openapi_schema/models/file_models.py</code> <pre><code>class MultipleFileUploadModel(BaseModel):\n    \"\"\"Model for multiple file uploads.\n\n    This model allows uploading multiple files at once and validates that all files\n    are valid FileStorage instances.\n\n    Attributes:\n        files: List of uploaded files.\n\n    Examples:\n        &gt;&gt;&gt; from flask_x_openapi_schema.models.file_models import MultipleFileUploadModel\n        &gt;&gt;&gt; # Example usage in a Flask route\n        &gt;&gt;&gt; # @openapi_metadata(summary=\"Upload multiple files\")\n        &gt;&gt;&gt; # def post(self, _x_file: MultipleFileUploadModel):\n        &gt;&gt;&gt; #     return {\"filenames\": [f.filename for f in _x_file.files]}\n\n    \"\"\"\n\n    files: list[FileStorage] = Field(..., description=\"The uploaded files\")\n\n    model_config = {\"arbitrary_types_allowed\": True}\n\n    @field_validator(\"files\")\n    @classmethod\n    def validate_files(cls, v: list[Any]) -&gt; list[FileStorage]:\n        \"\"\"Validate that all files are FileStorage instances.\n\n        Args:\n            v: List of values to validate.\n\n        Returns:\n            list[FileStorage]: The validated list of FileStorage instances.\n\n        Raises:\n            ValueError: If the list is empty or contains non-FileStorage objects.\n\n        \"\"\"\n        if not v:\n            msg = \"No files provided\"\n            raise ValueError(msg)\n\n        for file in v:\n            if not isinstance(file, FileStorage):\n                msg = \"Not a valid file upload\"\n                raise ValueError(msg)\n\n        return v\n</code></pre>"},{"location":"api/models/#flask_x_openapi_schema.models.file_models.MultipleFileUploadModel.validate_files","title":"<code>validate_files(v)</code>  <code>classmethod</code>","text":"<p>Validate that all files are FileStorage instances.</p> <p>Parameters:</p> Name Type Description Default <code>v</code> <code>list[Any]</code> <p>List of values to validate.</p> required <p>Returns:</p> Type Description <code>list[FileStorage]</code> <p>list[FileStorage]: The validated list of FileStorage instances.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the list is empty or contains non-FileStorage objects.</p> Source code in <code>src/flask_x_openapi_schema/models/file_models.py</code> <pre><code>@field_validator(\"files\")\n@classmethod\ndef validate_files(cls, v: list[Any]) -&gt; list[FileStorage]:\n    \"\"\"Validate that all files are FileStorage instances.\n\n    Args:\n        v: List of values to validate.\n\n    Returns:\n        list[FileStorage]: The validated list of FileStorage instances.\n\n    Raises:\n        ValueError: If the list is empty or contains non-FileStorage objects.\n\n    \"\"\"\n    if not v:\n        msg = \"No files provided\"\n        raise ValueError(msg)\n\n    for file in v:\n        if not isinstance(file, FileStorage):\n            msg = \"Not a valid file upload\"\n            raise ValueError(msg)\n\n    return v\n</code></pre>"},{"location":"api/models/#flask_x_openapi_schema.models.file_models.PDFField","title":"<code>PDFField</code>","text":"<p>               Bases: <code>FileField</code></p> <p>Field for PDF file uploads in OpenAPI schema.</p> Source code in <code>src/flask_x_openapi_schema/models/file_models.py</code> <pre><code>class PDFField(FileField):\n    \"\"\"Field for PDF file uploads in OpenAPI schema.\"\"\"\n</code></pre>"},{"location":"api/models/#flask_x_openapi_schema.models.file_models.TextField","title":"<code>TextField</code>","text":"<p>               Bases: <code>FileField</code></p> <p>Field for text file uploads in OpenAPI schema.</p> Source code in <code>src/flask_x_openapi_schema/models/file_models.py</code> <pre><code>class TextField(FileField):\n    \"\"\"Field for text file uploads in OpenAPI schema.\"\"\"\n</code></pre>"},{"location":"api/models/#flask_x_openapi_schema.models.file_models.VideoField","title":"<code>VideoField</code>","text":"<p>               Bases: <code>FileField</code></p> <p>Field for video file uploads in OpenAPI schema.</p> Source code in <code>src/flask_x_openapi_schema/models/file_models.py</code> <pre><code>class VideoField(FileField):\n    \"\"\"Field for video file uploads in OpenAPI schema.\"\"\"\n</code></pre>"},{"location":"api/models/#response-models","title":"Response Models","text":"<p>Response models for OpenAPI schema generation.</p> <p>This module provides models for defining OpenAPI responses in a structured way. It includes classes and helper functions to create and manage response definitions for OpenAPI schema generation.</p>"},{"location":"api/models/#flask_x_openapi_schema.models.responses.OpenAPIMetaResponse","title":"<code>OpenAPIMetaResponse</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Container for OpenAPI response definitions.</p> <p>This class allows defining multiple responses for different status codes. It is used to define all possible responses for an API endpoint in the OpenAPI schema.</p> <p>Attributes:</p> Name Type Description <code>responses</code> <code>dict[str, OpenAPIMetaResponseItem]</code> <p>Map of status codes to response definitions.</p> <code>default_error_response</code> <code>type[BaseErrorResponse]</code> <p>Default error response class for validation errors. Must be a subclass of BaseErrorResponse.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from flask_x_openapi_schema.models.responses import OpenAPIMetaResponse, OpenAPIMetaResponseItem\n&gt;&gt;&gt; from pydantic import BaseModel\n&gt;&gt;&gt;\n&gt;&gt;&gt; class UserResponse(BaseModel):\n...     id: str\n...     name: str\n&gt;&gt;&gt; class ErrorResponse(BaseModel):\n...     error: str\n...     code: int\n&gt;&gt;&gt; responses = OpenAPIMetaResponse(\n...     responses={\n...         \"200\": OpenAPIMetaResponseItem(\n...             model=UserResponse, description=\"User details retrieved successfully\"\n...         ),\n...         \"404\": OpenAPIMetaResponseItem(model=ErrorResponse, description=\"User not found\"),\n...     }\n... )\n</code></pre> Source code in <code>src/flask_x_openapi_schema/models/responses.py</code> <pre><code>class OpenAPIMetaResponse(BaseModel):\n    \"\"\"Container for OpenAPI response definitions.\n\n    This class allows defining multiple responses for different status codes.\n    It is used to define all possible responses for an API endpoint in the OpenAPI schema.\n\n    Attributes:\n        responses: Map of status codes to response definitions.\n        default_error_response: Default error response class for validation errors.\n            Must be a subclass of BaseErrorResponse.\n\n    Examples:\n        &gt;&gt;&gt; from flask_x_openapi_schema.models.responses import OpenAPIMetaResponse, OpenAPIMetaResponseItem\n        &gt;&gt;&gt; from pydantic import BaseModel\n        &gt;&gt;&gt;\n        &gt;&gt;&gt; class UserResponse(BaseModel):\n        ...     id: str\n        ...     name: str\n        &gt;&gt;&gt; class ErrorResponse(BaseModel):\n        ...     error: str\n        ...     code: int\n        &gt;&gt;&gt; responses = OpenAPIMetaResponse(\n        ...     responses={\n        ...         \"200\": OpenAPIMetaResponseItem(\n        ...             model=UserResponse, description=\"User details retrieved successfully\"\n        ...         ),\n        ...         \"404\": OpenAPIMetaResponseItem(model=ErrorResponse, description=\"User not found\"),\n        ...     }\n        ... )\n\n    \"\"\"\n\n    default_error_response: type[BaseErrorResponse] = Field(\n        default=BaseErrorResponse,\n        description=\"Default error response class for validation errors\",\n    )\n\n    responses: dict[str, OpenAPIMetaResponseItem] = Field(\n        ...,\n        description=\"Map of status codes to response definitions\",\n    )\n\n    def to_openapi_dict(self) -&gt; dict[str, Any]:\n        \"\"\"Convert the response container to an OpenAPI responses object.\n\n        Returns:\n            dict: An OpenAPI responses object dictionary.\n\n        \"\"\"\n        result = {}\n        for status_code, response_item in self.responses.items():\n            result[status_code] = response_item.to_openapi_dict()\n        return result\n</code></pre>"},{"location":"api/models/#flask_x_openapi_schema.models.responses.OpenAPIMetaResponse.to_openapi_dict","title":"<code>to_openapi_dict()</code>","text":"<p>Convert the response container to an OpenAPI responses object.</p> <p>Returns:</p> Name Type Description <code>dict</code> <code>dict[str, Any]</code> <p>An OpenAPI responses object dictionary.</p> Source code in <code>src/flask_x_openapi_schema/models/responses.py</code> <pre><code>def to_openapi_dict(self) -&gt; dict[str, Any]:\n    \"\"\"Convert the response container to an OpenAPI responses object.\n\n    Returns:\n        dict: An OpenAPI responses object dictionary.\n\n    \"\"\"\n    result = {}\n    for status_code, response_item in self.responses.items():\n        result[status_code] = response_item.to_openapi_dict()\n    return result\n</code></pre>"},{"location":"api/models/#flask_x_openapi_schema.models.responses.OpenAPIMetaResponseItem","title":"<code>OpenAPIMetaResponseItem</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Represents a single response item in an OpenAPI specification.</p> <p>This class allows defining a response with either a Pydantic model or a simple message. It is used to define the response for a specific status code in the OpenAPI schema.</p> <p>Attributes:</p> Name Type Description <code>model</code> <code>type[BaseModel] | None</code> <p>Pydantic model for the response.</p> <code>description</code> <code>str</code> <p>Response description.</p> <code>content_type</code> <code>str</code> <p>Response content type.</p> <code>headers</code> <code>dict[str, Any] | None</code> <p>Response headers.</p> <code>examples</code> <code>dict[str, Any] | None</code> <p>Response examples.</p> <code>msg</code> <code>str | None</code> <p>Simple message for responses without a model.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from flask_x_openapi_schema.models.responses import OpenAPIMetaResponseItem\n&gt;&gt;&gt; from pydantic import BaseModel\n&gt;&gt;&gt;\n&gt;&gt;&gt; class UserResponse(BaseModel):\n...     id: str\n...     name: str\n&gt;&gt;&gt; response_item = OpenAPIMetaResponseItem(\n...     model=UserResponse, description=\"User details\", content_type=\"application/json\"\n... )\n</code></pre> Source code in <code>src/flask_x_openapi_schema/models/responses.py</code> <pre><code>class OpenAPIMetaResponseItem(BaseModel):\n    \"\"\"Represents a single response item in an OpenAPI specification.\n\n    This class allows defining a response with either a Pydantic model or a simple message.\n    It is used to define the response for a specific status code in the OpenAPI schema.\n\n    Attributes:\n        model: Pydantic model for the response.\n        description: Response description.\n        content_type: Response content type.\n        headers: Response headers.\n        examples: Response examples.\n        msg: Simple message for responses without a model.\n\n    Examples:\n        &gt;&gt;&gt; from flask_x_openapi_schema.models.responses import OpenAPIMetaResponseItem\n        &gt;&gt;&gt; from pydantic import BaseModel\n        &gt;&gt;&gt;\n        &gt;&gt;&gt; class UserResponse(BaseModel):\n        ...     id: str\n        ...     name: str\n        &gt;&gt;&gt; response_item = OpenAPIMetaResponseItem(\n        ...     model=UserResponse, description=\"User details\", content_type=\"application/json\"\n        ... )\n\n    \"\"\"\n\n    model: type[BaseModel] | None = Field(None, description=\"Pydantic model for the response\")\n    description: str = Field(\"Successful response\", description=\"Response description\")\n    content_type: str = Field(\"application/json\", description=\"Response content type\")\n    headers: dict[str, Any] | None = Field(None, description=\"Response headers\")\n    examples: dict[str, Any] | None = Field(None, description=\"Response examples\")\n    msg: str | None = Field(None, description=\"Simple message for responses without a model\")\n\n    def to_openapi_dict(self) -&gt; dict[str, Any]:\n        \"\"\"Convert the response item to an OpenAPI response object.\n\n        Returns:\n            dict: An OpenAPI response object dictionary.\n\n        \"\"\"\n        response = {\"description\": self.description}\n\n        if self.model:\n            response[\"content\"] = {\n                self.content_type: {\"schema\": {\"$ref\": f\"#/components/schemas/{self.model.__name__}\"}},\n            }\n\n            if self.examples:\n                response[\"content\"][self.content_type][\"examples\"] = self.examples\n\n        if self.headers:\n            response[\"headers\"] = self.headers\n\n        return response\n</code></pre>"},{"location":"api/models/#flask_x_openapi_schema.models.responses.OpenAPIMetaResponseItem.to_openapi_dict","title":"<code>to_openapi_dict()</code>","text":"<p>Convert the response item to an OpenAPI response object.</p> <p>Returns:</p> Name Type Description <code>dict</code> <code>dict[str, Any]</code> <p>An OpenAPI response object dictionary.</p> Source code in <code>src/flask_x_openapi_schema/models/responses.py</code> <pre><code>def to_openapi_dict(self) -&gt; dict[str, Any]:\n    \"\"\"Convert the response item to an OpenAPI response object.\n\n    Returns:\n        dict: An OpenAPI response object dictionary.\n\n    \"\"\"\n    response = {\"description\": self.description}\n\n    if self.model:\n        response[\"content\"] = {\n            self.content_type: {\"schema\": {\"$ref\": f\"#/components/schemas/{self.model.__name__}\"}},\n        }\n\n        if self.examples:\n            response[\"content\"][self.content_type][\"examples\"] = self.examples\n\n    if self.headers:\n        response[\"headers\"] = self.headers\n\n    return response\n</code></pre>"},{"location":"api/models/#flask_x_openapi_schema.models.responses.create_response","title":"<code>create_response(model=None, description='Successful response', status_code=200, content_type='application/json', headers=None, examples=None, msg=None)</code>","text":"<p>Create a response definition for use with OpenAPIMetaResponse.</p> <p>This is a helper function to create a response definition for a specific status code. It returns a dictionary that can be used to build an OpenAPIMetaResponse object.</p> <p>Parameters:</p> Name Type Description Default <code>model</code> <code>type[BaseModel] | None</code> <p>Pydantic model for the response.</p> <code>None</code> <code>description</code> <code>str</code> <p>Response description.</p> <code>'Successful response'</code> <code>status_code</code> <code>int | str</code> <p>HTTP status code.</p> <code>200</code> <code>content_type</code> <code>str</code> <p>Response content type.</p> <code>'application/json'</code> <code>headers</code> <code>dict[str, Any] | None</code> <p>Response headers.</p> <code>None</code> <code>examples</code> <code>dict[str, Any] | None</code> <p>Response examples.</p> <code>None</code> <code>msg</code> <code>str | None</code> <p>Simple message for responses without a model.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>dict</code> <code>dict[str, OpenAPIMetaResponseItem]</code> <p>A dictionary with the status code as key and response item as value.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from flask_x_openapi_schema.models.responses import create_response, OpenAPIMetaResponse\n&gt;&gt;&gt; from pydantic import BaseModel\n&gt;&gt;&gt;\n&gt;&gt;&gt; class UserResponse(BaseModel):\n...     id: str\n...     name: str\n&gt;&gt;&gt;\n&gt;&gt;&gt; user_response = create_response(model=UserResponse, description=\"User details\", status_code=200)\n&gt;&gt;&gt;\n&gt;&gt;&gt; not_found_response = create_response(msg=\"User not found\", description=\"User not found\", status_code=404)\n&gt;&gt;&gt;\n&gt;&gt;&gt; responses = OpenAPIMetaResponse(responses={**user_response, **not_found_response})\n</code></pre> Source code in <code>src/flask_x_openapi_schema/models/responses.py</code> <pre><code>def create_response(\n    model: type[BaseModel] | None = None,\n    description: str = \"Successful response\",\n    status_code: int | str = 200,\n    content_type: str = \"application/json\",\n    headers: dict[str, Any] | None = None,\n    examples: dict[str, Any] | None = None,\n    msg: str | None = None,\n) -&gt; dict[str, OpenAPIMetaResponseItem]:\n    \"\"\"Create a response definition for use with OpenAPIMetaResponse.\n\n    This is a helper function to create a response definition for a specific status code.\n    It returns a dictionary that can be used to build an OpenAPIMetaResponse object.\n\n    Args:\n        model: Pydantic model for the response.\n        description: Response description.\n        status_code: HTTP status code.\n        content_type: Response content type.\n        headers: Response headers.\n        examples: Response examples.\n        msg: Simple message for responses without a model.\n\n    Returns:\n        dict: A dictionary with the status code as key and response item as value.\n\n    Examples:\n        &gt;&gt;&gt; from flask_x_openapi_schema.models.responses import create_response, OpenAPIMetaResponse\n        &gt;&gt;&gt; from pydantic import BaseModel\n        &gt;&gt;&gt;\n        &gt;&gt;&gt; class UserResponse(BaseModel):\n        ...     id: str\n        ...     name: str\n        &gt;&gt;&gt;\n        &gt;&gt;&gt; user_response = create_response(model=UserResponse, description=\"User details\", status_code=200)\n        &gt;&gt;&gt;\n        &gt;&gt;&gt; not_found_response = create_response(msg=\"User not found\", description=\"User not found\", status_code=404)\n        &gt;&gt;&gt;\n        &gt;&gt;&gt; responses = OpenAPIMetaResponse(responses={**user_response, **not_found_response})\n\n    \"\"\"\n    return {\n        str(status_code): OpenAPIMetaResponseItem(\n            model=model,\n            description=description,\n            content_type=content_type,\n            headers=headers,\n            examples=examples,\n            msg=msg,\n        ),\n    }\n</code></pre>"},{"location":"api/models/#flask_x_openapi_schema.models.responses.error_response","title":"<code>error_response(description, status_code=400, model=None, content_type='application/json', headers=None, examples=None, msg=None)</code>","text":"<p>Create an error response definition for use with OpenAPIMetaResponse.</p> <p>This is a convenience function to create an error response with a description.</p> <p>Parameters:</p> Name Type Description Default <code>description</code> <code>str</code> <p>Response description.</p> required <code>status_code</code> <code>int | str</code> <p>HTTP status code.</p> <code>400</code> <code>model</code> <code>type[BaseModel] | None</code> <p>Optional Pydantic model for the response.</p> <code>None</code> <code>content_type</code> <code>str</code> <p>Response content type.</p> <code>'application/json'</code> <code>headers</code> <code>dict[str, Any] | None</code> <p>Response headers.</p> <code>None</code> <code>examples</code> <code>dict[str, Any] | None</code> <p>Response examples.</p> <code>None</code> <code>msg</code> <code>str | None</code> <p>Simple message for responses without a model.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>dict</code> <code>dict[str, OpenAPIMetaResponseItem]</code> <p>A dictionary with the status code as key and response item as value.</p> Source code in <code>src/flask_x_openapi_schema/models/responses.py</code> <pre><code>def error_response(\n    description: str,\n    status_code: int | str = 400,\n    model: type[BaseModel] | None = None,\n    content_type: str = \"application/json\",\n    headers: dict[str, Any] | None = None,\n    examples: dict[str, Any] | None = None,\n    msg: str | None = None,\n) -&gt; dict[str, OpenAPIMetaResponseItem]:\n    \"\"\"Create an error response definition for use with OpenAPIMetaResponse.\n\n    This is a convenience function to create an error response with a description.\n\n    Args:\n        description: Response description.\n        status_code: HTTP status code.\n        model: Optional Pydantic model for the response.\n        content_type: Response content type.\n        headers: Response headers.\n        examples: Response examples.\n        msg: Simple message for responses without a model.\n\n    Returns:\n        dict: A dictionary with the status code as key and response item as value.\n\n    \"\"\"\n    return create_response(\n        model=model,\n        description=description,\n        status_code=status_code,\n        content_type=content_type,\n        headers=headers,\n        examples=examples,\n        msg=msg,\n    )\n</code></pre>"},{"location":"api/models/#flask_x_openapi_schema.models.responses.success_response","title":"<code>success_response(model, description='Successful response', status_code=200, content_type='application/json', headers=None, examples=None)</code>","text":"<p>Create a success response definition for use with OpenAPIMetaResponse.</p> <p>This is a convenience function to create a success response with a model.</p> <p>Parameters:</p> Name Type Description Default <code>model</code> <code>type[BaseModel]</code> <p>Pydantic model for the response.</p> required <code>description</code> <code>str</code> <p>Response description.</p> <code>'Successful response'</code> <code>status_code</code> <code>int | str</code> <p>HTTP status code.</p> <code>200</code> <code>content_type</code> <code>str</code> <p>Response content type.</p> <code>'application/json'</code> <code>headers</code> <code>dict[str, Any] | None</code> <p>Response headers.</p> <code>None</code> <code>examples</code> <code>dict[str, Any] | None</code> <p>Response examples.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>dict</code> <code>dict[str, OpenAPIMetaResponseItem]</code> <p>A dictionary with the status code as key and response item as value.</p> Source code in <code>src/flask_x_openapi_schema/models/responses.py</code> <pre><code>def success_response(\n    model: type[BaseModel],\n    description: str = \"Successful response\",\n    status_code: int | str = 200,\n    content_type: str = \"application/json\",\n    headers: dict[str, Any] | None = None,\n    examples: dict[str, Any] | None = None,\n) -&gt; dict[str, OpenAPIMetaResponseItem]:\n    \"\"\"Create a success response definition for use with OpenAPIMetaResponse.\n\n    This is a convenience function to create a success response with a model.\n\n    Args:\n        model: Pydantic model for the response.\n        description: Response description.\n        status_code: HTTP status code.\n        content_type: Response content type.\n        headers: Response headers.\n        examples: Response examples.\n\n    Returns:\n        dict: A dictionary with the status code as key and response item as value.\n\n    \"\"\"\n    return create_response(\n        model=model,\n        description=description,\n        status_code=status_code,\n        content_type=content_type,\n        headers=headers,\n        examples=examples,\n    )\n</code></pre>"}]}